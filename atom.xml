<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WaiBlog|码农的技术小窝</title>
  
  <subtitle>所有的努力都值得期许，每一份梦想都应该灌溉！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://waisunny.com/"/>
  <updated>2018-01-29T09:09:03.667Z</updated>
  <id>http://waisunny.com/</id>
  
  <author>
    <name>_learner</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python序列化模块json和pickle</title>
    <link href="http://waisunny.com/2018/01/30/python%E5%BA%8F%E5%88%97%E5%8C%96%E6%A8%A1%E5%9D%97json%E5%92%8Cpickle/"/>
    <id>http://waisunny.com/2018/01/30/python序列化模块json和pickle/</id>
    <published>2018-01-29T16:06:58.000Z</published>
    <updated>2018-01-29T09:09:03.667Z</updated>
    
    <content type="html"><![CDATA[<p>什么是序列化？</p><p>我们把对象(变量)从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling，在其他语言中也被称之为serialization，marshalling，flattening等等，都是一个意思。</p><p>序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。</p><p>反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。<br><a id="more"></a></p><h1 id="json"><a href="#json" class="headerlink" title="json"></a>json</h1><p>如果我们要在不同的编程语言之间传递对象，就必须把对象序列化为标准格式，比如XML，但更好的方法是序列化为JSON，因为JSON表示出来就是一个字符串，可以被所有语言读取，也可以方便地存储到磁盘或者通过网络传输。JSON不仅是标准格式，并且比XML更快，而且可以直接在Web页面中读取，非常方便。<br>JSON表示的对象就是标准的JavaScript语言的对象，JSON和Python内置的数据类型对应如下：<br><img src="https://i.imgur.com/4a221yG.png" alt=""></p><p>Json模块提供了四个功能：dumps、dump、loads、load 。</p><pre><code>import jsondic = {&apos;name&apos;: &apos;_learner&apos;, &apos;age&apos;: 23, &apos;sex&apos;: &apos;male&apos;}print(type(dic))  # &lt;class &apos;dict&apos;&gt;# -----------------------------序列化j = json.dumps(dic)print(type(j))  # &lt;class &apos;str&apos;&gt;f = open(&apos;file.txt&apos;, &apos;w&apos;)f.write(j)  # 等价于json.dump(dic,f)f.close()# -----------------------------反序列化f = open(&apos;file.txt&apos;)data = json.loads(f.read())  # 等价于data=json.load(f)print(data) # {&apos;name&apos;: &apos;_learner&apos;, &apos;age&apos;: 23, &apos;sex&apos;: &apos;male&apos;}</code></pre><h2 id="使用json注意事项"><a href="#使用json注意事项" class="headerlink" title="使用json注意事项"></a>使用json注意事项</h2><pre><code>import json#dic={&apos;1&apos;:111} #json.loads方法只接受字符串参数#print(json.loads(dic)) # TypeError: the JSON object must be str, bytes or bytearray, not &apos;dict&apos;#dic=&quot;{&apos;1&apos;:111}&quot;   # json 不认单引号#print(json.loads(dic)) # json.decoder.JSONDecodeError: Expecting property name enclosed in double quotes#dic=str({&quot;1&quot;:111})# 报错,因为生成的数据还是单引号:{&apos;one&apos;: 1}#print(json.loads(dic)) # json.decoder.JSONDecodeError: Expecting property name enclosed in double quotesdic=&apos;{&quot;1&quot;:111}&apos;print(json.loads(dic))# {&apos;1&apos;: 111}</code></pre><p>json不认单引号；另外，无论数据是怎样创建的，只要满足json格式，就可以json.loads出来,不一定非要dumps的数据才能loads。</p><h1 id="pickle"><a href="#pickle" class="headerlink" title="pickle"></a>pickle</h1><p>pickle是python特有的序列化方式，只能在python间使用。</p><p>pickle模块也提供了四个功能：dumps、dump、loads、load。</p><pre><code>import pickledic = {&apos;name&apos;: &apos;_learner&apos;, &apos;age&apos;: 23, &apos;sex&apos;: &apos;male&apos;}print(type(dic))  # &lt;class &apos;dict&apos;&gt;##-------------------------序列化j = pickle.dumps(dic)print(type(j))  # &lt;class &apos;bytes&apos;&gt;f = open(&apos;file_pickle&apos;, &apos;wb&apos;)  # 注意w是写入str,wb是写入bytes,j是&apos;bytes&apos;类型的f.write(j)  # -------------------等价于pickle.dump(dic,f)f.close()# -------------------------反序列化f = open(&apos;file_pickle&apos;, &apos;rb&apos;)data = pickle.loads(f.read())  # 等价于data=pickle.load(f)print(data[&apos;age&apos;]) # 23</code></pre><h1 id="pickle和json区别"><a href="#pickle和json区别" class="headerlink" title="pickle和json区别"></a>pickle和json区别</h1><p>json是可以在不同语言之间交换数据的，而pickle只在python之间使用。</p><p>json只能序列化最基本的数据类型，而pickle可以序列化所有的数据类型，包括类，函数都可以序列化。</p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>在这里介绍一下shelve模块，它也是一种序列化数据的方式。</p><p>shelve模块比pickle模块简单，只有一个open函数，返回类似字典的对象，可读可写;key必须为字符串，而值可以是python所支持的数据类型。</p><pre><code>import shelvef = shelve.open(r&apos;shelve.txt&apos;)f[&apos;stu_info&apos;]={&apos;name&apos;:&apos;_learner&apos;,&apos;age&apos;:&apos;23&apos;}f.close()f = shelve.open(r&apos;shelve.txt&apos;,&apos;r&apos;)print(f.get(&apos;stu_info&apos;)[&apos;age&apos;])f.close()</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是序列化？&lt;/p&gt;
&lt;p&gt;我们把对象(变量)从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling，在其他语言中也被称之为serialization，marshalling，flattening等等，都是一个意思。&lt;/p&gt;
&lt;p&gt;序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。&lt;/p&gt;
&lt;p&gt;反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://waisunny.com/categories/Python/"/>
    
    
      <category term="python模块" scheme="http://waisunny.com/tags/python%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>python中的super()函数</title>
    <link href="http://waisunny.com/2018/01/23/python%E4%B8%AD%E7%9A%84super-%E5%87%BD%E6%95%B0/"/>
    <id>http://waisunny.com/2018/01/23/python中的super-函数/</id>
    <published>2018-01-23T14:50:41.000Z</published>
    <updated>2018-01-29T09:08:54.593Z</updated>
    
    <content type="html"><![CDATA[<p>super() 函数用于调用下一个父类(超类)并返回该父类的实例，主要用途是来查找父类的属性，比如 ，<br>super(MyClass,self).__init__()。它只能用在新式类中。</p><p>语法如下：</p><pre><code>super(type[, obj])</code></pre><p>super()“返回此 type 的父类”。如果你希望父类被绑定,你可以传入 obj 参数(obj必须是 type 类型的)。否则父类不会被绑定。obj 参数也可以是一个类型，但它应当是 type 的一个子类。通常，当给出 obj 时：</p><ol><li>如果 obj 是一个实例，<strong>isinstance(obj,type)</strong>就必须返回 True</li><li>如果 obj 是一个类或类型，<strong>issubclass(obj,type)</strong>就必须返回 True<a id="more"></a></li></ol><h1 id="super函数的作用"><a href="#super函数的作用" class="headerlink" title="super函数的作用"></a>super函数的作用</h1><p>使用 super()的漂亮之处在于，你不需要明确给出任何基类名字… “跑腿事儿”，它帮你干了！</p><p>使用 super()的重点，是你不需要明确提供父类。这意味着如果你改变了类继承关系，你只需要改一<br>行代码（class 语句本身）而不必在大量代码中去查找所有被修改的那个类的名字。</p><p>在多重继承的情况下会涉及到查找顺序（<strong>MRO</strong>）、重复调用等种种问题。使用super()来避免这些问题。</p><p><strong>MRO</strong> 就是类的方法解析顺序表, 其实也就是继承父类方法时的顺序表,下面会介绍到。</p><p>下面我们通过对比使用 super函数和基类类名调用父类方法来介绍super函数的作用：</p><!--more--><h2 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h2><p>先看一个单继承的例子：</p><pre><code>class BaseCls(object):    def __init__(self,name):        print(&apos;Create BaseCls,name is %s&apos;%name)        self.name=nameclass ChildA(BaseCls):    def __init__(self,name):        print(&apos;Create ChildA&apos;)        BaseCls.__init__(self,name)class ChildB(BaseCls):    def __init__(self,name):        print(&apos;Create ChildB&apos;)        super(ChildB,self).__init__(name)a=ChildA(&apos;_learner1&apos;)b=ChildB(&apos;_learner2&apos;)</code></pre><p>运行结果：</p><pre><code>Create ChildACreate BaseCls,name is _learner1Create ChildBCreate BaseCls,name is _learner2</code></pre><p><strong>区别是使用super()继承时不用显式引用基类。避免类名发生变化时我们需要调整继承的代码。</strong></p><h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><h3 id="继承顺序问题"><a href="#继承顺序问题" class="headerlink" title="继承顺序问题"></a>继承顺序问题</h3><p>在多重继承时会涉及继承顺序，<font size="4" color="red"><strong>super()相当于返回继承顺序的下一个类，而不是父类</strong></font>，类似于这样的功能：</p><pre><code>def super(class_name, self):      mro = self.__class__.mro()      return mro[mro.index(class_name) + 1]  </code></pre><p>mro()用来获得类的继承顺序。 例如：</p><pre><code>class Base(object):    def __init__(self):        print(&apos;Base Create&apos;)class ChildA(Base):    def __init__(self):        print(&apos;enter A &apos;)        super(ChildA, self).__init__()        print (&apos;leave A&apos;)class ChildB(Base):    def __init__(self):        print(&apos;enter B &apos; )        super(ChildB, self).__init__()        print (&apos;leave B&apos;)class ChildC(ChildA, ChildB):    passc = ChildC()print (c.__class__.__mro__ )</code></pre><p>运行结果：</p><pre><code>enter A enter B Base createleave Bleave A(&lt;class &apos;__main__.childC&apos;&gt;, &lt;class &apos;__main__.ChildA&apos;&gt;, &lt;class &apos;__main__.ChildB&apos;&gt;, &lt;class &apos;__main__.Base&apos;&gt;, &lt;class &apos;object&apos;&gt;)</code></pre><p>supder和父类没有关联，因此执行顺序是 A —&gt; B—&gt;—&gt;Base</p><p>执行过程相当于：</p><ol><li>初始化childC()时，先会去调用childA的构造方法__init__,输出 enter A;</li><li>然后执行super(childA, self).<strong>init</strong>()， super(ChildA, self)返回当前类的继承顺序中ChildA后的一个类childB;</li><li>因此会进入到childB类执行器构造方法输出 enter B;</li><li>然后执行 super(ChildB, self).<strong>init</strong>()，返回继承顺序的下一个类，即Base;</li><li>执行Base类的__init__构造方法，输出 Base Create；</li><li>然后继续执行，输出 leave B,最后就是 leave A。</li></ol><p>在上面的例子中，如果把继承方式由super换成Base.<em>init</em>(self)，会看到什么样的输出结果呢？</p><pre><code>class Base(object):    def __init__(self):        print(&apos;Base create&apos;)class ChildA(Base):    def __init__(self):        print(&apos;enter A &apos;)        Base.__init__(self)        print (&apos;leave A&apos;)class ChildB(Base):    def __init__(self):        print(&apos;enter B &apos; )        Base.__init__(self)        print (&apos;leave B&apos;)class childC(ChildA, ChildB):    passc = childC()print (c.__class__.__mro__ )</code></pre><p>运行结果：</p><pre><code>enter A Base createleave A(&lt;class &apos;__main__.childC&apos;&gt;, &lt;class &apos;__main__.ChildA&apos;&gt;, &lt;class &apos;__main__.ChildB&apos;&gt;, &lt;class &apos;__main__.Base&apos;&gt;, &lt;class &apos;object&apos;&gt;)</code></pre><p>能看出，继承ChildA后就会直接跳到Base类里，而略过了ChildB。</p><h3 id="重复调用问题"><a href="#重复调用问题" class="headerlink" title="重复调用问题"></a>重复调用问题</h3><p>如果ChildA基础Base, ChildB继承childA和Base，如果ChildB需要调用Base的<strong>init</strong>()方法时，就会导致__init__()被执行两次：</p><pre><code>class Base(object):    def __init__(self):        print(&apos;Base create&apos;)class ChildA(Base):    def __init__(self):        print(&apos;enter A &apos;)        Base.__init__(self)        print(&apos;leave A&apos;)class ChildB(ChildA, Base):    def __init__(self):        print(&apos;enter B&apos;)        ChildA.__init__(self)        Base.__init__(self)b = ChildB()print (b.__class__.mro())</code></pre><p>运行结果：</p><pre><code>enter Benter A Base createleave ABase create[&lt;class &apos;__main__.ChildB&apos;&gt;, &lt;class &apos;__main__.ChildA&apos;&gt;, &lt;class &apos;__main__.Base&apos;&gt;, &lt;class &apos;object&apos;&gt;]</code></pre><p>使用super()函数可避免重复调用：</p><pre><code>class Base(object):    def __init__(self):        print(&apos;Base create&apos;)class ChildA(Base):    def __init__(self):        print(&apos;enter A &apos;)        super(ChildA, self).__init__()        print(&apos;leave A&apos;)class ChildB(ChildA, Base):    def __init__(self):        print(&apos;enter B&apos;)        super(ChildB,self).__init__()b = ChildB()print (b.__class__.mro())  </code></pre><p>运行结果：</p><pre><code>enter Benter A Base createleave A[&lt;class &apos;__main__.ChildB&apos;&gt;, &lt;class &apos;__main__.ChildA&apos;&gt;, &lt;class &apos;__main__.Base&apos;&gt;, &lt;class &apos;object&apos;&gt;]</code></pre><h1 id="super-函数使用注意点"><a href="#super-函数使用注意点" class="headerlink" title="super()函数使用注意点"></a>super()函数使用注意点</h1><p>从super()方法可以看出，super()的第一个参数可以是继承链中任意一个类的名字。</p><p>如果是本身就会依次继承下一个类；</p><p>如果是继承链里之前的类便会无限递归下去；</p><p>如果是继承链里之后的类便会忽略继承链汇总本身和传入类之间的类；</p><p>看例子:</p><p>将ChildA()中的super改为：super(ChildC, self).<strong>init</strong>()，程序就会无限递归下去:</p><pre><code>class Base(object):    def __init__(self):        print(&apos;Base Create&apos;)class ChildA(Base):    def __init__(self):        print(&apos;enter A &apos;)        super(ChildC, self).__init__()        print (&apos;leave A&apos;)class ChildB(Base):    def __init__(self):        print(&apos;enter B &apos; )        super(ChildB, self).__init__()        print (&apos;leave B&apos;)class ChildC(ChildA, ChildB):    passc = ChildC()</code></pre><p>运行结果：</p><pre><code>enter A enter A enter A enter A enter A Traceback (most recent call last):RecursionError: maximum recursion depth exceeded while calling a Python object</code></pre><p>将ChildA()中的super改为：super(ChildB, self).<strong>init</strong>()，程序就会跳过ChildB:</p><pre><code>class Base(object):    def __init__(self):        print(&apos;Base Create&apos;)class ChildA(Base):    def __init__(self):        print(&apos;enter A &apos;)        super(ChildB, self).__init__()        print (&apos;leave A&apos;)class ChildB(Base):    def __init__(self):        print(&apos;enter B &apos; )        super(ChildB, self).__init__()        print (&apos;leave B&apos;)class ChildC(ChildA, ChildB):    passc = ChildC()</code></pre><p>运行结果：</p><pre><code>enter A Base Createleave A</code></pre><p>另外，super函数只能应用在新式类中，用在经典类中会报错的：</p><pre><code>class A:    def __init__(self):        print(&apos;Create A&apos;)class B(A):    def __init__(self):        print(&apos;Create B&apos;)        super(B,self).__init__()b=B()</code></pre><p>运行结果:</p><pre><code>Create BTraceback (most recent call last):     super(B,self).__init__()TypeError: must be type, not classobj</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>使用super()函数能规避掉多继承中U存在的各种问题，但要注意super函数的一个参数，一般都是当前类，一旦写错，会造成很严重的后果，另外super函数只能应用在新式类中，在涉及到调用父类方法时，推荐使用该函数。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;super() 函数用于调用下一个父类(超类)并返回该父类的实例，主要用途是来查找父类的属性，比如 ，&lt;br&gt;super(MyClass,self).__init__()。它只能用在新式类中。&lt;/p&gt;
&lt;p&gt;语法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;super(type[, obj])
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;super()“返回此 type 的父类”。如果你希望父类被绑定,你可以传入 obj 参数(obj必须是 type 类型的)。否则父类不会被绑定。obj 参数也可以是一个类型，但它应当是 type 的一个子类。通常，当给出 obj 时：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果 obj 是一个实例，&lt;strong&gt;isinstance(obj,type)&lt;/strong&gt;就必须返回 True&lt;/li&gt;
&lt;li&gt;如果 obj 是一个类或类型，&lt;strong&gt;issubclass(obj,type)&lt;/strong&gt;就必须返回 True
    
    </summary>
    
      <category term="Python" scheme="http://waisunny.com/categories/Python/"/>
    
    
      <category term="python面向对象" scheme="http://waisunny.com/tags/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>python 类属性和实例属性</title>
    <link href="http://waisunny.com/2018/01/20/python-%E7%B1%BB%E5%B1%9E%E6%80%A7-VS-%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7/"/>
    <id>http://waisunny.com/2018/01/20/python-类属性-VS-实例属性/</id>
    <published>2018-01-20T11:46:54.000Z</published>
    <updated>2018-01-28T06:05:16.981Z</updated>
    
    <content type="html"><![CDATA[<p>在介绍类属性和实例属性区别之前我们先来了解一下属性是什么？什么是类属性？什么是实例属性？类属性和实例属性的是如何查找访问的？</p><p><strong>（本篇博文实例代码均是在python3下的执行结果，python2下略有不同。）</strong><br><a id="more"></a></p><h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><p>什么是属性呢？属性就是属于另一个对象的数据或者函数元素,可以通过我们熟悉的句点属性标识法来访问。一些 Python 类型比如复数有数据属性（实部和虚部），而另外一些，像列表和字典，拥有方法（函数属性）。</p><p>上面的定义听起来太抽象了，下面还是整点实在的吧！</p><h2 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a>类属性</h2><pre><code>class A:    attr=1</code></pre><p>上面就定义的 attr就是一个类属性，类属性是和类直接绑定的，可以通过类直接访问，也可以通过类的实例访问。</p><pre><code>&gt;&gt;&gt; A.attr1</code></pre><h2 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h2><pre><code>&gt;&gt;&gt; a=A()&gt;&gt;&gt; a.x=1010</code></pre><p>上述代码定义了一个实例a然后动态的给实例a添加了一个属性x。</p><h2 id="实例属性和类属性的访问方式"><a href="#实例属性和类属性的访问方式" class="headerlink" title="实例属性和类属性的访问方式"></a>实例属性和类属性的访问方式</h2><p>在介绍如何访问属性之前我们先介绍一个特殊的属性__dict__，每一个类及其每一个实例均有自己的__dict__属性，这个属性就是用来存储类及其实列的属性，方法等的。还有一个内建函数dir()也是用来查看对象包含的属性，方法等的，下面让我们来看一下：</p><pre><code>&gt;&gt;&gt; class A:...     attr=1...     def showInfo():...         print(&apos;my name is showInfo&apos;)...&gt;&gt;&gt; A.__dict__mappingproxy({&apos;__module__&apos;: &apos;__main__&apos;, &apos;attr&apos;: 1, &apos;showInfo&apos;: &lt;function A.showInfo at 0x0000020F36E5A510&gt;, &apos;__dict__&apos;: &lt;attribute &apos;__dict__&apos; of &apos;A&apos; objects&gt;, &apos;__weakref__&apos;: &lt;attribute &apos;__weakref__&apos; of &apos;A&apos; objects&gt;, &apos;__doc__&apos;: None})&gt;&gt;&gt; dir(A)[&apos;__class__&apos;, &apos;__delattr__&apos;, &apos;__dict__&apos;, &apos;__dir__&apos;, &apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, &apos;__getattribute__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__init_subclass__&apos;, &apos;__le__&apos;, &apos;__lt__&apos;, &apos;__module__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;__weakref__&apos;, &apos;attr&apos;, &apos;showInfo&apos;]&gt;&gt;&gt; a=A()&gt;&gt;&gt; a.__dict__{}&gt;&gt;&gt; a.x=10&gt;&gt;&gt; a.__dict__{&apos;x&apos;: 10}&gt;&gt;&gt; dir(a)[&apos;__class__&apos;, &apos;__delattr__&apos;, &apos;__dict__&apos;, &apos;__dir__&apos;, &apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, &apos;__getattribute__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__init_subclass__&apos;, &apos;__le__&apos;, &apos;__lt__&apos;, &apos;__module__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;__weakref__&apos;, &apos;attr&apos;, &apos;showInfo&apos;, &apos;x&apos;]&gt;&gt;&gt; a2=A()&gt;&gt;&gt; a2.__dict__{}&gt;&gt;&gt; a2.y=20&gt;&gt;&gt; a2.__dict__{&apos;y&apos;: 20}&gt;&gt;&gt; dir(a2)[&apos;__class__&apos;, &apos;__delattr__&apos;, &apos;__dict__&apos;, &apos;__dir__&apos;, &apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, &apos;__getattribute__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__init_subclass__&apos;, &apos;__le__&apos;, &apos;__lt__&apos;, &apos;__module__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;__weakref__&apos;, &apos;attr&apos;, &apos;showInfo&apos;, &apos;y&apos;]&gt;&gt;&gt;</code></pre><p>dir()返回的是对象的属性的一个名字列表，它包含了一些内置的属性和方法名，而__dict__返回的是一个字典(可以把 <strong>mappingproxy</strong>理解成是字典)，它的键(keys)是属性名，键值(values)是相应的属性对象的数据值。另外，类的实例的__dict__只包含实例自己的属性和方法，默认是一个空字典。</p><p>当访问一个类属性的时候，Python 解释器将会搜索字典以得到需要的属性。如果在__dict__中没有找到，将会在基类的字典中进行搜索，采用“深度优先搜索”顺序。基类集的搜索是按顺序的，从左到右，按其在类定义时，定义父类参数时的顺序。对类的修改会仅影响到此类的字典；基类的__dict__属性不会被改动的。</p><p>当访问实例属性的时候，和访问类属性差不多，先在实例的字典中查找，如果__dict__中找不到再去类的字典找那个查找，然后就是类的基类里面去找。</p><p>如果要访问的属性最终没有找到就会抛出 <strong>AttributeError</strong> 异常。</p><h2 id="通过实例访问类属性的注意点"><a href="#通过实例访问类属性的注意点" class="headerlink" title="通过实例访问类属性的注意点"></a>通过实例访问类属性的注意点</h2><pre><code>class Student:    name=&apos;_learner&apos;s1=Student()s2=Student()print(&apos;Student:{n}，s1:{n1}，s2:{n2}&apos;.format(n=Student.name,n1=s1.name,n2=s2.name))print(s1.__dict__)s1.name=&apos;Wai&apos;print(s1.__dict__)print(&apos;Student:{n}，s1:{n1}，s2:{n2}&apos;.format(n=Student.name,n1=s1.name,n2=s2.name))Student.name=&apos;Sunny&apos;print(&apos;Student:{n}，s1:{n1}，s2:{n2}&apos;.format(n=Student.name,n1=s1.name,n2=s2.name))del s1.nameprint(&apos;Student:{n}，s1:{n1}，s2:{n2}&apos;.format(n=Student.name,n1=s1.name,n2=s2.name))print(s1.__dict__)</code></pre><p>运行结果：</p><pre><code>Student:_learner，s1:_learner，s2:_learner{}{&apos;name&apos;: &apos;Wai&apos;}Student:_learner，s1:Wai，s2:_learnerStudent:Sunny，s1:Wai，s2:SunnyStudent:Sunny，s1:Sunny，s2:Sunny{}</code></pre><p>从上面的例子可以看出，在编写程序的时候，千万不要对实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。</p><p>核心提示：使用类属性来修改自身（不是实例属性）正如上面所看到的那样，使用实例属性来试着修改类属性是很危险的。原因在于实例拥有它们自已的属性集__dict__。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>python中类及实例的属性访问是通过字典__dict__实现的，另外，切记不要定义同名的类属性和实例属性，这样使用实例访问是会覆盖掉类属性，当修改类属性值时使用类修改而不是用实例修改。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在介绍类属性和实例属性区别之前我们先来了解一下属性是什么？什么是类属性？什么是实例属性？类属性和实例属性的是如何查找访问的？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（本篇博文实例代码均是在python3下的执行结果，python2下略有不同。）&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://waisunny.com/categories/Python/"/>
    
    
      <category term="python面向对象" scheme="http://waisunny.com/tags/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>python中 __new__和__init__的区别</title>
    <link href="http://waisunny.com/2018/01/18/python%E4%B8%AD%20__new__%E5%92%8C__init__%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://waisunny.com/2018/01/18/python中 __new__和__init__的区别/</id>
    <published>2018-01-18T09:14:27.000Z</published>
    <updated>2018-01-26T01:59:06.579Z</updated>
    
    <content type="html"><![CDATA[<p>新式类内置有__new__方法而经典类没有__new__方法，只有__init__方法。</p><p>在python中创建类的一个实例时，如果该类具有__new__方法，会先调用__new__方法，__new__方法接受当前正在实例化的类作为第一个参数（这个参数的类型是type，这个类型在c和python的交互编程中具有重要的角色，感兴趣的可以搜下相关的资料），其返回值是本次创建产生的实例，也就是我们熟知的__init__方法中的第一个参数self。那么就会有一个问题，这个实例怎么得到？<br><a id="more"></a></p><p>有__new__方法的都是object类(新式类)的后代，因此如果我们自己想要改写__new__方法（注意不改写时在创建实例的时候使用的是父类的__new__方法，如果父类没有则继续上溯）可以通过调用object的__new__方法类得到这个实例（这实际上也和python中的默认机制基本一致），如：</p><pre><code>class display(object):    def __init__(self, *args, **kwargs):        print(&quot;init&quot;)    def __new__(cls, *args, **kwargs):        print(&quot;new&quot;)        print(type(cls))        return object.__new__(cls, *args, **kwargs)  a=display()</code></pre><p>结果：</p><pre><code>new&lt;class &apos;type&apos;&gt;init</code></pre><p>因此我们可以得到如下结论：</p><p><strong>在实例创建过程中__new__方法先于__init__方法被调用，它的第一个参数类型为type,返回值是当前实例对象。</strong></p><p><strong>如果不需要其它特殊的处理，可以使用object的__new__方法来得到创建的实例（也即self)。</strong></p><p><strong>于是我们可以发现，实际上可以使用其它类的__new__方法类得到这个实例，只要那个类或其父类或祖先有__new__方法。</strong></p><pre><code>class another(object):    def __new__(cls,*args,**kwargs):        print(&quot;newano&quot;)        return object.__new__(cls, *args, **kwargs)  class display(object):    def __init__(self, *args, **kwargs):        print(&quot;init&quot;)    def __new__(cls, *args, **kwargs):        print(&quot;newdis&quot;)        print(type(cls))        return another.__new__(cls, *args, **kwargs)  a=display()</code></pre><p>结果：</p><pre><code>newdis&lt;class &apos;type&apos;&gt;newanoinit</code></pre><font size="4"><strong>总结</strong></font><p>我们发现__new__和__init__就像这么一个关系，__new__提供生产的原料self(但并不保证这个原料来源正宗，像上面那样它用的是另一个不相关的类的<strong>new</strong>方法类得到这个实例)，而__init__就用__new__给的原料来完善这个对象（尽管它不知道这些原料是不是正宗的）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;新式类内置有__new__方法而经典类没有__new__方法，只有__init__方法。&lt;/p&gt;
&lt;p&gt;在python中创建类的一个实例时，如果该类具有__new__方法，会先调用__new__方法，__new__方法接受当前正在实例化的类作为第一个参数（这个参数的类型是type，这个类型在c和python的交互编程中具有重要的角色，感兴趣的可以搜下相关的资料），其返回值是本次创建产生的实例，也就是我们熟知的__init__方法中的第一个参数self。那么就会有一个问题，这个实例怎么得到？&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://waisunny.com/categories/Python/"/>
    
    
      <category term="python面向对象" scheme="http://waisunny.com/tags/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>python中 __slots__属性详解</title>
    <link href="http://waisunny.com/2018/01/15/python%E4%B8%AD-slots-%E8%AF%A6%E8%A7%A3/"/>
    <id>http://waisunny.com/2018/01/15/python中-slots-详解/</id>
    <published>2018-01-15T08:26:28.000Z</published>
    <updated>2018-01-28T02:59:14.200Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>新式类增加了__slots__内置属性, 它的作用是把实例属性锁定到__slots__规定的范围内。</p><p>__slots__是一个元组，包括了当前能访问到的属性。当定义了slots后，slots中定义的变量变成了类的描述符，相当于java，c++中的成员变量声明，类的实例只能拥有slots中定义的变量。</p><p>看下面的例子：<br><a id="more"></a></p><p>例一：</p><pre><code>class A(object):    attr=1a=A()print(a.__dict__)a.x=10print(a.x)print(a.__dict__)</code></pre><p>结果：</p><pre><code>{}10{&apos;x&apos;: 10}</code></pre><p>例二：</p><pre><code>class A(object):    attr=1    __slots__=(&apos;x&apos;,&apos;y&apos;)print(a.x)  # AttributeError: xa=A()#a.__dict__ # AttributeError: &apos;A&apos; object has no attribute &apos;__dict__&apos;a.x=10#a.z=20     # AttributeError: &apos;A&apos; object has no attribute &apos;z&apos;print(a.x)</code></pre><p>结果：</p><pre><code>10</code></pre><p>通过上面的例子我们能看出，没有定义__slots__的类的实例包含__dict__属性，它是一个字典，默认为空，可以通过该属性动态添加属性，方法等。</p><p>但当定义了__slots__属性后，__dict__属性就没了，因此不能动态添加属性了，只能使用__slots__元组中规定的属性，前提是要先赋值。</p><p>Python是一门动态语言，可以在运行过程中，修改实例的属性和增删方法，使用__slots__属性后失去了这个特性；那么__slots__属性有什么用呢？继续往下面看：</p><h1 id="Slots的实现"><a href="#Slots的实现" class="headerlink" title="Slots的实现"></a>Slots的实现</h1><p>我们首先来看看用纯Python是如何实现__slots\__（为了将以下实现的slots与原slots区分开来，代码中用单下划线的_slots_来代替)</p><pre><code>class Member(object):    # 定义描述器实现slots属性的查找    def __init__(self, i):        self.i = i    def __get__(self, obj, type=None):        return obj._slotvalues[self.i]    def __set__(self, obj, value):        obj._slotvalues[self.i] = valueclass Type(type):    # 使用元类实现slots    def __new__(self, name, bases,  namespace):        slots = namespace.get(&apos;_slots_&apos;)        if slots:            for i, slot in enumerate(slots):                namespace[slot] = Member(i)            original_init = namespace.get(&apos;__init__&apos;)            def __init__(self, *args, **kwargs):                # 创建_slotvalues列表和调用原来的__init__                self._slotvalues = [None] * len(slots)                if original_init(self, *args, **kwargs):                    original_init(self, *args, **kwargs)            namespace[&apos;__init__&apos;] = __init__        return type.__new__(self, name, bases, namespace)# Python2与Python3使用元类的区别    try:    class Object(object): __metaclass__ = Typeexcept:    class Object(metaclass=Type): passclass A(Object):    _slots_ = &apos;x&apos;, &apos;y&apos;a = A()a.x = 10print(a.x)</code></pre><p>在<strong>CPython</strong>中，当一个A类定义了__slots__ = (‘x’, ‘y’)，A.x就是一个有__get__和__set__方法的member<em>descriptor，并且在每个实例中可以通过直接访问内存（direct memory access）获得。（具体实现是用偏移地址来记录描述器，通过公式可以直接计算出其在内存中的实际地址 ，访问\</em>_dict__也是用相同的方法，也就是说访问A.__dict__和A.x描述器的速度是相近的）。</p><p>在上面的例子中，我们用纯Python实现了一个等价的slots。当一个元类看到_slots_定义了x和y，它会创建两个的类变量，x = Member(0)和y = Member(1)。然后，装饰__init__方法让新的实例创建一个_slotvalues列表。</p><p><strong>例子中的实现和CPython不同的是</strong>：</p><p>例子中_slotvalues是一个存储在类对象外部的列表，而在<strong>CPython</strong>中它与实例对象存储在一起，可以通过直接访问内存获得。相应地，member decriptor也不是存在外部列表中，而同样可以通过直接访问内存获得。</p><p>默认情况下，__new__方法会为每个实例创建一个字典__dict__来存储实例的属性。但如果定义了__slots__，__new__方法就不会再创建这个字典。</p><p>由于不存在__dict__来存储新的属性，所以使用一个不在__slots__中的属性时，程序会报错。</p><h2 id="更快的属性访问速度"><a href="#更快的属性访问速度" class="headerlink" title="更快的属性访问速度"></a>更快的属性访问速度</h2><p>默认情况下，访问一个实例的属性是通过访问该实例的__dict__来实现的。如访问a.x就相当于访问a.__dict__[‘x’]。为了便于理解，我粗略地将它拆分为四步：</p><ol><li>a.x </li><li>a.__dict__ </li><li>a.__dict__[‘x’] </li><li>结果</li></ol><p>从__slots__的实现可以得知，定义了__slots__的类会为每个属性创建一个描述器。访问属性时就直接调用这个描述器。在这里我将它拆分为三步：</p><ol><li>b.x </li><li>member decriptor </li><li>结果</li></ol><p>我在上文提到，访问__dict__和描述器的速度是相近的，而通过__dict__访问属性多了a.__dict__[‘x’]字典访值一步（一个哈希函数的消耗）。由此可以推断出，使用了__slots__的类的属性访问速度比没有使用的要快。下面用一个例子验证：</p><pre><code>from timeit import repeatclass A(object): passclass B(object): __slots__ = (&apos;x&apos;)def get_set_del_fn(obj):    def get_set_del():        obj.x = 1        obj.x        del obj.x    return get_set_dela = A()b = B()ta = min(repeat(get_set_del_fn(a)))tb = min(repeat(get_set_del_fn(b)))print(&quot;%.2f%%&quot; % ((ta/tb - 1)*100))</code></pre><p>在本人电脑上测试速度有10%-20%的提升。</p><h2 id="减少内存消耗"><a href="#减少内存消耗" class="headerlink" title="减少内存消耗"></a>减少内存消耗</h2><p><strong>Python内置的字典本质是一个哈希表，它是一种用空间换时间的数据结构。为了解决冲突的问题，当字典使用量超过2/3时，Python会根据情况进行2-4倍的扩容。由此可预见，取消__dict__的使用可以大幅减少实例的空间消耗。</strong></p><p>下面使用memory_profiler模块，memory_profiler模块是在逐行的基础上，测量代码的内存使用率。尽管如此，它可能使得你的代码运行的更慢。使用装饰器@profile来标记哪个函数被跟踪。</p><pre><code>from  memory_profiler import profileclass A(object):  # 没有定义__slots__属性    def __init__(self, x):        self.x = x@profiledef main():    f = [A(523825) for i in range(100000)]if __name__ == &apos;__main__&apos;:    main()</code></pre><p>运行结果：</p><pre><code>Line #    Mem usage    Increment   Line Contents================================================ 7        17.2 MiB     17.2 MiB    @profile 8                                 def main(): 9        35.3 MiB     17.0 MiB       f = [A(523825) for i in range(100000)]</code></pre><p>第2列表示该行执行后Python解释器的内存使用情况，第3列表示该行代码执行前后的内存变化。</p><p>在没有定义__slots__属性的情况下，该代码共使用了(17.2+17.0)MiB内存。</p><p>从结果可以看出，内存使用是以MiB为单位衡量的,表示的mebibyte(1MiB = 1.05MB)。</p><pre><code>from memory_profiler import profileclass A(object):  # 定义了__slots__属性    __slots__ = (&apos;x&apos;)    def __init__(self, x):        self.x = x@profiledef main():    f = [A(523825) for i in range(100000)]if __name__ == &apos;__main__&apos;:    main()</code></pre><p>运行结果：</p><pre><code>Line #    Mem usage    Increment   Line Contents================================================   7      16.9 MiB     16.9 MiB   @profile   8                              def main():   9      22.9 MiB     6.0 MiB       f = [A(523825) for i in range(100000)]</code></pre><p>定义__slots__属性的情况下，该代码共使用了(16.9+6.0)MiB内存。</p><p>从上述结果可看到使用__slots__能极大地减少内存空间的消耗，这也是最常见到的用法。</p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>1.只有非字符串的迭代器可以赋值给__slots__</p><pre><code>&gt;&gt;&gt; class A(object): __slots__ = (&apos;a&apos;, &apos;b&apos;, &apos;c&apos;)&gt;&gt;&gt; class B(object): __slots__ = &apos;abcd&apos;&gt;&gt;&gt; B.__slots__&apos;abc&apos;</code></pre><p>若直接将字符串赋值给它，就只有一个属性。</p><p>2.关于__slots__的继承问题</p><p>在一般情况下，使用__slots__的类需要直接继承object，如class Foo(object): __slots__ = ()</p><p>在继承自己创建的类时，我根据子类父类是否定义了__slots__，将它细分为六种情况:</p><p>① 父类有，子类没有：</p><p>子类的实例还是会自动创建__dict__来存储属性，不过父类__slots__已有的属性不受影响。</p><pre><code>&gt;&gt;&gt; class Father(object): __slots__ = (&apos;x&apos;)&gt;&gt;&gt; class Son(Base): pass&gt;&gt;&gt; son = Son()&gt;&gt;&gt; son.x, son.y = 1, 1&gt;&gt;&gt; son.__dict__&gt;&gt;&gt; {&apos;y&apos;: 1}</code></pre><p>② 父类没有，子类有：</p><p>虽然子类取消了__dict__，但继承父类后它会继续生成。同上面一样，__slots__已有的属性不受影响。</p><pre><code>&gt;&gt;&gt; class Father(object): pass&gt;&gt;&gt; class Son(Father): __slots__ = (&apos;x&apos;)&gt;&gt;&gt; son = Son()&gt;&gt;&gt; son.x, son.y = 1, 1&gt;&gt;&gt; son.__dict__&gt;&gt;&gt; {&apos;y&apos;: 1}</code></pre><p>③ 父类有，子类有：</p><p>只有子类的__slots__有效，访问父类有子类没有的属性依然会报错。</p><pre><code>&gt;&gt;&gt; class Father(object): __slots__ = (&apos;x&apos;, &apos;y&apos;)&gt;&gt;&gt; class Son(Father): __slots__ = (&apos;x&apos;, &apos;z&apos;)&gt;&gt;&gt; son = Son()&gt;&gt;&gt; son.x, son.y, son.z = 1, 1, 1Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;AttributeError: &apos;Son&apos; object has no attribute &apos;y&apos;</code></pre><p>④ 多个拥有非空__slots__的父类：</p><p>由于__slots__的实现不是简单的列表或字典，多个父类的非空__slots__不能直接合并，所以使用时会报错（即使多个父类的非空__slots__是相同的）。</p><pre><code>&gt;&gt;&gt; class Father(object): __slots__ = (&apos;x&apos;)&gt;&gt;&gt; class Mother(object): __slots__ = (&apos;x&apos;)&gt;&gt;&gt; class Son(Father, Mother): passTraceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: Error when calling the metaclass basesmultiple bases have instance lay-out conflict</code></pre><p>⑤ 多个空__slots__的父类：</p><p>这是关于__slots__使用多继承唯一办法。</p><p>⑥ 某些父类有，某些父类没有：</p><p>跟第一种情况类似。</p><p>为了正确使用__slots__，最好直接继承object。如有需要用到其他父类，则父类和子类都要定义__slots__，还要记得子类的__slots__会覆盖父类的__slots__;除非所有父类的__slots__都为空，否则不要使用多继承。</p><p>3.添加__dict__获取动态特性</p><p>在特殊情况下，可以在__slots__里添加__dict__来获取与普通实例同样的动态特性。</p><pre><code>&gt;&gt;&gt; class A(object): __slots__ = ()&gt;&gt;&gt; class B(A): __slots__ = (&apos;__dict__&apos;, &apos;x&apos;)&gt;&gt;&gt; b = B()&gt;&gt;&gt; b.x, b.y = 1, 1&gt;&gt;&gt; b.__dict__{&apos;y&apos;: 1}</code></pre><p>4.添加__weakref__获取弱引用功能</p><p>__slots__的实现不仅取消了__dict__的生成，也取消了__weakref__的生成。同样的，在__slots__将其添加可以重新获取弱引用这一功能。</p><p>5.如果类变量与__slots__的变量同名，则该变量被设置为readonly！！！</p><pre><code>class base(object):      __slots__=(&apos;y&apos;)      y=22 # y是类变量,y与__slots__中的变量同名      var=11      def __init__(self):          pass  b=base()  print (b.y)  print (base.y)  #b.y=66 #AttributeError: &apos;base&apos; object attribute &apos;y&apos; is read-only  </code></pre><p>运行结果：</p><pre><code>2222</code></pre><p>6.namedtuple</p><p>利用内置的namedtuple不可变的特性，结合__slots__，能创建出一个轻量不可变的实例。(约等于一个元组的大小)</p><pre><code>&gt;&gt;&gt; from collections import namedtuple&gt;&gt;&gt; class MyNt(namedtupele(&apos;MyNt&apos;, &apos;bar baz&apos;)): __slots__ = ()&gt;&gt;&gt; nt = MyNt(&apos;r&apos;, &apos;z&apos;)&gt;&gt;&gt; nt.bar&apos;r&apos;&gt;&gt;&gt; nt.baz&apos;z&apos;</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>当一个类需要创建大量实例时，可以使用__slots__来减少内存消耗。如果对访问属性的速度有要求，也可以酌情使用。另外可以利用__slots__的特性来限制实例的属性。而用在普通类身上时，使用__slots__后会丧失动态添加属性和弱引用的功能，进而引起其他错误，所以在一般情况下不要使用它。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;新式类增加了__slots__内置属性, 它的作用是把实例属性锁定到__slots__规定的范围内。&lt;/p&gt;
&lt;p&gt;__slots__是一个元组，包括了当前能访问到的属性。当定义了slots后，slots中定义的变量变成了类的描述符，相当于java，c++中的成员变量声明，类的实例只能拥有slots中定义的变量。&lt;/p&gt;
&lt;p&gt;看下面的例子：&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://waisunny.com/categories/Python/"/>
    
    
      <category term="python面向对象" scheme="http://waisunny.com/tags/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>python中__get__、__getattr__、__getattribute__详解</title>
    <link href="http://waisunny.com/2018/01/12/python%E4%B8%AD-get-getattr-getattribute-%E8%AF%A6%E8%A7%A3/"/>
    <id>http://waisunny.com/2018/01/12/python中-get-getattr-getattribute-详解/</id>
    <published>2018-01-12T08:25:32.000Z</published>
    <updated>2018-01-26T01:38:40.136Z</updated>
    
    <content type="html"><![CDATA[<p>__get__,__getattr__和__getattribute__（只存在于新式类）都是访问属性的方法，但有一定的区别。 </p><pre><code>object.__getattr__(self, name) </code></pre><p>通过实例访问属性时，若属性不存在则会调用__getattr__方法，默认触发AttributeError异常；若属性存在，但手动引发AttributeError异常，也会调用__getattr__方法，好比一个异常处理函数。</p><pre><code>object.__getattribute__(self, name) </code></pre><p>通过实例访问属性时，__getattribute__方法是无条件调用的，无论被访问的属性是否存在，它都会被触发，并返回属性本身；</p><pre><code>object.__get__(self, instance, owner) </code></pre><p>如果class定义了它，则这个class就可以称为descriptor。owner是所有者的类，instance是访问descriptor的实例，如果不是通过实例访问，而是通过类访问的话，instance则为None。需要注意的是：descriptor的实例自己访问自己时不会触发__get__，而会触发__call__，只有descriptor作为其它类的属性才有意义。</p><p>前两个都是通过实例访问才会触发，最后一个通过类或实例访问都可以触发，下面我们看一个例子，加深一下理解：</p><a id="more"></a><pre><code>class C(object):                                                          a = &apos;abc&apos;                                                             def __getattribute__(self, *args, **kwargs):                              print(&quot;__getattribute__() is called&quot;)                                 return object.__getattribute__(self, *args, **kwargs)             def __getattr__(self, name):                                              print(&quot;__getattr__() is called &quot;)                                     return name + &quot; from getattr&quot;                                     def __get__(self, instance, owner):                                       print(&quot;__get__() is called&quot;, instance, owner)                 class C2(object):                                                         d = C()                                                           if __name__ == &apos;__main__&apos;:                                                c = C()    c2 = C2()                                                           print(c.a)                                                          print(c.zzzzzzzz)                                                   c2.d                                                                print(c2.d.a)    </code></pre><p>运行结果：</p><pre><code>__getattribute__() is calledabc__getattribute__() is called__getattr__() is called zzzzzzzz from getattr(&apos;__get__() is called&apos;, &lt;__main__.C2 object at 0x0000000002A76400&gt;, &lt;class &apos;__main__.C2&apos;&gt;)(&apos;__get__() is called&apos;, &lt;__main__.C2 object at 0x0000000002A76400&gt;, &lt;class &apos;__main__.C2&apos;&gt;)__getattribute__() is calledabc   </code></pre><p>简单说明一下：</p><p>if里面前两行是获取类实例，不会有任何输出；</p><p>第三行通过实例c访问存在的属性a会调用 __getattribute__ 方法，看到前两行输出结果；</p><p>第四行通过实例访问不存在的属性zzzzzzzz会先调用__getattribute__ 方法然后调用__getattr__方法，看到了3~5行的输出结果；</p><p>第五行通过C2的实例访问其属性d，d又是C类的一个实例，所以会触发__get__方法，看到第六行输出结果。</p><p>第六行通过C2的属性d（C的实例）调用C存在的属性a会先触发方法__get__然后调用__getattribute__ 方法，看到7~9行输出。</p><font size="5"><strong>补充</strong></font><p>大多时候我们并不太需要关注__getattribute__ 和__getattr__的一些细节，一般情况下使用我们自定义的类的时候，我们对类的结构都了解，不会刻意偏离，造成一些属性访问的错误等。</p><p>值得一提的是，适当的重写会使我们的程序变的优雅，但也有一些需要注意的地方，看下面的例子：</p><p>链式生成url:</p><pre><code>class UrlGenerator(object):                                            def __init__(self, root_url):                                          self.url = root_url                                            def __getattr__(self, item):                                           if item == &apos;get&apos; or item == &apos;post&apos;:                                    print (self.url)                                               return UrlGenerator(&apos;{}/{}&apos;.format(self.url, item))        url_gen = UrlGenerator(&apos;http://www.aa.com&apos;)                        url_gen.users.show.get</code></pre><p>结果：</p><pre><code>http://www.aa.com/users/show     </code></pre><p>充分利用getattr会在没有查找到相应实例属性时被调用的特点，方便的通过链式调用生成对应的url，源代码中在碰到http method的时候返回一个<br>可调用的对象更加的优雅，链式的操作不仅优雅而且还能很好的说明调用的接口的意义（restful的接口啦）。</p><font size="4"><strong>注意点：</strong></font><p><strong>1.自定义getattribute的时候防止无限递归</strong></p><p>因为getattribute在访问属性的时候一直会被调用，自定义的getattribute方法里面同时需要返回相应的属性，通过self.<strong>dict</strong>取值会继续向下调用getattribute，造成循环调用：</p><pre><code>class A(object):                                                                                                         def __getattribute__(self, item):                                                                                        print(item)                                                                                                          return self.__dict__[item]    #RuntimeError: maximum recursion depth exceeded while calling a Python object  a=A()                                                                                                                a.aaa                                                                                                                </code></pre><p>上面的代码运行会输出 aaa ，但是会报超出最大递归深度的异常，这是需要重点注意的。                                                                                                                     </p><pre><code>class A(object):                                                                                                         def __getattribute__(self, item):                                                                                        try:                                                                                                                     print(item)                                                                                                          super(A,self).__getattribute__(item)# AttributeError: &apos;A&apos; object has no attribute &apos;aaa&apos;                          except KeyError as e:                                                                                                    return &apos;default&apos;                                                                                         a=A()                                                                                                                a.aaa                                                                                                                </code></pre><p>上面的代码运行也会输出 aaa ,aaa这个属性找不到，然后抛出AttributeError，调用 __getattr__方法。这也是我们想要的结果。</p><p><strong>2.同时覆盖掉__getattribute__和__getattr__的时候，在__getattribute__中需要模仿原本的行为抛出AttributeError或者手动调用__getattr__</strong></p><pre><code>class A(object):                                               def  __init__(self,name):                                      self.name=name                                         def __getattribute__(self, item):                              try:                                                           return super(A,self).__getattribute__(item)            except KeyError:                                               return &apos;default&apos;                                       except AttributeError as e:                                    print(e)                                           def __getattr__(self, item):                                   return &apos;default&apos;                                   a=A(&apos;_learner&apos;)                                            print(a.name)                                              print(a.age)                                               </code></pre><p>运行结果：</p><pre><code>_learner&apos;A&apos; object has no attribute &apos;age&apos;None</code></pre><p>上面例子里面的getattr方法根本不会被调用，因为原本的AttributeError被我们自行处理并未抛出，也没有手动调用getattr，所以访问age的结果是None而不是default.</p><font size="5"><strong>总结</strong></font><p>每次通过实例访问属性，都会经过__getattribute__函数。而当属性不存在时，仍然需要访问__getattribute__，不过接着要访问__getattr__，_getattr__好像是一个异常处理函数。 </p><p>每次访问descriptor（即实现了__get__的类），都会先经过__get__函数。 </p><p>当使用类访问不存在的变量时，不会经过__getattr__函数。而descriptor不存在此问题，只是把instance标识为none而已。</p><p>在重写 __getattribute__、_getattr__方法时，要注意堆栈溢出以及吃掉AttributeError异常的问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;__get__,__getattr__和__getattribute__（只存在于新式类）都是访问属性的方法，但有一定的区别。 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;object.__getattr__(self, name) 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过实例访问属性时，若属性不存在则会调用__getattr__方法，默认触发AttributeError异常；若属性存在，但手动引发AttributeError异常，也会调用__getattr__方法，好比一个异常处理函数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;object.__getattribute__(self, name) 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过实例访问属性时，__getattribute__方法是无条件调用的，无论被访问的属性是否存在，它都会被触发，并返回属性本身；&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;object.__get__(self, instance, owner) 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果class定义了它，则这个class就可以称为descriptor。owner是所有者的类，instance是访问descriptor的实例，如果不是通过实例访问，而是通过类访问的话，instance则为None。需要注意的是：descriptor的实例自己访问自己时不会触发__get__，而会触发__call__，只有descriptor作为其它类的属性才有意义。&lt;/p&gt;
&lt;p&gt;前两个都是通过实例访问才会触发，最后一个通过类或实例访问都可以触发，下面我们看一个例子，加深一下理解：&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://waisunny.com/categories/Python/"/>
    
    
      <category term="python面向对象" scheme="http://waisunny.com/tags/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>python面向对象初识-新式类VS经典类</title>
    <link href="http://waisunny.com/2018/01/11/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%9D%E8%AF%86-%E6%96%B0%E5%BC%8F%E7%B1%BBVS%E7%BB%8F%E5%85%B8%E7%B1%BB/"/>
    <id>http://waisunny.com/2018/01/11/python面向对象初识-新式类VS经典类/</id>
    <published>2018-01-10T18:15:58.000Z</published>
    <updated>2018-01-29T00:15:54.768Z</updated>
    
    <content type="html"><![CDATA[<p>在python2.x中，从object继承得来的类称为新式类（如class A(object)）不从object继承得来的类称为经典类（如class A()）；python3中所有的类都为新式类。</p><p>那么新式类和经典类有啥区别呢？ 主要区别体现在五个方面，接下来我们详细介绍一下。<br><a id="more"></a></p><font size="4"><strong>__class__属性</strong></font><p>新式类对象有__class__属性， 可以直接通过__class__属性获取自身类型:type;经典类没有这个属性。</p><p>经典类：</p><pre><code>&gt;&gt;&gt; class A:...     pass...&gt;&gt;&gt; A.__class__Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;AttributeError: class A has no attribute &apos;__class__&apos;&gt;&gt;&gt; type(A)&lt;type &apos;classobj&apos;&gt;&gt;&gt;&gt; a=A()&gt;&gt;&gt; a.__class__&lt;class __main__.A at 0x00000000006277C8&gt;&gt;&gt;&gt; type(a)&lt;type &apos;instance&apos;&gt;&gt;&gt;&gt; a.__class__ is type(a)False</code></pre><p>新式类：</p><pre><code>&gt;&gt;&gt; class B(object):...     pass...&gt;&gt;&gt; B.__class__&lt;type &apos;type&apos;&gt;&gt;&gt;&gt; type(B)&lt;type &apos;type&apos;&gt;&gt;&gt;&gt; B.__class__ is type(B)True&gt;&gt;&gt; b=B()&gt;&gt;&gt; b.__class__&lt;class &apos;__main__.B&apos;&gt;&gt;&gt;&gt; type(b)&lt;class &apos;__main__.B&apos;&gt;&gt;&gt;&gt; b.__class__ is type(b)True</code></pre><p>能看出，新式类及其实例均有__class__属性，并且通过内建函数type()获取到的值与__class__属性获取到的值一致；经典类没有__class__属性，但其实例有，但是通过内建函数type()获取到的值与__class__属性获取到的值不一致。</p><font size="4"><strong>多继承属性搜索顺序</strong></font><p>经典类多继承时属性搜索顺序: 先深入继承树左侧，再返回，开始找右侧（即深度优先搜索）;</p><p>新式类多继承属性搜索顺序: 先水平搜索，然后再向上移动（即宽度优先）。</p><p>这涉及到一个MRO(方法解释顺序)的 问题 ，经典类的MRO算法和新式类不同，不适用于新式类，经典类，使用深度优先算法，但因为新式类继承自 object，新的菱形类继承结构出现，问题也就接着而来了，所以必须新建一个 MRO算法。</p><p>例子：</p><p>经典类(深度优先) attr查找顺序：D、B、A、C</p><pre><code>class A:    attr=1class B(A):    passclass C(A):    attr = 2class D(B,C):    passd=D()print(d.attr)</code></pre><p>结果：</p><pre><code>1</code></pre><p>新式类(宽度优先) attr查找顺序：D、B、C、A</p><pre><code>class A(object):    attr=1class B(A):    passclass C(A):    attr = 2class D(B,C):    passd=D()print(d.attr)</code></pre><p>结果：</p><pre><code>2</code></pre><font size="4"><strong>__slots__属性</strong></font><p>新式类增加了__slots__属性，具体请参考：<a href="http://waisunny.com/2018/01/15/python%E4%B8%AD-slots-%E8%AF%A6%E8%A7%A3/" title="python中 __slots__属性详解">http://waisunny.com/2018/01/15/python%E4%B8%AD-slots-%E8%AF%A6%E8%A7%A3/</a></p><font size="4"><strong>__getattribute__方法</strong></font><p>新式类增加了__getattribute__方法，具体请参考：<a href="http://waisunny.com/2018/01/12/python%E4%B8%AD-get-getattr-getattribute-%E8%AF%A6%E8%A7%A3/" title="python中__get__、__getattr__、__getattribute__详解">http://waisunny.com/2018/01/12/python%E4%B8%AD-get-getattr-getattribute-%E8%AF%A6%E8%A7%A3/</a></p><font size="4"><strong>__new__方法</strong></font><p>新式类增加了__new__方法，具体请参考：<a href="http://waisunny.com/2018/01/18/python%E4%B8%AD-new-VS-init/" title="python中 __new__和__init__的区别">http://waisunny.com/2018/01/18/python%E4%B8%AD-new-VS-init/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在python2.x中，从object继承得来的类称为新式类（如class A(object)）不从object继承得来的类称为经典类（如class A()）；python3中所有的类都为新式类。&lt;/p&gt;
&lt;p&gt;那么新式类和经典类有啥区别呢？ 主要区别体现在五个方面，接下来我们详细介绍一下。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://waisunny.com/categories/Python/"/>
    
    
      <category term="python面向对象" scheme="http://waisunny.com/tags/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>python—包剖析</title>
    <link href="http://waisunny.com/2017/12/30/python%E2%80%94%E5%8C%85%E5%89%96%E6%9E%90/"/>
    <id>http://waisunny.com/2017/12/30/python—包剖析/</id>
    <published>2017-12-29T17:11:03.000Z</published>
    <updated>2018-01-28T06:06:32.264Z</updated>
    
    <content type="html"><![CDATA[<p>包是一个有层次的文件目录结构, 它定义了一个由模块和子包组成的 Python 应用程序执行<br>环境。Python 1.5 加入了包, 用来帮助解决如下问题:</p><ol><li>为平坦的名称空间加入有层次的组织结构</li><li>允许程序员把有联系的模块组合到一起</li><li>允许分发者使用目录结构而不是一大堆混乱的文件</li><li>帮助解决有冲突的模块名称</li></ol><p>与类和模块相同, 包也使用句点属性标识来访问他们的元素。 使用标准的 import 和<br>from-import 语句导入包中的模块。<br><a id="more"></a></p><h1 id="包的目录结构"><a href="#包的目录结构" class="headerlink" title="包的目录结构"></a>包的目录结构</h1><pre><code>Phone/    __init__.py    common_util.py    Voicedta/        __init__.py        Pots.py    Fax/        __init__.py        G3.py    Mobile/        __init__.py        Analog.py        Digital.py    Pager/        __init__.py        Numeric.py</code></pre><p>Phone 是最顶层的包, Voicedta 等是它的子包。 </p><p>从上面的目录结构我们发现每一个包中都包含一个__init__.py文件。</p><p>这个文件有什么作用呢？</p><ol><li>__init__.py的第一个作用就是包的标识，如果没有该文件，该目录就不会认为是包。</li><li>__init__.py的另外一个作用就是定义包中的__all__变量，该变量包含执行 from module import * 这样的语句时应该导入的模块的名字. 它由一个模块名字符串列表组成。</li></ol><h1 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h1><h2 id="import语句"><a href="#import语句" class="headerlink" title="import语句"></a>import语句</h2><pre><code>import Phone.Mobile.Analog #导入子包中的模块Phone.Mobile.Analog.dial() #调用子包模块中的函数dial()</code></pre><h2 id="from-import语句"><a href="#from-import语句" class="headerlink" title="from-import语句"></a>from-import语句</h2><pre><code>from Phone import MobileMobile.Analog.dial(&apos;555-1212&apos;)from Phone.Mobile import AnalogAnalog.dial(&apos;555-1212&apos;)from package.module import *</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;包是一个有层次的文件目录结构, 它定义了一个由模块和子包组成的 Python 应用程序执行&lt;br&gt;环境。Python 1.5 加入了包, 用来帮助解决如下问题:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为平坦的名称空间加入有层次的组织结构&lt;/li&gt;
&lt;li&gt;允许程序员把有联系的模块组合到一起&lt;/li&gt;
&lt;li&gt;允许分发者使用目录结构而不是一大堆混乱的文件&lt;/li&gt;
&lt;li&gt;帮助解决有冲突的模块名称&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;与类和模块相同, 包也使用句点属性标识来访问他们的元素。 使用标准的 import 和&lt;br&gt;from-import 语句导入包中的模块。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://waisunny.com/categories/Python/"/>
    
    
      <category term="python基础" scheme="http://waisunny.com/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>python—模块剖析</title>
    <link href="http://waisunny.com/2017/12/28/python%E2%80%94%E6%A8%A1%E5%9D%97%E5%89%96%E6%9E%90/"/>
    <id>http://waisunny.com/2017/12/28/python—模块剖析/</id>
    <published>2017-12-28T11:12:17.000Z</published>
    <updated>2018-01-28T06:06:39.334Z</updated>
    
    <content type="html"><![CDATA[<p>在计算机程序的开发过程中，随着程序代码越写越多，在一个文件里代码就会越来越长，越来越不容易维护。为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在Python中，一个.py文件就称之为一个模块（Module）。</p><p>使用模块有什么好处？</p><p>最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括Python内置的模块和来自第三方的模块。<br><a id="more"></a></p><h1 id="导入模块"><a href="#导入模块" class="headerlink" title="导入模块"></a>导入模块</h1><h2 id="模块导入原理"><a href="#模块导入原理" class="headerlink" title="模块导入原理"></a>模块导入原理</h2><p>模块的导入需要一个叫做”路径搜索”的过程。 即在文件系统”预定义区域”中查找 mymodule.py<br>文件(如果你导入 mymodule 的话)。 这些预定义区域只不过是你的 Python 搜索路径的集合。</p><p>路径搜索和搜索路径是两个不同的概念, 前者是指查找某个文件的操作, 后者是去查找一组目录。</p><p>解释器启动之后可以通过Python的sys.path属性获得当前搜索路径集合：</p><pre><code>&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.path[&apos;C:\\Python36\\DLLs&apos;, &apos;C:\\Python36\\lib&apos;, &apos;C:\\Python36&apos;, &apos;C:\\Python36\\lib\\site-packages&apos;, &apos;C:\\Python36\\lib\\site-packages\\pip-9.0.1-py3.6.egg&apos;, &apos;C:\\Python36\\lib\\site-packages\\pymysql-0.7.11-py3.6.egg&apos;, &apos;C:\\Python36\\lib\\site-packages\\requests-2.18.4-py3.6.egg&apos;, &apos;C:\\Python36\\lib\\site-packages\\certifi-2017.7.27.1-py3.6.egg&apos;]</code></pre><p>如果你知道你需要导入的模块是什么,而它的路径不在搜索路径里, 那么只需要向sys.path 添加即可：</p><pre><code>sys.path.append(&apos;/home/wesc/py/lib&apos;)</code></pre><p>由于append()方法是把元素放在集合尾部，<strong>解释器是按照搜索路径顺序查找匹配的第一个模块名称</strong>，如果你有特殊需要, 那么应该使用列表的 insert() 方法操作。</p><p>补充：sys.path集合中值得顺序是：当前目录—&gt;环境变量PYTHONPATH中配置的目录—&gt;python的安装设置相关的默认路径</p><h2 id="模块导入方式"><a href="#模块导入方式" class="headerlink" title="模块导入方式"></a>模块导入方式</h2><h3 id="import-语句"><a href="#import-语句" class="headerlink" title="import 语句"></a>import 语句</h3><pre><code>import mymodule</code></pre><p>这种方式导入模块，就在当前的名称空间(namespace)建立了一个到该模块的引用。这种引用必须使用全称，也就是说，当使用在被导入模块中定义的函数时，必须包含模块的名字。所以不能只使用funcname，而应该使用 mymodule.funcname</p><p>当前的名称空间(namespace)，意思就是说如果在一个模块的顶层导入, 那么它的作用域就是全局的; 如果在函数中导入, 那么它的作用域是局部的。</p><p>如果mymodule模块是被第一次导入, 它将被加载并执行。</p><h3 id="from-import语句"><a href="#from-import语句" class="headerlink" title="from-import语句"></a>from-import语句</h3><pre><code>from module import name1[ name2[,....nameN]</code></pre><p>from-import语句导入模块的指定属性。name1、name2… 直接被导入到当前名称空间里去，这意味着你不需要使用属性/句点属性标识来访问模块的标识符，可直接使用name1、name2。</p><p>值得提一下的是：</p><pre><code>from module import *</code></pre><p>上面这句话是把module模块中的’所有‘名称导入到当前名称空间中，但是：</p><ol><li><p>如果module中定义了__all__变量，那只能导入__all__中的名称。</p><pre><code># module.py__all__ = [&apos;a&apos;, &apos;b&apos;]a = 10b = 20c=50</code></pre><p> 只会导入 a、b两个名称。</p> <font color="red">__all__只针对 from module import * 语句起作用。</font></li><li><p>没有定义__all__变量时，会导入所有非’<em>‘开头的名称，在python中以’</em>‘开头认为是私有的。</p><pre><code># module.pya = 10_b = 20c=50</code></pre><p>只会导入 a、c两个名称。</p></li></ol><p>另外，我们认为 “from module import *” 不是良好的编程风格, 因为它”污染”当前名称<br>空间, 而且很可能覆盖当前名称空间中现有的名字。</p><p>我们只在两种场合下建议使用这样的方法, 一个场合是：目标模块中的属性非常多, 反复键入<br>模块名很不方便, 例如 Tkinter (Python/Tk) 和 NumPy (Numeric Python) 模块, 可能还有<br>socket 模块。另一个场合是在交互解释器下, 因为这样可以减少输入次数。</p><h2 id="扩展的import语句-as"><a href="#扩展的import语句-as" class="headerlink" title="扩展的import语句(as)"></a>扩展的import语句(as)</h2><p>意思是给自己导入的模块或模块中的名称起别名。</p><pre><code>import Tkinter as tkfrom cqi import FieldStorage as fiesto</code></pre><h2 id="导入模块执行机制"><a href="#导入模块执行机制" class="headerlink" title="导入模块执行机制"></a>导入模块执行机制</h2><p>第一次载入时执行模块(执行是指模块的顶层代码将被直接执行)，一个模块只被执行一次，无论被导入多少次，这样可以阻止多重导入时代码被多次执行。这个机制是通过sys.modules控制的。</p><p>导入模块时，是创建一个名为模块名称的对象，该对象引用模块的名字空间，这样就可以通过这个对象访问模块中的函数及变量。当多次导入同一个模块时，后面的import语句只是简单的创建一个到模块名字空间的引用而已。</p><p>sys.modules是一个字典，保存着所有被导入模块的模块名到模块对象的映射。这个字典用来决定是否需要使用import语句来导入一个模块的最新拷贝。</p><h2 id="模块导入规范"><a href="#模块导入规范" class="headerlink" title="模块导入规范"></a>模块导入规范</h2><p>我们推荐所有的模块在 Python 模块的开头部分导入。 而且最好按照这样的顺序:</p><ol><li>Python 标准库模块</li><li>Python 第三方模块</li><li>应用程序自定义模块</li></ol><p>然后使用一个空行分割这三类模块的导入语句。 这将确保模块使用固定的习惯导入, 有助于减<br>少每个模块需要的 import 语句数目。</p><h1 id="模块内建函数"><a href="#模块内建函数" class="headerlink" title="模块内建函数"></a>模块内建函数</h1><h2 id="import-函数"><a href="#import-函数" class="headerlink" title="__import__函数"></a>__import__函数</h2><pre><code>__import__(module_name[, globals[, locals[, fromlist]]])</code></pre><p><strong>import</strong>() 函数作为实际上导入模块的函数, 这意味着 import 语句调用 <strong>import</strong>() 函数完成它的工作。提供这个函数是为了让有特殊需要的用户覆盖它, 实现自定义的导入算法。</p><pre><code>#这两句话相等mymodule = __import__ (’module_name’)import module_name</code></pre><h2 id="global-和locals"><a href="#global-和locals" class="headerlink" title="global()和locals()"></a>global()和locals()</h2><p>globals() 和 locals() 内建函数分别返回调用者全局和局部名称空间的字典。 在一个函数内<br>部, 局部名称空间代表在函数执行时候定义的所有名字, locals() 函数返回的就是包含这些名字<br>的字典。 globals() 会返回函数可访问的全局名字。</p><p>在全局名称空间下, globals() 和 locals() 返回相同的字典, 因为这时的局部名称空间就是<br>全局空间。</p><pre><code>def foo():    print &apos;\ncalling foo()...&apos;    aString = &apos;bar&apos;    anInt = 42    print &quot;foo()&apos;s globals:&quot;, globals().keys()    print &quot;foo()&apos;s locals:&quot;, locals().keys()print &quot;__main__&apos;s globals:&quot;, globals().keys()print &quot;__main__&apos;s locals:&quot;, locals().keys() foo()</code></pre><p>执行这个脚本, 我们得到如下的输出:</p><pre><code>&gt;&gt;&gt; $ namespaces.py__main__&apos;s globals: [&apos;__doc__&apos;, &apos;foo&apos;, &apos;__name__&apos;, &apos;__builtins__&apos;]__main__&apos;s locals: [&apos;__doc__&apos;, &apos;foo&apos;, &apos;__name__&apos;, &apos;__builtins__&apos;]</code></pre><h2 id="reload"><a href="#reload" class="headerlink" title="reload()"></a>reload()</h2><p>reload() 内建函数可以重新导入一个已经导入的模块。 它的语法如下:</p><pre><code>reload(module)</code></pre><p>上述是python2中的写法，在python3中写法如下：</p><pre><code>import importlibimportlib.reload(module)</code></pre><p>使用 reload() 的时候有一些标准。 首先模块必须是全部<br>导入(不是使用 from-import), 而且它必须被成功导入。另外 reload() 函数的参数必须是模块自<br>身而不是包含模块名的字符串。 也就是说必须类似 reload(sys) 而不是 reload(‘sys’)。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>说了那么多，主要记住,模块导入原理，根据sys.path搜索的；模块执行机制，根据sys.modules控制的；以及模块的导入方式就可以了，接下来会有博文介绍python中包的概念。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在计算机程序的开发过程中，随着程序代码越写越多，在一个文件里代码就会越来越长，越来越不容易维护。为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在Python中，一个.py文件就称之为一个模块（Module）。&lt;/p&gt;
&lt;p&gt;使用模块有什么好处？&lt;/p&gt;
&lt;p&gt;最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括Python内置的模块和来自第三方的模块。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://waisunny.com/categories/Python/"/>
    
    
      <category term="python基础" scheme="http://waisunny.com/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>python黑魔法—装饰器</title>
    <link href="http://waisunny.com/2017/12/26/python%E9%BB%91%E9%AD%94%E6%B3%95%E2%80%94%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <id>http://waisunny.com/2017/12/26/python黑魔法—装饰器/</id>
    <published>2017-12-26T09:37:26.000Z</published>
    <updated>2018-01-21T23:58:10.027Z</updated>
    
    <content type="html"><![CDATA[<p>先来一个形象的比喻：</p><p>内裤可以用来遮羞，但是到了冬天它没法为我们防风御寒，聪明的人们发明了长裤，有了长裤后宝宝再也不冷了，装饰器就像我们这里说的长裤，在不影响内裤作用的前提下，给我们的身子提供了保暖的功效。</p><p>再回到我们的主题</p><a id="more"></a><p><strong>什么是装饰器？</strong></p><p>装饰器本质上是一个Python函数，它可以让其它函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值是一个函数对象。</p><p><strong>装饰器有哪些使用场景？</strong></p><p>它经常用于有切面(AOP)需求的场景，比如：<strong>插入日志、性能测试、事务处理、缓存、权限校验</strong>等场景。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码并继续重用。概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。</p><h1 id="函数装饰器"><a href="#函数装饰器" class="headerlink" title="函数装饰器"></a>函数装饰器</h1><p>我们用一个小例子一步步引出装饰器：</p><pre><code>def fun():    print(&apos;my name is fun&apos;)</code></pre><p>上面我们定义了一个fun函数，函数运行时告诉用户一些信息。</p><p>现在我们有一个新的需求，需要给增加日志记录的功能，怎么办？</p><pre><code>import logginglogging.basicConfig(filename=&apos;log1.log&apos;,level=logging.DEBUG)def fun():    print(&apos;my name is fun&apos;)    logging.debug(&apos;fun is running&apos;)fun()</code></pre><p>我们借助了python内置的logging模块实现了日志记录的功能，运行上述代码能成功记录日志，新增的需求开发完了，真的开发完了吗？如果我们有fun1(),fun2()…等其它函数也需要记录日志呢，难道每一个函数都要加上一句logging.debug()语句吗？这样的话会有很多重复代码；我们可以定义一个专门记录日志的函数：</p><pre><code>import logginglogging.basicConfig(filename=&apos;log1.log&apos;,level=logging.DEBUG)def use_log(fun):    logging.debug(&apos;%s is running&apos;%fun.__name__)    fun()def fun():    print(&apos;my name is fun&apos;)use_log(fun)</code></pre><p>逻辑上不难理解，而且解决了重复代码的问题 ，但是它有一个极大的弊端；它改变了 用户的请求方式，以前我们只需要调用fun()函数即可，现在我们必须调用    use_log(fun)才行，这是 一个很糟糕的设计，想一想，我们的程序可能已经发布到了生产环境，也许正在有很多用户在使用，这么一改，用户按照以前的方式调用，全挂掉了，这种设计还不如第一种呢….,那没有什么好办法了吗？在不改变原有调用方式的前提下，增加日志记录功能。当然有,就是我们的装饰器：</p><p>简单的装饰器：</p><pre><code>import logginglogging.basicConfig(filename=&apos;log1.log&apos;,level=logging.DEBUG)def use_log(fun):    def wrapper():        logging.debug(&apos;%s is running&apos;%fun.__name__)        fun()    return wrapperdef fun():    print(&apos;my name is fun&apos;)fun=use_log(fun)fun()</code></pre><p>上述调用方式看起来有点麻烦，幸运的是python中给我们提供了语法糖，上述代码直接修改成：</p><pre><code>@use_log  等价于 fun=use_log(fun)def fun():    print(&apos;my name is fun&apos;)fun()</code></pre><p>use_log函数就是一个装饰器函数，内部函数 wrapper 是用来执行具体操作逻辑的函数。</p><p>不难看出usel_log其实也是一个闭包函数，没错，装饰器就是基于（闭包，高阶函数）实现的。</p><p>这样我们在不改变原有函数调用方式的前提下，增加了日志功能，并提高了代码的复用性。</p><p>上面的装饰器过于简单，如果我们要执行的函数带有参数怎么办？</p><h2 id="给功能函数加参数"><a href="#给功能函数加参数" class="headerlink" title="给功能函数加参数"></a><strong>给功能函数加参数</strong></h2><pre><code>import logginglogging.basicConfig(filename=&apos;log1.log&apos;,level=logging.DEBUG)def use_log(fun):    def wrapper(*args,**kwargs):        logging.debug(&apos;%s is running&apos;%fun.__name__)        fun(*args,**kwargs)    return wrapper@use_logdef fun(name):    print(&apos;my name is fun,params is %s&apos;%name)fun(&apos;_learner&apos;)</code></pre><p>我们将装饰器的内部函数定义成了 def wrapper(<em>args,*</em>kwargs): 的形式，这样就可以接受任何参数了。</p><p>现在我们又有了一个新的需求，函数可以自己控制是否记录日志；这时就需要用到装饰器参数了</p><h2 id="给装饰器函数加参数"><a href="#给装饰器函数加参数" class="headerlink" title="给装饰器函数加参数"></a><strong>给装饰器函数加参数</strong></h2><pre><code>import logginglogging.basicConfig(filename=&apos;log1.log&apos;,level=logging.DEBUG)def use_Log(is_log=1):    def decorator(fun):        def wrapper(*args,**kwargs):            if is_log:                logging.debug(&apos;%s is running&apos;%fun.__name__)            fun(*args,**kwargs)        return wrapper    return decorator@use_Log(0) 等价于 @decorator 等价于 fun=decorator(fun)def fun(name):    print(&apos;my name is fun,params is %s&apos;%name)fun(&apos;_learner&apos;)</code></pre><p>给装饰器函数加参数的方式：多定义一层外部函数，用于接受参数，该外部函数的返回值就是装饰器函数。</p><h1 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a><strong>类装饰器</strong></h1><p>再来看看类装饰器，相比函数装饰器，类装饰器具有灵活度大、高内聚、封装性等优点。使用类装饰器还可以依靠类内部的__call__方法，当使用 @ 形式将装饰器附加到函数上时，就会调用此方法。</p><h2 id="装饰器无参数，被装饰对象有参数"><a href="#装饰器无参数，被装饰对象有参数" class="headerlink" title="装饰器无参数，被装饰对象有参数"></a>装饰器无参数，被装饰对象有参数</h2><pre><code>class Decorator:    def __init__(self,func):# func是被装饰的对象        self.func=func    def __call__(self,*args, **kwargs):#*args, **kwargs用于承载被装饰对象的参数        print(&apos;class decoratoe is running&apos;)        self.func(*args,**kwargs)        print(&apos;class decorator is runned&apos;)@Decoratordef fun(name):    print(&apos;my name is %s&apos;%name)fun(&apos;_learner&apos;)</code></pre><p>运行结果：</p><pre><code>class decoratoe is runningmy name is _learnerclass decorator is runned</code></pre><h2 id="装饰器有参数，被装饰对象也有参数"><a href="#装饰器有参数，被装饰对象也有参数" class="headerlink" title="装饰器有参数，被装饰对象也有参数"></a>装饰器有参数，被装饰对象也有参数</h2><pre><code>class Decorator:    def __init__(self,is_print): # is_print 装饰器参数        self.is_print=is_print    def __call__(self,func): # func是被装饰的对象        def _cal(*args, **kwargs):# *args, **kwargs用于承载被装饰对象的参数            if self.is_print:                print(&apos;class decoratoe is running&apos;)                func(*args,**kwargs)                print(&apos;class decorator is runned&apos;)            else:                func(*args, **kwargs)        return _cal@Decorator(0)def fun(name):    print(&apos;my name is %s&apos;%name)fun(&apos;_learner&apos;)</code></pre><p>运行结果：</p><pre><code>my name is _learner</code></pre><h1 id="functools-wraps"><a href="#functools-wraps" class="headerlink" title="functools.wraps"></a><strong>functools.wraps</strong></h1><p>使用装饰器极大地复用了代码，但是他有一个缺点就是原函数的元信息不见了，比如函数的__doc__、__name__、参数列表，先看例子：</p><pre><code>def logged(fun):    def with_logging(*args,**kwargs):        &apos;&apos;&apos;with_logging&apos;&apos;&apos;        print(&apos;was called: %s&apos;%fun.__name__)        return fun(*args,**kwargs)    return with_logging@loggeddef f(x):    &apos;&apos;&apos; does some math&apos;&apos;&apos;    return x*xf(5)print(f.__name__)print(f.__doc__)</code></pre><p>运行结果：</p><pre><code>was called: fwith_loggingwith_logging</code></pre><p>能看出函数f的__doc__、__name__属性值全部变成了内部函数with_logging的了；这个问题是比较严重的，好在我们有functools.wraps，wraps本身也是一个装饰器，它能把原函数的元信息拷贝到装饰器函数中，这使得装饰器函数也有和原函数一样的元信息了。</p><pre><code>from  functools import wrapsdef logged(fun):    @wraps(fun)    def with_logging(*args,**kwargs):        &apos;&apos;&apos;with_logging&apos;&apos;&apos;        print(with_logging.__doc__)        print(with_logging.__name__)        return fun(*args,**kwargs)    return with_logging@loggeddef f(x):    &apos;&apos;&apos;does some math&apos;&apos;&apos;    return x*xf(5)print(f.__name__)print(f.__doc__)</code></pre><p>运行结果：</p><pre><code>does some mathffdoes some math</code></pre><h1 id="装饰器执行顺序"><a href="#装饰器执行顺序" class="headerlink" title="装饰器执行顺序"></a><strong>装饰器执行顺序</strong></h1><pre><code>@a@b@cdef fun():    pass</code></pre><p>等价于</p><pre><code>fun=a(b(c(fun)))</code></pre><h1 id="内置装饰器"><a href="#内置装饰器" class="headerlink" title="内置装饰器"></a><strong>内置装饰器</strong></h1><p>@staticmathod、@classmethod、@property</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>装饰器是python中一个相当重要的内容，它是在闭包合高阶函数的基础上实现的；可以定义函数装饰器、类装饰器等；它们分别都可以装饰函数、类等。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先来一个形象的比喻：&lt;/p&gt;
&lt;p&gt;内裤可以用来遮羞，但是到了冬天它没法为我们防风御寒，聪明的人们发明了长裤，有了长裤后宝宝再也不冷了，装饰器就像我们这里说的长裤，在不影响内裤作用的前提下，给我们的身子提供了保暖的功效。&lt;/p&gt;
&lt;p&gt;再回到我们的主题&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://waisunny.com/categories/Python/"/>
    
    
      <category term="python基础" scheme="http://waisunny.com/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>python中的下划线</title>
    <link href="http://waisunny.com/2017/12/24/python%E4%B8%AD%E7%9A%84%E4%B8%8B%E5%88%92%E7%BA%BF/"/>
    <id>http://waisunny.com/2017/12/24/python中的下划线/</id>
    <published>2017-12-24T15:56:58.000Z</published>
    <updated>2017-12-24T08:24:47.582Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章讨论Python中下划线<em>的使用。跟Python中很多用法类似，下划线</em>的不同用法绝大部分（不全是）都是一种惯例约定。<br><a id="more"></a></p><h1 id="单个下划线（-）"><a href="#单个下划线（-）" class="headerlink" title="单个下划线（_）"></a>单个下划线（_）</h1><p>主要有三种情况：</p><ol><li><p>解释器中<br>_符号是指交互解释器中最后一次执行语句的返回结果。这种用法最初出现在CPython解释器中，其他解释器后来也都跟进了。</p><pre><code>&gt;&gt;&gt; _Traceback (most recent call last):File &quot;&quot;, line 1, in NameError: name &apos;_&apos; is not defined&gt;&gt;&gt; 42&gt;&gt;&gt; _42&gt;&gt;&gt; &apos;alright!&apos; if _ else &apos;:(&apos;&apos;alright!&apos;&gt;&gt;&gt; _&apos;alright!&apos;</code></pre></li><li><p>作为名称使用<br>这个跟上面有点类似。_用作被丢弃的名称。按照惯例，这样做可以让阅读你代码的人知道，这是个不会被使用的特定名称。举个例子，你可能无所谓一个循环计数的值：</p><pre><code>n = 42for _ in range(n):    do_something()</code></pre></li><li><p>i18n<br>_还可以被用作函数名。这种情况，单下划线经常被用作国际化和本地化字符串翻译查询的函数名。这种惯例好像起源于C语言。举个例子，在 <a href="https://docs.djangoproject.com/en/dev/topics/i18n/translation/" target="_blank" rel="external">Django documentation for translation</a> 中你可能会看到：</p><pre><code>from django.utils.translation import ugettext as _from django.http import HttpResponsedef my_view(request):    output = _(&quot;Welcome to my site.&quot;)    return HttpResponse(output)</code></pre></li></ol><p>第二种和第三种用法会引起冲突，所以在任意代码块中，如果使用了_作i18n翻译查询函数，就应该避免再用作被丢弃的变量名。</p><h1 id="单下划线前缀的名称（例如-shahriar）"><a href="#单下划线前缀的名称（例如-shahriar）" class="headerlink" title="单下划线前缀的名称（例如_shahriar）"></a>单下划线前缀的名称（例如_shahriar）</h1><p>单下划线开头被常用于模块中，在一个模块中以单下划线开头的变量和函数被默认当作内部函数,“私有成员”，如果使用 from a<em>module import * 导入时，这部分变量和函数不会被导入,除非模块/包的\</em>_all__列表明确包含了这些名称。不过值得注意的是，如果使用 import a_module 这样导入模块，仍然可以用 a_module._some_var 这样的形式访问到这样的对象。</p><h1 id="双下划线前缀的名称（例如-shahriar）"><a href="#双下划线前缀的名称（例如-shahriar）" class="headerlink" title="双下划线前缀的名称（例如__shahriar）"></a>双下划线前缀的名称（例如__shahriar）</h1><p>以双下划线做前缀的名称（特别是方法名）并不是一种惯例；它对解释器有特定含义。Python会改写这些名称，以免与子类中定义的名称产生冲突。Python documentation中提到，任何__spam这种形式（至少以两个下划线做开头，绝大部分都还有一个下划线做结尾）的标识符，都会文本上被替换为_classname__spam，其中classname是当前类名，并带上一个下划线做前缀。</p><p>看下面这个例子：</p><pre><code>&gt;&gt;&gt; class A(object):...     def _internal_use(self):...         pass...     def __method_name(self):...         pass... &gt;&gt;&gt; dir(A())[&apos;_A__method_name&apos;, ..., &apos;_internal_use&apos;]</code></pre><p>正如所料，_internal<em>use没有变化，但\</em>_method_name被改写成了_ClassName__method_name。现在创建一个A的子类B（这可不是个好名字），就不会轻易的覆盖掉A中的__method_name了：</p><pre><code>&gt;&gt;&gt; class B(A):...     def __method_name(self):...         pass... &gt;&gt;&gt; dir(B())[&apos;_A__method_name&apos;, &apos;_B__method_name&apos;, ..., &apos;_internal_use&apos;]</code></pre><p>这种特定的行为差不多等价于Java中的final方法和C++中的正常方法（非虚方法）。</p><h1 id="前后都带有双下划线的名称（例如-init-）"><a href="#前后都带有双下划线的名称（例如-init-）" class="headerlink" title="前后都带有双下划线的名称（例如 __init__）"></a>前后都带有双下划线的名称（例如 __init__）</h1><p>这些是Python的特殊方法名，这仅仅是一种惯例，一种确保Python系统中的名称不会跟用户自定义的名称发生冲突的方式。通常你可以覆写这些方法，在Python调用它们时，产生你想得到的行为。例如，当写一个类的时候经常会覆写__init__方法。Python 官方推荐永远不要将这样的命名方式应用于自己的变量或函数，而是按照文档说明来使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章讨论Python中下划线&lt;em&gt;的使用。跟Python中很多用法类似，下划线&lt;/em&gt;的不同用法绝大部分（不全是）都是一种惯例约定。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://waisunny.com/categories/Python/"/>
    
    
      <category term="python基础" scheme="http://waisunny.com/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Python黑魔法—上下文管理器</title>
    <link href="http://waisunny.com/2017/12/21/Python%E9%BB%91%E9%AD%94%E6%B3%95%E2%80%94%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8/"/>
    <id>http://waisunny.com/2017/12/21/Python黑魔法—上下文管理器/</id>
    <published>2017-12-20T16:51:59.000Z</published>
    <updated>2017-12-24T09:46:16.171Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是上下文管理器"><a href="#什么是上下文管理器" class="headerlink" title="什么是上下文管理器"></a>什么是上下文管理器</h1><p>上下文管理器顾名思义是管理上下文的,也就是负责冲锋和垫后,而让主人专心完成自己的事情。我们在编写程序的时候，通常会将一系列操作放到一个语句块中，当某一条件为真时执行该语句快。有时候，我们需要再执行一个语句块时保持某种状态，并且在离开语句块后结束这种状态。例如对文件的操作，我们在打开一个文件进行读写操作时需要保持文件处于打开状态，而等操作完成之后要将文件关闭。所以，上下文管理器的任务是：代码块执行前准备，代码块执行后收拾。上下文管理器是在Python2.5加入的功能，它能够让你的代码可读性更强并且错误更少。</p><p>需求的产生<br>在正常的管理各种系统资源(文件、锁定和连接)，在涉及到异常时通常是个棘手的问题。异常很可能导致控制流跳过负责释放关键资源的语句。例如打开一个文件进行操作时，如果意外情况发生（磁盘已满、特殊的终端信号让其终止等），就会抛出异常，这样可能最后的文件关闭操作就不会执行。如果这样的问题频繁出现，则可能耗尽系统资源。</p><p>是的，这样的问题并不是不可避免。在没有接触到上下文管理器之前，我们可以用“try/finally”语句来解决这样的问题。或许在有些人看来，“try/finally”语句显得有些繁琐。上下文管理器就是被设计用来简化“try/finally”语句的，这样可以让程序更加简洁。<br><a id="more"></a></p><h1 id="With语句"><a href="#With语句" class="headerlink" title="With语句"></a>With语句</h1><p>With语句用于执行上下文操作，它也是复合语句的一种，其基本语法如下所示：</p><pre><code>with context_expr [as var]:    with_suite</code></pre><p>With 语句仅能工作于支持上下文管理协议(context management protocol)的对象。也就是说只有内建了”上下文管理”的对象才能和 with 一起工作。Python内置了一些支持该协议的对象，如下所列是一个简短列表：</p><ol><li>file</li><li>decimal.Context</li><li>thread.LockType</li><li>threading.Lock</li><li>threading.RLock</li><li>threading.Condition</li><li>threading.Semaphore</li><li>threading.BoundedSemaphore</li></ol><p>由以上列表可以看出，file 是已经内置了对上下文管理协议的支持。所以我们可以用下边的方法来操作文件：</p><pre><code>with open(&apos;/etc/passwd&apos;, &apos;r&apos;) as f:    for eachLine in f:        # ...do stuff with eachLine or f...</code></pre><p>上边的代码试图打开一个文件,如果一切正常,把文件对象赋值给 f。然后用迭代器遍历文件中的每一行,当完成时,关闭文件。无论是在这一段代码的开始,中间,还是结束时发生异常,会执行清理的代码,此外文件仍会被自动的关闭。</p><h1 id="自定义上下文管理器"><a href="#自定义上下文管理器" class="headerlink" title="自定义上下文管理器"></a>自定义上下文管理器</h1><p>要实现上下文管理器，必须实现两个方法：一个负责进入语句块的准备操作，另一个负责离开语句块的善后操作。Python类包含两个特殊的方法，分别名为：<strong>__enter__ 和 __exit__</strong>。</p><p>__enter__: 该方法进入运行时上下文环境，并返回自身或另一个与运行时上下文相关的对象。返回值会赋给 as 从句后面的变量，as 从句是可选的。</p><p>__exit__: 该方法退出当前运行时上下文并返回一个布尔值，该布尔值标明了“如果 with<em>suit 的退出是由异常引发的，该异常是否须要被忽略”。如果 \</em>_exit__() 的返回值等于 False，那么这个异常将被重新引发一次；如果 __exit__() 的返回值等于 True，那么这个异常就被无视掉，继续执行后面的代码。</p><p>With 语句的实际执行流程是这样的：</p><ol><li>执行 context_exp 以获取上下文管理器</li><li>加载上下文管理器的 __exit__() 方法以备稍后调用</li><li>调用上下文管理器的 __enter__() 方法</li><li>如果有 as var 从句，则将 __enter__() 方法的返回值赋给 var</li><li>执行子代码块 with_suit</li><li>调用上下文管理器的 __exit__() 方法，如果 with<em>suit 的退出是由异常引发的，那么该异常的 type、value 和 traceback 会作为参数传给 \</em>_exit__()，否则传三个 None。</li><li>如果 with<em>suit 的退出由异常引发，并且 \</em>_exit__() 的返回值等于 False，那么这个异常将被重新引发一次；如果 __exit__() 的返回值等于 True，那么这个异常就被无视掉，继续执行后面的代码</li></ol><p>下面我们自己来实现一个支持上下文管理协议的类：</p><pre><code>class Query(object):    def __init__(self, name):        self.name = name    def __enter__(self):        print(&apos;Begin&apos;)        return self    def __exit__(self, exc_type, exc_value, traceback):        if exc_type:            print(&apos;Error&apos;)        else:            print(&apos;End&apos;)    def query(self):        print(&apos;Query info about %s...&apos; % self.name)</code></pre><p>这样我们就可以把自己写的资源对象用于with语句：</p><pre><code>with Query(&apos;_learner&apos;) as q:    q.query()</code></pre><p>执行结果：</p><pre><code>BeginQuery info about _learner...End</code></pre><h1 id="上下文管理工具（contextlib模块）"><a href="#上下文管理工具（contextlib模块）" class="headerlink" title="上下文管理工具（contextlib模块）"></a>上下文管理工具（contextlib模块）</h1><p><strong>contextlib</strong>模块提供更易用的上下文管理器。</p><h2 id="contextmanager"><a href="#contextmanager" class="headerlink" title="@contextmanager"></a>@contextmanager</h2><p>编写<strong>enter</strong>和<strong>exit</strong>仍然很繁琐，因此Python的标准库contextlib提供了更简单的写法，上面的代码可以改写如下：</p><pre><code>from contextlib import contextmanagerclass Query(object):    def __init__(self, name):        self.name = name    def query(self):        print(&apos;Query info about %s...&apos; % self.name)@contextmanagerdef create_query(name):    print(&apos;Begin&apos;)    q = Query(name)    yield q    print(&apos;End&apos;)</code></pre><p><strong>@contextmanager</strong>这个decorator接受一个generator，用yield语句把with … as var把变量输出出去，然后，with语句就可以正常地工作了：</p><pre><code>with create_query(&apos;_learner&apos;) as q:    q.query()</code></pre><p>执行结果：</p><pre><code>BeginQuery info about _learner...End</code></pre><p>很多时候，我们希望在某段代码执行前后自动执行特定代码，也可以用@contextmanager实现。例如：</p><pre><code>@contextmanagerdef tag(name):    print(&quot;&lt;%s&gt;&quot; % name)    yield    print(&quot;&lt;/%s&gt;&quot; % name)with tag(&quot;h1&quot;):    print(&quot;hello&quot;)    print(&quot;world&quot;)</code></pre><p>上述代码执行结果为：</p><pre><code>&lt;h1&gt;helloworld&lt;/h1&gt;</code></pre><p>代码的执行顺序是：</p><ol><li>with语句首先执行yield之前的语句，因此打印出<h1\>；</h1\></li><li>yield调用会执行with语句内部的所有语句，因此打印出hello和world；</li><li>最后执行yield之后的语句，打印出。</li></ol><p>因此，@contextmanager让我们通过编写generator来简化上下文管理。</p><h2 id="closing"><a href="#closing" class="headerlink" title="@closing"></a>@closing</h2><p>如果一个对象没有实现上下文，我们就不能把它用于with语句。这个时候，可以用closing()来把该对象变为上下文对象。例如，用with语句使用urlopen()：</p><pre><code>from contextlib import closingfrom urllib.request import urlopenwith closing(urlopen(&apos;https://www.python.org&apos;)) as page:    for line in page:        print(line)</code></pre><p><strong>closing</strong>也是一个经过<strong>@contextmanager</strong>装饰的generator，这个generator编写起来其实非常简单：</p><pre><code>@contextmanagerdef closing(thing):    try:        yield thing    finally:        thing.close()</code></pre><p>重写上面的例子：</p><pre><code>from contextlib import  contextmanagerfrom urllib.request import urlopen@contextmanagerdef closing(thing):    try:        yield thing    finally:        thing.close()with closing(urlopen(&apos;https://www.python.org&apos;)) as page:    for line in page:        print(line)</code></pre><p>它的作用就是把任意对象变为上下文对象，并支持with语句。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是上下文管理器&quot;&gt;&lt;a href=&quot;#什么是上下文管理器&quot; class=&quot;headerlink&quot; title=&quot;什么是上下文管理器&quot;&gt;&lt;/a&gt;什么是上下文管理器&lt;/h1&gt;&lt;p&gt;上下文管理器顾名思义是管理上下文的,也就是负责冲锋和垫后,而让主人专心完成自己的事情。我们在编写程序的时候，通常会将一系列操作放到一个语句块中，当某一条件为真时执行该语句快。有时候，我们需要再执行一个语句块时保持某种状态，并且在离开语句块后结束这种状态。例如对文件的操作，我们在打开一个文件进行读写操作时需要保持文件处于打开状态，而等操作完成之后要将文件关闭。所以，上下文管理器的任务是：代码块执行前准备，代码块执行后收拾。上下文管理器是在Python2.5加入的功能，它能够让你的代码可读性更强并且错误更少。&lt;/p&gt;
&lt;p&gt;需求的产生&lt;br&gt;在正常的管理各种系统资源(文件、锁定和连接)，在涉及到异常时通常是个棘手的问题。异常很可能导致控制流跳过负责释放关键资源的语句。例如打开一个文件进行操作时，如果意外情况发生（磁盘已满、特殊的终端信号让其终止等），就会抛出异常，这样可能最后的文件关闭操作就不会执行。如果这样的问题频繁出现，则可能耗尽系统资源。&lt;/p&gt;
&lt;p&gt;是的，这样的问题并不是不可避免。在没有接触到上下文管理器之前，我们可以用“try/finally”语句来解决这样的问题。或许在有些人看来，“try/finally”语句显得有些繁琐。上下文管理器就是被设计用来简化“try/finally”语句的，这样可以让程序更加简洁。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://waisunny.com/categories/Python/"/>
    
    
      <category term="python基础" scheme="http://waisunny.com/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>python 闭包</title>
    <link href="http://waisunny.com/2017/12/18/python-%E9%97%AD%E5%8C%85/"/>
    <id>http://waisunny.com/2017/12/18/python-闭包/</id>
    <published>2017-12-18T11:03:42.000Z</published>
    <updated>2018-01-28T06:05:52.668Z</updated>
    
    <content type="html"><![CDATA[<p>首先，什么是闭包？，它的定义如下：</p><p>如果在一个内部函数里，对在外部作用域 (但不是全局作用域)的变量进行引用，那么内部函数就被认为是闭包。</p><p>定义在外部函数内的但由内部函数引用或者使用的变量被称为自由变量。</p><p>分析一下满足闭包的必备条件：</p><ol><li>需要函数嵌套, 就是一个函数里面再写一个函数.</li><li>外部函数中有一些局部变量, 并且, 这些局部变量在内部函数中有使用。</li><li>外部函数必须返回内嵌函数<a id="more"></a></li></ol><p>看一个简单的例子：</p><pre><code>def counter(start_at=0):     count = [start_at]     def incr():        count[0] += 1        return count[0]    return incr</code></pre><p>上面的例子使用闭包实现了一个计数器，调用结果如下：</p><pre><code>&gt;&gt;&gt; cou=counter(5)&gt;&gt;&gt; cou()6&gt;&gt;&gt; cou()7</code></pre><h1 id="closure-属性"><a href="#closure-属性" class="headerlink" title="__closure__属性"></a>__closure__属性</h1><p>在Python中，函数对象有一个<strong>closure</strong>属性，我们可以通过这个属性看看闭包的一些细节。</p><pre><code>def counter(start_at=0):    count = [start_at]    def incr():        count[0]+=1        return count    return incrfunc=counter(5)print(dir(func))print(func.__closure__)print(type(func.__closure__))print(type(func.__closure__[0]))print(func.__closure__[0].cell_contents)</code></pre><p>执行结果：</p><pre><code>[&apos;__call__&apos;, &apos;__class__&apos;, &apos;__closure__&apos;, &apos;__code__&apos;, &apos;__defaults__&apos;, &apos;__delattr__&apos;, &apos;__dict__&apos;, &apos;__doc__&apos;, &apos;__format__&apos;, &apos;__get__&apos;, &apos;__getattribute__&apos;, &apos;__globals__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__module__&apos;, &apos;__name__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;func_closure&apos;, &apos;func_code&apos;, &apos;func_defaults&apos;, &apos;func_dict&apos;, &apos;func_doc&apos;, &apos;func_globals&apos;, &apos;func_name&apos;](&lt;cell at 0x00000000029C85E8: list object at 0x000000000291CE88&gt;,)&lt;type &apos;tuple&apos;&gt;&lt;type &apos;cell&apos;&gt;[5]</code></pre><p>通过<strong>closure</strong>属性看到，它对应了一个tuple，tuple的内部包含了cell类型的对象。</p><p>对于这个例子，可以得到cell的值（内容）为”[5]”，也就是变量”count”的值。</p><p>从这里可以看到闭包的原理，当内嵌函数引用了包含它的函数（enclosing function）中的变量后，这些变量会被保存在enclosing function的<strong>closure</strong>属性中，成为enclosing function本身的一部分；也就是说，这些变量的生命周期会和enclosing function一样。</p><h1 id="闭包和函数"><a href="#闭包和函数" class="headerlink" title="闭包和函数"></a>闭包和函数</h1><p>闭包只是在表现形式上跟函数类似，但实际上不是函数。</p><pre><code>def counter(start_at=0):    count = [start_at]    def incr():        count[0]+=1        return count    return incrfunc1=counter(5)print (&quot;function name is:&quot;, func1.__name__)print (&quot;id of mGreeting is:&quot;, id(func1))func2=counter(5)print (&quot;function name is:&quot;, func2.__name__)print (&quot;id of mGreeting is:&quot;, id(func2))</code></pre><p>执行结果：</p><pre><code>(&apos;function name is:&apos;, &apos;incr&apos;)(&apos;id of mGreeting is:&apos;, 44399080L)(&apos;function name is:&apos;, &apos;incr&apos;)(&apos;id of mGreeting is:&apos;, 44399192L)</code></pre><p>从代码的结果中可以看到，闭包在运行时可以有多个实例。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文介绍了如何通过Python创建一个闭包，以及Python创建的闭包是如何工作的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先，什么是闭包？，它的定义如下：&lt;/p&gt;
&lt;p&gt;如果在一个内部函数里，对在外部作用域 (但不是全局作用域)的变量进行引用，那么内部函数就被认为是闭包。&lt;/p&gt;
&lt;p&gt;定义在外部函数内的但由内部函数引用或者使用的变量被称为自由变量。&lt;/p&gt;
&lt;p&gt;分析一下满足闭包的必备条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;需要函数嵌套, 就是一个函数里面再写一个函数.&lt;/li&gt;
&lt;li&gt;外部函数中有一些局部变量, 并且, 这些局部变量在内部函数中有使用。&lt;/li&gt;
&lt;li&gt;外部函数必须返回内嵌函数
    
    </summary>
    
      <category term="Python" scheme="http://waisunny.com/categories/Python/"/>
    
    
      <category term="python基础" scheme="http://waisunny.com/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Python 开发者都会遇到的错误：UnboundLocalError</title>
    <link href="http://waisunny.com/2017/12/17/Python-%E5%BC%80%E5%8F%91%E8%80%85%E9%83%BD%E4%BC%9A%E9%81%87%E5%88%B0%E7%9A%84%E9%94%99%E8%AF%AF%EF%BC%9AUnboundLocalError/"/>
    <id>http://waisunny.com/2017/12/17/Python-开发者都会遇到的错误：UnboundLocalError/</id>
    <published>2017-12-17T11:03:42.000Z</published>
    <updated>2018-01-28T06:05:35.151Z</updated>
    
    <content type="html"><![CDATA[<p>每个 Python 开发者都至少会经历一次 UnboundLocalError 的错误，初次遇到这种错误会觉得莫名其妙，用这张图来描述当时的心情最为贴切：<br><img src="https://i.imgur.com/nJmYi4j.jpg" alt=""><br><a id="more"></a><br>比如下面的代码在 foo 函数中给 x 自增 1：</p><pre><code>x = 10def foo():    x += 1    print(x)foo()</code></pre><p>调用 foo() 的时候，就会看到这个错误：</p><pre><code>UnboundLocalError: local variable &apos;x&apos; referenced before assignment</code></pre><p>堆栈日志告诉我们：局部变量 x 赋值前在其它地方被引用了，换句话说就是 x 在当前作用域内还没有定义就拿来使用了。</p><p>明明 x 在函数 foo 的外面定义了，为什么却告知我们说 x 没赋值就被引用了呢？</p><p>因为这是几乎每个人都会遇到的错误，所以 Python 官方把这个问题收入到了它的 FAQ 中，它是这样说的：</p><p>This is because when you make an assignment to a variable in a scope, that variable becomes local to that scope and shadows any similarly named variable in the outer scope.</p><font color="red"><strong>翻译过来就是，当你在局部作用域中给变量赋值时，那么这个变量就会变成一个局部变量，不管它在外部有没有初始化。如果外部作用域有相同名字的变量，那么对局部空间来说这些相同名字的全局变量都将被隐藏为不可见的。</strong></font><p><strong>如果在局部作用域中没有给变量 x 重新赋值，而是直接引用它，那么 Python 会沿着 LEGB（local-&gt;-enclosing-&gt;global-&gt;built-in） 的规则顺序查找变量。</strong></p><p>在这里，x += 1 等价于 x = x + 1，首先会执行 x + 1 操作，然后再赋值给 x。而执行加法操作之前它会先查找变量 x，根据官方的这个解释所述， Python 认为 x 对函数 foo 来说一个局部变量，因为它有赋值操作，既然 x 是局部变量，在执行加法操作时，又引用了 x，所以抛出了 <strong>UnboundLocalError</strong> 异常。</p><p>那么，该异常如何解决？办法非常简单，Python 提供了一个关键字 globlal，用来显示地标识 x 为全局变量，x 设置为全局变量后，执行加操作的时候就会去全局命名空间查找 x 。</p><pre><code>x = 10def foo():    global x    x += 1    print(x)foo()</code></pre><p>执行结果：</p><pre><code>11</code></pre><p>容易混淆的可变类型的例子：</p><pre><code>lst = [1, 2, 3]def foo():    lst.append(5)   # 正常执行，lst 没有重新赋值，首先在局部作用域查找，没找到再往全局作用域查找 lst    #lst += [5]     # UnboundLocalError 错误，因为重新赋值了，而在局部作用域没定义就引用了foo()print(lst)</code></pre><p>这个问题解决之后，再来看另外一个类似的问题：</p><pre><code>def external():    x = 10    def internal():        x += 1        print(x)    internal()external()</code></pre><p>这是一个 Python 闭包，执行 external 函数的时候，看代码你也知道会报同样的 UnboundLocalError 错误，那么用 global 来 修复可行吗？试试：</p><pre><code>def external():    x = 10    def internal():        global x        x += 1        print(x)    internal()external()</code></pre><p>新的错误出现了:</p><pre><code>NameError: name &apos;x&apos; is not defined</code></pre><p>全部变量 x 没有定义，仔细想想也是啊，你看 x 是定义在 external 函数中的一个局部变量，现在你要把 internal 函数中的 x 声明为全局变量，Python 在全局作用域空间 找不到 x ，所以出现了 NameError，那么这个问题又该如何解决呢？如果你是使用 Python3，恭喜你，Python3 中新增了一个关键字 nonlocal，用于表示非局部变量。</p><pre><code>def external():    x = 10    def internal():        nonlocal x        x += 1        print(x)    internal()external()</code></pre><p>执行结果：</p><pre><code>11</code></pre><p>补充：</p><pre><code>import disx = 10def foo():    x += 1    print(x)dis.dis(foo)</code></pre><p>用 dis.dis(foo) 可以看到 Python 内部字节码指令的执行过程，从字节码中可以知道，第三行代码 x= x+1 操作的指令是 LOAD_FAST ，LOAD_FAST  0 (x) 表示 Python 解释器 从局部作用域加载 x，而 x 由找不到，因此出现了UnboundLocalError。</p><pre><code>4         0 LOAD_FAST                0 (x)          2 LOAD_CONST               1 (1)          4 INPLACE_ADD          6 STORE_FAST               0 (x)5         8 LOAD_GLOBAL              0 (print)         10 LOAD_FAST                0 (x)         12 CALL_FUNCTION            1         14 POP_TOP         16 LOAD_CONST               0 (None)         18 RETURN_VALUE</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每个 Python 开发者都至少会经历一次 UnboundLocalError 的错误，初次遇到这种错误会觉得莫名其妙，用这张图来描述当时的心情最为贴切：&lt;br&gt;&lt;img src=&quot;https://i.imgur.com/nJmYi4j.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://waisunny.com/categories/Python/"/>
    
    
      <category term="python基础" scheme="http://waisunny.com/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>python中的作用域</title>
    <link href="http://waisunny.com/2017/12/16/python%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>http://waisunny.com/2017/12/16/python中的作用域/</id>
    <published>2017-12-16T11:03:42.000Z</published>
    <updated>2018-01-28T06:05:44.924Z</updated>
    
    <content type="html"><![CDATA[<p>1、‘块级作用域’</p><p>想想此时运行下面的程序会有输出吗？执行会成功吗？</p><pre><code>if 1 == 1:    name = &quot;_learner&quot;print(name)for i in range(10):    age = iprint(age)</code></pre><p>执行结果：</p><pre><code>_learner9</code></pre><a id="more"></a><p>代码执行成功，没有问题；但在Java/C#中，执行上面的代码会提示name，age没有定义，而在Python中可以执行成功，这是因为在<strong>Python中是没有块级作用域的</strong>，代码块里的变量，外部可以调用，所以可运行成功；　　</p><p>2、局部作用域</p><p>回顾之前学过的知识，我们学函数的时候，函数是个单独的作用域，Python中没有块级作用域，但是有局部作用域；看看下面的代码</p><pre><code>def  func():    name = &quot;lzl&quot;print(name)</code></pre><p>运行这段代码，想想会不会有输出？</p><p>抛出异常：</p><pre><code>NameError: name &apos;name&apos; is not defined</code></pre><p>运行报错，我相信这个大家都能理解，name变量只在func()函数内部中生效，所以在全局中是没法调用的；对上面代码做个简单调整，再看看结果如何?</p><pre><code>def  func():    name = &quot;lzl&quot;func()          #执行函数print(name)</code></pre><p>对之前的代码添加了一句代码，在变量name打印之前，执行了一下函数，此时打印会不会有变化？</p><p>还是抛出异常：<br>    NameError: name ‘name’ is not defined</p><p>执行依然报错，还是回到刚才那句话：即使执行了一下函数，name的作用域也只是在函数内部，外部依然无法进行调用；把前两个知识点记住，接下来要开始放大招了</p><p>3、作用域链(嵌套作用域)</p><p>对函数做下调整，看看下面的代码执行结果如何？</p><pre><code>name = &quot;lzl&quot;def f1():    name = &quot;Eric&quot;    def f2():        name = &quot;Snor&quot;        print(name)    f2()f1()</code></pre><p>学过函数，肯定知道最后f1()执行完会输出Snor；我们先记住一个概念，Python中有作用域链，变量会由内到外找，先去自己作用域去找，自己没有再去上级去找，直到找不到报错为止。</p><p>4、终极版作用域</p><pre><code>name = &quot;lzl&quot;def f1():    print(name)def f2():    name = &quot;eric&quot;    f1()f2()</code></pre><p>想想最后f2()执行结果是打印“lzl”呢，还是打印“eric”？记住自己的答案，现在先不把答案贴出来，先看看下面这段代码：</p><pre><code>name = &quot;lzl&quot;def f1():    print(name)def f2():    name = &quot;eric&quot;    return f1ret = f2()ret()</code></pre><p>执行结果：</p><pre><code>lzl</code></pre><p>执行结果为“lzl”，分析下上面的代码，f2()执行结果为函数f1的内存地址，即ret=f1；执行ret()等同于执行f1()，执行f1()时与f2()没有任何关系，name=“lzl”与f1()在一个作用域链，函数内部没有变量是会向外找，所以此时变量name值为“lzl”；理解了这个，那么刚才没给出答案的那个终极代码的<br>执行结果：</p><pre><code>lzl</code></pre><p>是的，输出的是“lzl”，记住<font color="red">在函数未执行之前，作用域已经形成了，作用域链也生成了。</font></p><p>5、新浪面试题</p><pre><code>&gt;&gt;&gt; li = [lambda :x for x in range(10)]</code></pre><p>判断下li的类型？li里面的元素是什么类型？</p><pre><code>&gt;&gt;&gt; type(li)&lt;class &apos;list&apos;&gt;&gt;&gt;&gt; type(li[0])&lt;class &apos;function&apos;&gt;</code></pre><p>可以看到li为列表类型，list里面的元素为函数，那么打印list里面第一个元素的返回值，此时返回值为多少？</p><pre><code>&gt;&gt;&gt; res = li[0]()&gt;&gt;&gt; res9</code></pre><p>li第一个函数的返回值为9还不是0，记住：<font color="red">函数在没有执行前，内部代码不执行</font>；所以，列表li中每个函数元素的执行结果都是 for x in range(10) 返回的最后一个x的值，即：9。</p><pre><code>&gt;&gt;&gt; for res in li:...     res()...9999999999</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、‘块级作用域’&lt;/p&gt;
&lt;p&gt;想想此时运行下面的程序会有输出吗？执行会成功吗？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if 1 == 1:
    name = &amp;quot;_learner&amp;quot;
print(name)
for i in range(10):
    age = i
print(age)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;_learner
9
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Python" scheme="http://waisunny.com/categories/Python/"/>
    
    
      <category term="python基础" scheme="http://waisunny.com/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>python—函数式编程(匿名函数、高阶函数、偏函数)</title>
    <link href="http://waisunny.com/2017/12/15/python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>http://waisunny.com/2017/12/15/python函数式编程/</id>
    <published>2017-12-15T11:03:42.000Z</published>
    <updated>2018-01-28T06:06:24.986Z</updated>
    
    <content type="html"><![CDATA[<p>函数式编程是使用一系列函数去解决问题，按照一般编程思维，面对问题时我们的思考方式是“怎么干”，而函数函数式编程的思考方式是我要“干什么”。 </p><p>Python 不是也不大可能会成为一种函数式编程语言，但是它支持许多有价值的函数式编程语言构建。<br><a id="more"></a></p><p>#lambda表达式(匿名函数)</p><p>语法：</p><pre><code>lambda [arg1[,arg2,....argN]]: expression</code></pre><p>定义一个计算两个数乘积的函数,并返回结果值：</p><p>普通函数定义方式：</p><pre><code>def funcTake(a,b):    return a*b&gt;&gt;&gt; funcTake(2,3)6</code></pre><p>匿名函数定义方式：</p><pre><code>&gt;&gt;&gt; funcTake=lambda a,b:a*b #定义一个匿名函数并将函数赋值给变量funcTake&gt;&gt;&gt; funcTake(2,4)8</code></pre><p>匿名函数和普通函数一样，可以不带参数，也支持默认参数，可变参数，关键字参数等。</p><pre><code>&gt;&gt;&gt; func=lambda:True  #无参数&gt;&gt;&gt; func&lt;function &lt;lambda&gt; at 0x000001CC2BAEA510&gt;&gt;&gt;&gt; func()True&gt;&gt;&gt; func=lambda a,b=5:a*b #默认参数&gt;&gt;&gt; func(2)10&gt;&gt;&gt; func=lambda a,*args,**kw:[ a* i for i in args if i in kw.values()] #可变参数和关键字参数&gt;&gt;&gt; func(3,2,3,num=2,num2=5)[6]</code></pre><p>#高阶函数</p><ol><li><p>函数名可以作为函数的参数输入的函数是高阶函数。</p></li><li><p>函数名可以作为返回值的函数也是高阶函数。</p></li></ol><p>满足上述任何一点均是高阶函数。</p><pre><code>def funcA(a,b):    return a+bfun=funcA #将函数赋值给变量，其实就是给函数funcA()增加了一个引用。&gt;&gt;&gt; fun(2,3)5def funcB(num1,num2,func):#将函数作为参数传入    return func(num1,num2)&gt;&gt;&gt; funcB(2,3,funcA)5</code></pre><p>下面介绍四个内置的高阶函数。</p><h2 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h2><p>语法：</p><pre><code>filter(func,seq)</code></pre><p>调用一个布尔函数 func 来迭代遍历每个 seq 中的元素； p返回一个使 func 返回值为 ture 的元素构成的filter对象。python2中返回的是一个过滤后的序列。</p><p>用代码的形式阐述filter函数的实现机制：</p><pre><code>def filter(bool_func,seq):    filtered_seq=[]    for item in seq:        if bool_func(item):            filtered_seq.append(item)    return filtered_seq</code></pre><p>下面我们用filter()函数过滤掉1~10以内的所有偶数：</p><pre><code>&gt;&gt;&gt; def odd(num):...     return num%2...&gt;&gt;&gt; result=filter(odd,range(1,11))&gt;&gt;&gt; result&lt;filter object at 0x000001CC2BB1A390&gt;&gt;&gt;&gt; list(result)[1, 3, 5, 7, 9]</code></pre><p>上面的例子可以用lambda表达式一句话搞定：</p><pre><code>&gt;&gt;&gt; result=filter(lambda num :num%2,range(1,11))&gt;&gt;&gt; result&lt;filter object at 0x0000011EE27AF9E8&gt;&gt;&gt;&gt; list(result)[1, 3, 5, 7, 9]</code></pre><h2 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h2><p>语法：</p><pre><code>map(func, seq1[,seq2...])</code></pre><p>将函数 func 作用于给定序列（s)的每个元素，并用一个列表来提供返回值；python2中如果 func 为 None， func 表现为一个身份函数，返回一个含有每个序列中元素集合的 n 个元组的列表。</p><font color="red">python2中返回一个新的列表，<strong>注意是列表不是序列</strong> ，而python3中返回的是一个map对象。</font><p>用代码的形式阐述map函数的实现机制：</p><pre><code>def map(func,seq):    mapped_seq=[]    for item in seq:        mapped_seq.append(func(item))    return mapped_seq</code></pre><p>看个简单的例子：</p><pre><code>&gt;&gt;&gt; result=map((lambda x: x+2), [0, 1, 2, 3, 4, 5])&gt;&gt;&gt; result&lt;map object at 0x0000011EE27DA438&gt;&gt;&gt;&gt; list(result)[2, 3, 4, 5, 6, 7]</code></pre><p>把列表所有数字转为字符串：</p><pre><code>&gt;&gt;&gt; result=map(str,[1,2,3,4,5,6])&gt;&gt;&gt; list(result)[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;]</code></pre><p>map()函数作用于多个序列：</p><pre><code>&gt;&gt;&gt; result=map(lambda x,y:x+y,[1,3,5],[2,4,6])&gt;&gt;&gt; list(result)[3, 7, 11]&gt;&gt;&gt; result=map(lambda x,y:(x+y,x-y),[1,3,5],[2,4,6])&gt;&gt;&gt; list(result)[(3, -1), (7, -1), (11, -1)]</code></pre><p>另外，python2中map()函数支持None参数</p><pre><code>&gt;&gt;&gt; result=map(None,[1,3,5],[2,4,6])  #结果等价于zip()函数&gt;&gt;&gt; result[(1, 2), (3, 4), (5, 6)]</code></pre><p>python3中不在支持None参数：</p><pre><code>&gt;&gt;&gt; result=map(None,[1,3,5],[2,4,6])&gt;&gt;&gt; list(result)Traceback (most recent call last):File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: &apos;NoneType&apos; object is not callable</code></pre><h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h2><p>语法:</p><pre><code>reduce(func, seq[, init])</code></pre><p>它通过取出序列的头两个元素，将他们传入二元函数来获得一个单一的值来实现。然后又用这<br>个值和序列的下一个元素来获得又一个值，然后继续直到整个序列的内容都遍历完毕以及最后的值<br>会被计算出来为止；如果初始值 init 给定，第一个比较会是 init 和第一个序列元素而不是序列的头两个元素。</p><font color="red">在Python 3里,reduce()函数已经被从全局名字空间里移除了，它现在被放置在fucntools模块里 用的话要先引入。</font><p>用代码的形式阐述reduce函数的实现机制：</p><pre><code>def reduce(bin_func,seq,init=None):    Iseq=list(seq)    if init is None:        res=lseq.pop(0) #获取第一个元素并移除。    else:        res=init    for item in Iseq:        res=bin_func(res,item)    return res</code></pre><p>简单的例子，计算1~100的和：</p><pre><code>&gt;&gt;&gt; from functools import reduce&gt;&gt;&gt; result=reduce(lambda x,y:x+y,range(1,101))&gt;&gt;&gt; result5050&gt;&gt;&gt; result=reduce(lambda x,y:x+y,range(1,101),1)&gt;&gt;&gt; result5051</code></pre><h2 id="sorted"><a href="#sorted" class="headerlink" title="sorted()"></a>sorted()</h2><p>sorted()也是一个高阶函数。用sorted()排序的关键在于实现一个映射函数。</p><p>python3中用法如下：</p><p>语法:</p><pre><code>sorted(iterable[, key][, reverse]) </code></pre><p>sorted的第一个参数是一个迭代器，第二个参数是用来排序的key，第三个参数的排序顺序：正序还是倒序。</p><p>第一个参数是迭代器：</p><pre><code>&gt;&gt;&gt; sorted([36, 5, -12, 9, -21])[-21, -12, 5, 9, 36]</code></pre><p>第二个参数是用来排序的key：</p><pre><code>&gt;&gt;&gt; sorted([36, 5, -12, 9, -21], key=abs)[5, 9, -12, -21, 36]</code></pre><p>key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序。</p><p>第三个参数决定正向还是反向排序，要进行反向排序，可以传入第三个参数reverse=True：</p><pre><code>&gt;&gt;&gt; sorted([&apos;bob&apos;, &apos;about&apos;, &apos;Zoo&apos;, &apos;Credit&apos;], key=str.lower, reverse=True)[&apos;Zoo&apos;, &apos;Credit&apos;, &apos;bob&apos;, &apos;about&apos;] #忽略大小写反序排列</code></pre><p>python2中的用法如下：</p><p>语法：</p><pre><code>sorted(iterable[,cmp][, key][, reverse]) #多了一个cmp参数。</code></pre><p>看一个例子:</p><pre><code>def reversed_cmp(x, y):    if x &gt; y:        return -1    if x &lt; y:        return 1    return 0&gt;&gt;&gt; sorted([2,5,6,2,1,3],reversed_cmp) #倒序排[6,5,3,2,2,1]</code></pre><p>其他参数与python3中的用法一致。</p><h1 id="偏函数-currying"><a href="#偏函数-currying" class="headerlink" title="偏函数(currying)"></a>偏函数(currying)</h1><p>Python的functools模块提供了很多有用的功能，其中一个就是偏函数（Partial function）。要注意，这里的偏函数和数学意义上的偏函数不一样。</p><p>在介绍函数参数的时候，我们讲到，通过设定参数的默认值，可以降低函数调用的难度。而偏函数也可以做到这一点。举例如下：</p><p>int()函数可以把字符串转换为整数，当仅传入字符串时，int()函数默认按十进制转换：</p><pre><code>&gt;&gt;&gt; int(&apos;12345&apos;)12345</code></pre><p>但int()函数还提供额外的base参数，默认值为10。如果传入base参数，就可以做N进制的转换：</p><pre><code>&gt;&gt;&gt; int(&apos;12345&apos;, base=8)5349&gt;&gt;&gt; int(&apos;12345&apos;, 16)74565</code></pre><p>假设要转换大量的二进制字符串，每次都传入int(x, base=2)非常麻烦，于是，我们想到，可以定义一个int2()的函数，默认把base=2传进去：</p><pre><code>def int2(x, base=2):    return int(x, base)</code></pre><p>这样，我们转换二进制就非常方便了：</p><pre><code>&gt;&gt;&gt; int2(&apos;1000000&apos;)64&gt;&gt;&gt; int2(&apos;1010101&apos;)85</code></pre><p>functools.partial就是帮助我们创建一个偏函数的，不需要我们自己定义int2()，可以直接使用下面的代码创建一个新的函数int2：</p><pre><code>&gt;&gt;&gt; import functools&gt;&gt;&gt; int2 = functools.partial(int, base=2)&gt;&gt;&gt; int2(&apos;1000000&apos;)64&gt;&gt;&gt; int2(&apos;1010101&apos;)85</code></pre><p>所以，简单总结functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。</p><p>注意到上面的新的int2函数，仅仅是把base参数重新设定默认值为2，但也可以在函数调用时传入其他值：</p><pre><code>&gt;&gt;&gt; int2(&apos;1000000&apos;, base=10)1000000</code></pre><p>最后，创建偏函数时，实际上可以接收函数对象、<em>args和*</em>kw这3个参数，当传入：</p><pre><code>&gt;&gt;&gt; int2 = functools.partial(int, base=2)</code></pre><p>实际上固定了int()函数的关键字参数base，也就是：</p><pre><code>&gt;&gt;&gt; int2(&apos;10010&apos;)18</code></pre><p>相当于：</p><pre><code>&gt;&gt;&gt; kw = { &apos;base&apos;: 2 }&gt;&gt;&gt; int(&apos;10010&apos;, **kw)18</code></pre><p>当传入：</p><pre><code>&gt;&gt;&gt; max2 = functools.partial(max, 10)</code></pre><p>实际上会把10作为*args的一部分自动加到左边，也就是：</p><pre><code>&gt;&gt;&gt; max2(5, 6, 7)10</code></pre><p>相当于：</p><pre><code>&gt;&gt;&gt; args = (10, 5, 6, 7)&gt;&gt;&gt; max(*args)10</code></pre><p>小结</p><p>当函数的参数个数太多，需要简化时，使用functools.partial可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最后我们可以看到，函数式编程有如下好处：</p><ol><li>代码更简单了。</li><li>数据集，操作，返回值都放到了一起。</li><li>你在读代码的时候，没有了循环体，于是就可以少了些临时变量，以及变量倒来倒去逻辑。</li><li>你的代码变成了在描述你要干什么，而不是怎么去干。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;函数式编程是使用一系列函数去解决问题，按照一般编程思维，面对问题时我们的思考方式是“怎么干”，而函数函数式编程的思考方式是我要“干什么”。 &lt;/p&gt;
&lt;p&gt;Python 不是也不大可能会成为一种函数式编程语言，但是它支持许多有价值的函数式编程语言构建。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://waisunny.com/categories/Python/"/>
    
    
      <category term="python基础" scheme="http://waisunny.com/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>python—递归函数</title>
    <link href="http://waisunny.com/2017/12/14/python%E2%80%94%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0/"/>
    <id>http://waisunny.com/2017/12/14/python—递归函数/</id>
    <published>2017-12-14T11:03:42.000Z</published>
    <updated>2018-01-28T06:05:58.919Z</updated>
    
    <content type="html"><![CDATA[<p>在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。</p><p>举个例子，我们来计算阶乘n! = 1 x 2 x 3 x … x n，用函数fact(n)表示，可以看出：</p><pre><code>fact(n) = n! = 1 x 2 x 3 x ... x (n-1) x n = (n-1)! x n = fact(n-1) x n</code></pre><p>所以，fact(n)可以表示为n x fact(n-1)，只有n=1时需要特殊处理。</p><p>于是，fact(n)用递归的方式写出来就是：</p><pre><code>def fact(n):    if n==1:        return 1    return n * fact(n - 1)</code></pre><a id="more"></a><p>上面就是一个递归函数。可以试试：</p><pre><code>&gt;&gt;&gt; fact(1)1&gt;&gt;&gt; fact(5)120&gt;&gt;&gt; fact(100)93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000</code></pre><p>如果我们计算fact(5)，可以根据函数定义看到计算过程如下：</p><pre><code>===&gt; fact(5)===&gt; 5 * fact(4)===&gt; 5 * (4 * fact(3))===&gt; 5 * (4 * (3 * fact(2)))===&gt; 5 * (4 * (3 * (2 * fact(1))))===&gt; 5 * (4 * (3 * (2 * 1)))===&gt; 5 * (4 * (3 * 2))===&gt; 5 * (4 * 6)===&gt; 5 * 24===&gt; 120</code></pre><font color="red">递归函数的优点是定义简单，逻辑清晰，但其效率低。理论上，所有的递归函数都可以用循环代替，循环的逻辑不如递归清晰但比递归高效。</font><font color="red">使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。</font><p>可以试试fact(1000)：</p><pre><code>&gt;&gt;&gt; fact(1000)Traceback (most recent call last):File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;File &quot;&lt;stdin&gt;&quot;, line 4, in fact...File &quot;&lt;stdin&gt;&quot;, line 4, in factRuntimeError: maximum recursion depth exceeded in comparison</code></pre><p>解决递归调用栈溢出的方法是通过尾递归优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。</p><p>尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。</p><p>上面的fact(n)函数由于return n * fact(n - 1)引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，需要多一点代码，主要是要把每一步的乘积传入到递归函数中：</p><pre><code>def fact(n):    return fact_iter(n, 1)def fact_iter(num, product):    if num == 1:        return product    return fact_iter(num - 1, num * product)</code></pre><p>可以看到，return fact_iter(num - 1, num <em> product)仅返回递归函数本身，num - 1和num </em> product在函数调用前就会被计算，不影响函数调用。</p><p>fact(5)对应的fact_iter(5, 1)的调用如下：</p><pre><code>===&gt; fact_iter(5, 1)===&gt; fact_iter(4, 5)===&gt; fact_iter(3, 20)===&gt; fact_iter(2, 60)===&gt; fact_iter(1, 120)===&gt; 120</code></pre><p>尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。</p><p>遗憾的是，大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化，所以，即使把上面的fact(n)函数改成尾递归方式，也会导致栈溢出。</p><p>使用递归和循环实现斐波那契数列：</p><pre><code>#Action1--递归---这种方式效率太低，当num值比较大是执行会很耗时间并且会抛出RecursionError: 超过了最大递归深度def fibonacci1(num):    num = int(num)    if num==0:        res =0    elif num==1:        res =1    else:        res= fibonacci1(num-1)+fibonacci1(num-2)    return res# Action2--迭代，这种方式相比之前效率高很多，是和返回一个计算列表，返回单个值时推荐Action3def fibonacci2(num):    numList = [1, 1]    num = int(num)    for i in range(num - 2):        numList.append(numList[-2] + numList[-1])    return numList#Action3--循环,计算单个值得时候，这种方式最高效def fibonacci3(n):    n=int(n)    x, y = 0, 1    while(n):        x,y,n = y, x+y, n - 1    return x</code></pre><p>运行结果：</p><pre><code>fibonacci1函数运行结果---&gt;832040   运行时间----&gt;0:00:00.923646fibonacci2函数运行结果---&gt;[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040]   运行时间----&gt;0:00:00fibonacci3函数运行结果---&gt;832040   运行时间----&gt;0:00:00</code></pre><p>小结</p><p>使用递归函数的优点是逻辑简单清晰，缺点是过深的调用会导致栈溢出，另外递归效率比较低。</p><p>针对尾递归优化的语言可以通过尾递归防止栈溢出。尾递归事实上和循环是等价的，没有循环语句的编程语言只能通过尾递归实现循环。</p><p>Python标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。&lt;/p&gt;
&lt;p&gt;举个例子，我们来计算阶乘n! = 1 x 2 x 3 x … x n，用函数fact(n)表示，可以看出：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fact(n) = n! = 1 x 2 x 3 x ... x (n-1) x n = (n-1)! x n = fact(n-1) x n
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所以，fact(n)可以表示为n x fact(n-1)，只有n=1时需要特殊处理。&lt;/p&gt;
&lt;p&gt;于是，fact(n)用递归的方式写出来就是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def fact(n):
    if n==1:
        return 1
    return n * fact(n - 1)
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Python" scheme="http://waisunny.com/categories/Python/"/>
    
    
      <category term="python基础" scheme="http://waisunny.com/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>python函数参数总结</title>
    <link href="http://waisunny.com/2017/12/13/python%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E6%80%BB%E7%BB%93/"/>
    <id>http://waisunny.com/2017/12/13/python函数参数总结/</id>
    <published>2017-12-13T11:03:42.000Z</published>
    <updated>2018-01-28T06:06:46.924Z</updated>
    
    <content type="html"><![CDATA[<p>定义函数的时候，我们把参数的名字和位置确定下来，函数的接口定义就完成了。对于函数的调用者来说，只需要知道如何传递正确的参数，以及函数将返回什么样的值就够了，函数内部的复杂逻辑被封装起来，调用者无需了解。</p><p>Python的函数定义非常简单，但灵活度却非常大。除了正常定义的必选参数外，还可以使用默认参数、可变参数和关键字参数，使得函数定义出来的接口，不但能处理复杂的参数，还可以简化调用者的代码。<br><a id="more"></a></p><p>#位置参数<br>我们定义一个计算x*y的函数：</p><pre><code>def power(x,y):    return x*y</code></pre><p>对于power(x)函数，参数x,y就是位置参数。</p><p>调用power函数时，必须传入两个参数x,y：</p><pre><code>&gt;&gt;&gt; power(5,4)20&gt;&gt;&gt; power(15,2)30</code></pre><p>#默认参数</p><p>我们定义一个显示学生信息的函数:</p><pre><code>def showSudentInfo(name,age=20):    print(&apos;{}:{}&apos;.format(name,age))</code></pre><p>调用函数时必须传入name参数而age参数是可选的：</p><pre><code>&gt;&gt;&gt; showSudentInfo(&apos;_learner&apos;)_learner:20&gt;&gt;&gt; showSudentInfo(&apos;jack&apos;,18)jack:18</code></pre><p>说明：大部分学生的年龄都是20岁，所以我们设置age参数的默认值是20，这样就简化了函数的调用，另外，设置默认参数需要注意几点：</p><ol><li><p>必选参数在前，默认参数在后，否则Python的解释器会报错（思考一下为什么默认参数不能放在必选参数前面）；</p></li><li><p>如何设置默认参数。</p><ol><li>当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。</li><li>使用默认参数有什么好处？最大的好处是能降低调用函数的难度。</li></ol></li></ol><font color="red">但是，默认参数使用不当会掉坑里，最大的坑，看下面这个列子：</font><pre><code>def func(li=[]):    li.append(&apos;end&apos;)    return li</code></pre><p>调用函数：</p><pre><code>&gt;&gt;&gt; func([1,2,3])[1, 2, 3, &apos;end&apos;]&gt;&gt;&gt; func()[&apos;end&apos;]&gt;&gt;&gt; func()[&apos;end&apos;, &apos;end&apos;]&gt;&gt;&gt; func()[&apos;end&apos;, &apos;end&apos;,&apos;end&apos;]</code></pre><p>由结果可知，前两次调用一切正常，当连续使用默认参数的形式调用的时候结果不对了，按我们理解的后两次func()调用 输出的结果应该也是[‘end’]，为啥不是呢？</p><p>原因是这样的：python函数在定义的时候，默认参数L的值就被计算出来了，即[]，[]所占用的内存地址也不会变了，除非重新赋值，因为[]是一个可变对象，每次给他li.append(‘end’)添加值，只是改变了其值，其所指向的对象地址没有变。所以多次调用func()操作的是同一个li,所以就出现了上述情况。</p><p>修改一下这个例子,输出id值：</p><pre><code>def func(li=[]):    li.append(&apos;end&apos;)    print(id(li))    return li</code></pre><p>调用函数：</p><pre><code>&gt;&gt;&gt; func([1,2,3])1497991838664[1, 2, 3, &apos;end&apos;]&gt;&gt;&gt; func()1497991837896[&apos;end&apos;]&gt;&gt;&gt; func()1497991837896[&apos;end&apos;, &apos;end&apos;]&gt;&gt;&gt; func()1497991837896[&apos;end&apos;, &apos;end&apos;,&apos;end&apos;]</code></pre><p>能看出，后面三次调用操作的是同一个对象li。</p><font color="red">定义默认参数要牢记一点：默认参数必须指向不变对象！</font><p>上述列子的改进方案：</p><pre><code>def func(li=None):    if not li:        li=[]    li.append(&apos;end&apos;)    return li</code></pre><p>调用函数：</p><pre><code>&gt;&gt;&gt; func([1,2,3])[1, 2, 3, &apos;end&apos;]&gt;&gt;&gt; func()[&apos;end&apos;]&gt;&gt;&gt; func()[&apos;end&apos;, &apos;end&apos;]&gt;&gt;&gt; func()[&apos;end&apos;, &apos;end&apos;,&apos;end&apos;]</code></pre><p>#可变参数</p><p>顾名思义，可变参数就是传入的参数个数是可变的，可以是1个、2个到任意个，还可以是0个。</p><p>定义可变参数在参数前面加了一个*号。在函数内部，参数numbers接收到的是一个tuple。</p><pre><code>def func(*numbers):    sum=0    for num in numbers:        sum=sum+num    return sum</code></pre><p>调用函数：</p><pre><code>&gt;&gt;&gt; func(1,2,3)6&gt;&gt;&gt; tup=(1,3,5,8)&gt;&gt;&gt; func(*tup)17&gt;&gt;&gt; li=[1,3,5,8]&gt;&gt;&gt; func(*li)17</code></pre><p>#关键字参数</p><p>可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。请看示例：</p><pre><code>def person(name, age, **kw):    print(&apos;name:&apos;, name, &apos;age:&apos;, age, &apos;other:&apos;, kw)</code></pre><p>函数person除了必选参数name和age外，还接受关键字参数kw。在调用该函数时，可以只传入必选参数：</p><pre><code>&gt;&gt;&gt; person(&apos;Michael&apos;, 30)name: Michael age: 30 other: {}</code></pre><p>也可以传入任意个数的关键字参数：</p><pre><code>&gt;&gt;&gt; person(&apos;Bob&apos;, 35, city=&apos;Beijing&apos;)name: Bob age: 35 other: {&apos;city&apos;: &apos;Beijing&apos;}&gt;&gt;&gt; person(&apos;Adam&apos;, 45, gender=&apos;M&apos;, job=&apos;Engineer&apos;)name: Adam age: 45 other: {&apos;gender&apos;: &apos;M&apos;, &apos;job&apos;: &apos;Engineer&apos;}</code></pre><p>关键字参数有什么用？它可以扩展函数的功能。比如，在person函数里，我们保证能接收到name和age这两个参数，但是，如果调用者愿意提供更多的参数，我们也能收到。试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。</p><p>和可变参数类似，也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去：</p><pre><code>&gt;&gt;&gt; extra = {&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;}&gt;&gt;&gt; person(&apos;Jack&apos;, 24, **extra)name: Jack age: 24 other: {&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;}</code></pre><font color="red">**extra表示把extra这个dict的所有key-value用关键字参数传入到函数的**kw参数，kw将获得一个dict，注意kw获得的dict是extra的一份拷贝，对kw的改动不会影响到函数外的extra。</font><p>#命名关键字参数</p><p>如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数。这种方式定义的函数如下：</p><pre><code>def person(name, age, *, city, job):    print(name, age, city, job)</code></pre><p>和关键字参数<em>*kw不同，命名关键字参数需要一个特殊分隔符</em>，*后面的参数被视为命名关键字参数。</p><p>调用方式如下：</p><pre><code>&gt;&gt;&gt; person(&apos;Jack&apos;, 24, city=&apos;Beijing&apos;, job=&apos;Engineer&apos;)Jack 24 Beijing Engineer</code></pre><p>如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了：</p><pre><code>def person(name, age, *args, city, job):    print(name, age, args, city, job)</code></pre><p>调用方式如下：</p><pre><code>&gt;&gt;&gt; person(&apos;_learner&apos;, 23, &apos;酷爱Python&apos;,city=&apos;北京&apos;,job=&apos;程序员&apos;)_learner 23 (&apos;酷爱Python&apos;,) 北京 程序员</code></pre><p>命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错：</p><pre><code>&gt;&gt;&gt; person(&apos;Jack&apos;, 24, &apos;Beijing&apos;, &apos;Engineer&apos;)Traceback (most recent call last):File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: person() takes 2 positional arguments but 4 were given</code></pre><p>由于调用时缺少参数名city和job，Python解释器把这4个参数均视为位置参数，但person()函数仅接受2个位置参数。</p><p>命名关键字参数可以有缺省值，从而简化调用：</p><pre><code>def person(name, age, *, city=&apos;Beijing&apos;, job):    print(name, age, city, job)</code></pre><p>由于命名关键字参数city具有默认值，调用时，可不传入city参数：</p><pre><code>&gt;&gt;&gt; person(&apos;Jack&apos;, 24, job=&apos;Engineer&apos;)Jack 24 Beijing Engineer</code></pre><h1 id="参数组合"><a href="#参数组合" class="headerlink" title="参数组合"></a>参数组合</h1><p>在Python中定义函数，可以用必选(位置)参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选(位置)参数、默认参数、可变参数、命名关键字参数和关键字参数。</p><p>比如定义一个函数，包含上述若干种参数：</p><pre><code>def f1(a, b, c=0, *args, **kw):    print(&apos;a =&apos;, a, &apos;b =&apos;, b, &apos;c =&apos;, c, &apos;args =&apos;, args, &apos;kw =&apos;, kw)def f2(a, b, c=0, *, d, **kw):    print(&apos;a =&apos;, a, &apos;b =&apos;, b, &apos;c =&apos;, c, &apos;d =&apos;, d, &apos;kw =&apos;, kw)</code></pre><p>在函数调用的时候，Python解释器自动按照参数位置和参数名把对应的参数传进去。</p><pre><code>&gt;&gt;&gt; f1(1, 2)a = 1 b = 2 c = 0 args = () kw = {}&gt;&gt;&gt; f1(1, 2, c=3)a = 1 b = 2 c = 3 args = () kw = {}&gt;&gt;&gt; f1(1, 2, 3, &apos;a&apos;, &apos;b&apos;)a = 1 b = 2 c = 3 args = (&apos;a&apos;, &apos;b&apos;) kw = {}&gt;&gt;&gt; f1(1, 2, 3, &apos;a&apos;, &apos;b&apos;, x=99)a = 1 b = 2 c = 3 args = (&apos;a&apos;, &apos;b&apos;) kw = {&apos;x&apos;: 99}&gt;&gt;&gt; f2(1, 2, d=99, ext=None)a = 1 b = 2 c = 0 d = 99 kw = {&apos;ext&apos;: None}</code></pre><p>最神奇的是通过一个tuple和dict，你也可以调用上述函数：</p><pre><code>&gt;&gt;&gt; args = (1, 2, 3, 4)&gt;&gt;&gt; kw = {&apos;d&apos;: 99, &apos;x&apos;: &apos;#&apos;}&gt;&gt;&gt; f1(*args, **kw)a = 1 b = 2 c = 3 args = (4,) kw = {&apos;d&apos;: 99, &apos;x&apos;: &apos;#&apos;}&gt;&gt;&gt; args = (1, 2, 3)&gt;&gt;&gt; kw = {&apos;d&apos;: 88, &apos;x&apos;: &apos;#&apos;}&gt;&gt;&gt; f2(*args, **kw)a = 1 b = 2 c = 3 d = 88 kw = {&apos;x&apos;: &apos;#&apos;}</code></pre><font color="red">所以，对于任意函数，都可以通过类似func(<em>args, *</em>kw)的形式调用它，无论它的参数是如何定义的。<br>虽然可以组合多达5种参数，但不要同时使用太多的组合，否则函数接口的可理解性很差。</font>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;定义函数的时候，我们把参数的名字和位置确定下来，函数的接口定义就完成了。对于函数的调用者来说，只需要知道如何传递正确的参数，以及函数将返回什么样的值就够了，函数内部的复杂逻辑被封装起来，调用者无需了解。&lt;/p&gt;
&lt;p&gt;Python的函数定义非常简单，但灵活度却非常大。除了正常定义的必选参数外，还可以使用默认参数、可变参数和关键字参数，使得函数定义出来的接口，不但能处理复杂的参数，还可以简化调用者的代码。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://waisunny.com/categories/Python/"/>
    
    
      <category term="python基础" scheme="http://waisunny.com/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>解决RabbitMq无法接收消息的问题</title>
    <link href="http://waisunny.com/2017/12/03/%E8%A7%A3%E5%86%B3RabbitMq%E6%97%A0%E6%B3%95%E6%8E%A5%E6%94%B6%E6%B6%88%E6%81%AF%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://waisunny.com/2017/12/03/解决RabbitMq无法接收消息的问题/</id>
    <published>2017-12-02T17:18:57.000Z</published>
    <updated>2018-01-04T03:04:24.334Z</updated>
    
    <content type="html"><![CDATA[<p>前两天在产品迭代过程中遇到一个问题，再往RabbitMQ发送消息的时候，消息无法进入到队列里；</p><p>最开始，我以为是服务瞬间消费掉了，消费端出现了啥问题导致被消费的消息没进入到数据库中，但是，我分析消费端代码和异常信息，都没有发现消费端有啥问题；</p><p>于是，我先把RabbitMQ消费端停掉，继续发送消息，发现消息压根就没进入到队列里，刨除掉了消费端的问题；然后接着分析发送端代码，感觉一切也ok呀，没有啥问题；刨除掉自己代码的问题，那只有一种可能会不会是RabbitMQ服务出问题了，不接受消息了…<br><a id="more"></a></p><p>然后，查看RabbitMQ服务器内存、CPU、磁盘后发现，内存、CPU指标正常，磁盘的剩余空间只剩下500M左右，通过RabbitMQ网站发现另一个队列堆积了大量的消息并且没有消费端，找到了相应的负责人后，把消息处理掉，瞬间就好使了。附上一张图：<br><img src="https://i.imgur.com/CKuo2o2.png" alt=""><br>当途中圈出来的变成<font color="red">红色</font>的时候说明你的磁盘空间不够用了，估计就是消息堆积导致的.</p><p>另外：正常情况在生产环境下都会设置报警机制，RabbitMQ服务端默认配置是当内存使用达到40%，磁盘空闲空间小于50M，即启动内存报警，磁盘报警；由于我上述问题是在测试环境下遇到的，测试环境没有设置报警机制。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前两天在产品迭代过程中遇到一个问题，再往RabbitMQ发送消息的时候，消息无法进入到队列里；&lt;/p&gt;
&lt;p&gt;最开始，我以为是服务瞬间消费掉了，消费端出现了啥问题导致被消费的消息没进入到数据库中，但是，我分析消费端代码和异常信息，都没有发现消费端有啥问题；&lt;/p&gt;
&lt;p&gt;于是，我先把RabbitMQ消费端停掉，继续发送消息，发现消息压根就没进入到队列里，刨除掉了消费端的问题；然后接着分析发送端代码，感觉一切也ok呀，没有啥问题；刨除掉自己代码的问题，那只有一种可能会不会是RabbitMQ服务出问题了，不接受消息了…&lt;br&gt;
    
    </summary>
    
      <category term="消息队列" scheme="http://waisunny.com/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
      <category term="RabbitMQ" scheme="http://waisunny.com/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>python黑魔法—迭代器与生成器</title>
    <link href="http://waisunny.com/2017/11/29/python%E9%BB%91%E9%AD%94%E6%B3%95%E2%80%94%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <id>http://waisunny.com/2017/11/29/python黑魔法—迭代器与生成器/</id>
    <published>2017-11-28T17:44:06.000Z</published>
    <updated>2018-01-21T23:50:30.299Z</updated>
    
    <content type="html"><![CDATA[<p>在了解Python的数据结构时，容器(container)、可迭代对象(iterable)、迭代器(iterator)、生成器(generator)、列表/集合/字典推导式(list,set,dict comprehension)众多概念参杂在一起，难免让初学者一头雾水，我将用一篇文章试图将这些概念以及它们之间的关系捋清楚。<br><img src="https://i.imgur.com/RLHjcHO.png" alt=""></p><a id="more"></a><h1 id="容器-container"><a href="#容器-container" class="headerlink" title="容器(container)"></a>容器(container)</h1><p>容器是一种把多个元素组织在一起的数据结构，容器中的元素可以逐个地迭代获取，可以用in, not in关键字判断元素是否包含在容器中。通常这类数据结构把所有的元素存储在内存中（也有一些特例，并不是所有的元素都放在内存，比如迭代器和生成器对象）在Python中，常见的容器对象有：</p><p>list, deque, ….</p><p>set, frozensets, ….</p><p>dict, defaultdict, OrderedDict, Counter, ….</p><p>tuple, namedtuple, …</p><p>str</p><p>容器比较容易理解，因为你就可以把它看作是一个盒子、一栋房子、一个柜子，里面可以塞任何东西。从技术角度来说，当它可以用来询问某个元素是否包含在其中时，那么这个对象就可以认为是一个容器，比如 序列，set，dic都是容器对象：</p><pre><code>&gt;&gt;&gt; assert 1 in [1,2,3] #list&gt;&gt;&gt; assert 4 not in [1,2,3]&gt;&gt;&gt; assert 1 in {1,2,3} #set&gt;&gt;&gt; assert 1 in (1,2,3) #tuple&gt;&gt;&gt; assert &apos;a&apos; in &apos;a,b,c&apos; #str&gt;&gt;&gt; assert &apos;key1&apos; in {&apos;key1&apos;:2,&apos;key2&apos;:5} # dic</code></pre><p>尽管绝大多数容器都提供了某种方式来获取其中的每一个元素，但这并不是容器本身提供的能力，而是 可迭代对象 赋予了容器这种能力，当然并不是所有的容器都是可迭代的，比如（<a href="http://blog.csdn.net/wh_springer/article/details/52193110" target="_blank" rel="external">Bloom filter</a>）。</p><h1 id="可迭代对象（Iterable）"><a href="#可迭代对象（Iterable）" class="headerlink" title="可迭代对象（Iterable）"></a>可迭代对象（Iterable）</h1><p>刚才说过，很多容器都是可迭代对象，此外还有更多的对象同样也是可迭代对象，比如处于打开状态的files，sockets等等。但凡是可以返回一个 迭代器 的对象都可称之为可迭代对象。听起来可能有点困惑，没关系，可迭代对象与迭代器有一个非常重要的区别。先看一个例子：</p><pre><code>&gt;&gt;&gt; x=[1,2,3]&gt;&gt;&gt; y=iter(x)&gt;&gt;&gt; next(y)1&gt;&gt;&gt; type(x)&lt;class &apos;list&apos;&gt;&gt;&gt;&gt; type(y)&lt;class &apos;list_iterator&apos;&gt;</code></pre><p>x 是一个可迭代对象，可迭代对象和容器一样是一种通俗的叫法，并不是指某种具体的数据类型，list是可迭代对象，dict是可迭代对象，set也是可迭代对象。 y 是一个独立的迭代器，迭代器内部持有一个状态，该状态用于记录当前迭代所在的位置，以方便下次迭代的时候获取正确的元素。迭代器是一种具体的迭代器类型，比如 list_iterator ， set_iterator 。<strong>可迭代对象实现了__iter__方法，该方法返回一个迭代器对象。</strong></p><p>判断一个对象是否是可迭代对象：</p><pre><code>&gt;&gt;&gt; from collections import Iterable &gt;&gt;&gt; isinstance(&apos;abc&apos;, Iterable)     True&gt;&gt;&gt; isinstance(1, Iterable)     False&gt;&gt;&gt; isinstance([], Iterable)True</code></pre><p>可迭代对象一般都用for循环遍历元素，也就是能用for循环的对象都可称为可迭代对象：</p><pre><code>&gt;&gt;&gt; for i in [1,2,3]:...     pass...</code></pre><p>执行上述代码时实际的调用过程如下：<br><img src="https://i.imgur.com/HbRZYL4.png" alt=""></p><p>第一步：调用iter()方法将可迭代对象转换成迭代器</p><p>第二步：调用next()方法获取元素值。</p><p>第三步：处理StopIteration异常。（下面会讲到）</p><p>So,我们可以将上述代码理解成：</p><pre><code>list_iter=iter([1, 2, 3])while True:    try:        next(list_iter)    except StopIteration:        break</code></pre><h1 id="迭代器（Iterator）"><a href="#迭代器（Iterator）" class="headerlink" title="迭代器（Iterator）"></a>迭代器（Iterator）</h1><p>那么什么迭代器呢？它是一个带状态的对象，它能在你调用next()方法的时候返回容器中的下一个值，任何实现了__iter__和__next__()（python2中实现next()）方法的对象都是迭代器，__iter__返回迭代器自身，__next__返回容器中的下一个值，如果容器中没有更多元素了，则抛出<strong>StopIteration</strong>异常，至于它们到底是如何实现的这并不重要。</p><p>所以，迭代器就是实现了工厂模式的对象，它在你每次询问要下一个值的时候给你返回。有很多关于迭代器的例子，比如itertools函数返回的都是迭代器对象。</p><p>生成一个无线序列：</p><pre><code>&gt;&gt;&gt; from itertools import count&gt;&gt;&gt; counter = count(start=13)&gt;&gt;&gt; next(counter)13&gt;&gt;&gt; next(counter)14</code></pre><p>以斐波那契数列()为例，学习为何创建以及如何创建一个迭代器：</p><p>著名的斐波拉契数列（Fibonacci），除第一个和第二个数外，任意一个数都可由前两个数相加得到：</p><p>1, 1, 2, 3, 5, 8, 13, 21, 34, …</p><p>版本一：</p><pre><code>def fab(max):     n, a, b = 0, 0, 1     while n &lt; max:         print(b)         a, b = b, a + b         n = n + 1fab(5)</code></pre><p>结果：</p><pre><code>1, 1, 2, 3, 5</code></pre><p>直接在函数fab(max)中用print打印会导致函数的可复用性变差，因为fab返回None。其他函数无法获得fab函数返回的数列。</p><p>版本二：</p><pre><code>def fab(max):    L = [1,1]    n=2    while n &lt; max:        L.append(L[-1]+L[-2])        n = n + 1    return Lprint(fab(5))</code></pre><p>结果：</p><pre><code>[1, 1, 2, 3, 5]</code></pre><p>版本二满足了可复用性的需求，但是占用了内存空间，最好不要。</p><p>对比python2中 </p><pre><code>for i in range(1000):     pass</code></pre><p>和</p><pre><code>for i in xrange(1000):     pass，</code></pre><p>前一个返回1000个元素的列表，而后一个在每次迭代中返回一个元素，因此可以使用迭代器来解决占空间的问题。</p><p>版本三：自定义迭代器实现斐波那契数列</p><pre><code>class Fab:    def __init__(self,max):        self.max=max        self.n,self.a,self.b=0,0,1    def __iter__(self):        return self    def __next__(self):        if self.n&lt;self.max:            r=self.b            self.a,self.b=self.b,self.a+self.b            self.n+=1            return r        raise StopIterationfab=Fab(5)for i in fab:    print(i)</code></pre><p>结果：</p><pre><code>1, 1, 2, 3, 5</code></pre><p>使用内建函数调用上面的迭代器：</p><pre><code>fab=Fab(5)l=list(fab)print(type(l))for i in fab:    print(i)</code></pre><p>上面代码的输出结果只有：</p><pre><code>&lt;class &apos;list&apos;&gt;</code></pre><p>为什么 for循环没有输出结果呢？原因是因为在对迭代器调用list、tuple等内建函数时会调用next()方法将当前迭代器对象的值全部算出来，迭代器已经计算完了，所以后面的for循环没有值输出。</p><p>Fab既是一个可迭代对象（因为它实现了 __iter__ 方法），又是一个迭代器（因为实现了 __next__ 方法）。实例变量 self.a 和 self.b 用于维护迭代器内部的状态。每次调用 next() 方法的时候做两件事：</p><ol><li><p>为下一次调用 next() 方法修改状态</p></li><li><p>为当前这次调用生成返回结果</p></li></ol><p>迭代器就像一个懒加载的工厂，等到有人需要的时候才给它生成值返回，没调用的时候就处于休眠状态等待下一次调用。</p><h1 id="生成器（generator）"><a href="#生成器（generator）" class="headerlink" title="生成器（generator）"></a>生成器（generator）</h1><p>生成器算得上是Python语言中最吸引人的特性之一，<strong>生成器其实是一种特殊的迭代器</strong>，不过这种迭代器更加优雅。上述版本3的代码远没有版本一的代码简洁，生成器（yield）既可以保持版本一的简洁性，又可以保持版本三的效果。它不需要再像上面的类一样写 __iter__() 和 __next__() 方法了，只需要一个 yiled 关键字。 生成器有如下特征使它一定是迭代器（反之不成立），因此生成器也是以一种懒加载的模式生成值。用生成器来实现斐波那契数列的例子是：</p><pre><code>def fab(max):    n,a,b=0,0,1    while n&lt;max:        yield b        n+=1        a,b=b,a+bf=fab(5)for i in f:    print(i)</code></pre><p>结果：</p><pre><code>1,1,2,3,5</code></pre><p>fab 就是一个普通的python函数，它特别的地方在于函数体中没有 return 关键字，函数的返回值是一个生成器对象。<strong>当执行 f=fab(5) 返回的是一个生成器对象，此时函数体中的代码并不会执行，只有显示或隐示地调用next的时候才会真正执行里面的代码。</strong></p><p>yield 的作用就是把一个函数变成一个 generator，带有 yield 的函数不再是一个普通函数，可以称作生成器函数；Python 解释器会将其视为一个 generator，在 for 循环执行时，每次循环都会执行 fab 函数内部的代码，执行到 yield b 时，fab 函数就返回一个迭代值，下次迭代时，代码从 yield b 的下一条语句继续执行，而函数的本地变量看起来和上次中断执行前是完全一样的，于是函数继续执行，直到再次遇到 yield。看起来就好像一个函数在正常执行的过程中被 yield 中断了数次，每次中断都会通过 yield 返回当前的迭代值。</p><p>也可以手动调用 fab(5) 的 next() 方法（因为 fab(5) 是一个 generator 对象，该对象具有 next() 方法），这样我们就可以更清楚地看到 fab 的执行流程：</p><pre><code>&gt;&gt;&gt; f = fab(3)&gt;&gt;&gt; f.__next__()1&gt;&gt;&gt; f.__next__()1&gt;&gt;&gt; f.__next__()2&gt;&gt;&gt; f.__next__()Traceback (most recent call last):  File &quot;&lt;pyshell#62&gt;&quot;, line 1, in &lt;module&gt;    f.next()StopIteration</code></pre><h2 id="生成器中的return"><a href="#生成器中的return" class="headerlink" title="生成器中的return"></a>生成器中的return</h2><p>在一个生成器中，如果没有return，则默认执行到函数完毕；如果遇到return,如果在执行过程中 return，则直接抛出 StopIteration 终止迭代。</p><pre><code>def fab():    print(&apos;yield 1&apos;)    yield 1    return    print(&apos;yield 2&apos;)    yield 2for i in fab():    print(i)</code></pre><p>结果：</p><pre><code>yield 11</code></pre><p>上述代码 for循环帮我们处理了StopIteration异常，要是自己调用两次next()方法就会抛出异常的。</p><h2 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h2><p>生成器表达式与列表解析表达式很相似，区别就是将‘[]’换成‘()’。</p><p>定义一个生成器表达式：</p><pre><code>&gt;&gt;&gt; result = (x for x in range(5))&gt;&gt;&gt; result&lt;generator object &lt;genexpr&gt; at 0x0000022F66D2F4C0&gt;&gt;&gt;&gt; type(result)&lt;class &apos;generator&apos;&gt;&gt;&gt;&gt; next(result)0&gt;&gt;&gt; for i in result:...     print(i)...1234</code></pre><p>定义一个列表解析表达式：</p><pre><code>&gt;&gt;&gt; result = [ x for x in range(5)]&gt;&gt;&gt; type(result)&lt;type &apos;list&apos;&gt;&gt;&gt;&gt; result[0, 1, 2, 3, 4]</code></pre><h2 id="生成器的send-方法"><a href="#生成器的send-方法" class="headerlink" title="生成器的send()方法"></a>生成器的send()方法</h2><p>send()方法和next()方法基本一样（send(None)等价于next()），都能启动生成器并获取yield 的返回值，它比next()方法多一个功能，可以给生成器传递值；需要注意的是，第一次启动生成器时，请使用next()语句或是send(None)，不能使用send发送一个非None的值，否则会出错的，因为没有 yield语句来接收这个值。</p><pre><code>def gen():    print(&apos;1111&apos;)    name=yield 1    print(name)    yield 2g=gen()#g.send(1) #TypeError: can&apos;t send non-None value to a just-started generatorprint(g.send(None))print(g.send(&apos;_learner&apos;))</code></pre><p>结果：</p><pre><code>11111_learner2</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>凡是可作用于for循环的对象都是可迭代对象(Iterable)类型。</p><p>凡是可作用于next()函数的对象都是迭代器(Iterator)类型，生成器是一个特殊的迭代器，它表示一个惰性计算的序列。</p><p>序列、字典等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。</p><p>Python的for循环本质上就是通过不断调用next()函数实现的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在了解Python的数据结构时，容器(container)、可迭代对象(iterable)、迭代器(iterator)、生成器(generator)、列表/集合/字典推导式(list,set,dict comprehension)众多概念参杂在一起，难免让初学者一头雾水，我将用一篇文章试图将这些概念以及它们之间的关系捋清楚。&lt;br&gt;&lt;img src=&quot;https://i.imgur.com/RLHjcHO.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://waisunny.com/categories/Python/"/>
    
    
      <category term="python基础" scheme="http://waisunny.com/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
