<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WaiBlog|码农的技术小窝</title>
  
  <subtitle>所有的努力都值得期许，每一份梦想都应该灌溉！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://waisunny.com/"/>
  <updated>2017-11-26T04:23:18.459Z</updated>
  <id>http://waisunny.com/</id>
  
  <author>
    <name>_learner</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python之文件操作</title>
    <link href="http://waisunny.com/2017/11/22/python%E4%B9%8B%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <id>http://waisunny.com/2017/11/22/python之文件操作/</id>
    <published>2017-11-22T15:35:28.000Z</published>
    <updated>2017-11-26T04:23:18.459Z</updated>
    
    <content type="html"><![CDATA[<p>  首先，学习python，掌握文件操作这一技能是必不可少的，本篇博文由浅入深，详细介绍python中操作文件的各种方法、各种方法之间的对比以及如何高效的读取文件等；Python中文件操作的三个步骤：</p><ol><li>打开文件</li><li>操作文件</li><li>关闭文件</li></ol><h1 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h1><p>Python中file()与open()两个都能够打开文件，对文件进行操作，也具有相似的用法和参数，并且返回的都是一个文件对象；但是，这两种文件打开方式有本质的区别，file是一个类，用file()来打开文件，相当于这是在构造文件类，而用open()打开文件，是用python的内建函数来操作，这是不一样的，另外python3已经不再支持file()了；So，<font color="#FF0000" size="5"><strong>强烈建议使用open()函数</strong></font>。</p><h2 id="open"><a href="#open" class="headerlink" title="open()"></a>open()</h2><pre><code>open(file[, mode[, buffering[, encoding[, errors[, newline[, closefd=True]]]]]])</code></pre><p>open函数有很多的参数，常用的是file，mode和encoding</p><ol><li>file：文件路径包含文件名，需要加引号</li><li>mode：文件打开模式，见下面3</li><li>encoding：表示的是返回的数据采用何种编码，一般采用utf8或者gbk；</li><li>buffering(可选):控制着文件的缓冲，<ol><li>如果参数是0(或者是False)，I/O(输人/输出)就是无缓冲的(所有的读写操作都直接针对硬盘);</li><li>如果是1(或者是true), I/O就是有缓冲的(意味着Python使用内存来代替硬盘，让程序更快，只有使用flush或者close时才会更新硬盘上的数据;如果是大于1的数字代表缓冲区的大小(单位是字节)；</li><li>如果是-1(或者是任何负数)代表使用默认的缓冲区大小。</li><li>使用默认时，会采用下面策略来选择：<ol><li>对于二进制文件模式时，采用固定块内存缓冲区方式，内存块的大小根据系统设备的分配的磁盘块来决定，如果获取系统磁盘块的大小失败，就使用内部常量io.DEFAULT_BUFFER_SIZE定义的大小。一般的操作系统上，块的大小是4096或者8192字节大小。</li><li>对于交互的文本文件（采用isatty()判断为True）时，采用一行缓冲区的方式。其它文本文件使用跟二进制一样的方式。</li></ol></li></ol></li></ol><h2 id="文件模式"><a href="#文件模式" class="headerlink" title="文件模式"></a>文件模式</h2><ol><li>‘r’：读模式</li><li>‘w’：写模式，会先清空文件内容</li><li>‘a’：追加模式</li><li>‘b’：二进制模式（可添加到其他模式中使用，如：’rb’：表示读取二进制文件）</li><li>‘+’：读/写模式（可添加到其他模式中使用）</li><li>‘a+’：可读写模式，写只能写在文件末尾</li><li>‘w+’：可读写，与’a+’的区别是要清空文件内容(<font color="#FF0000" size="3"><strong>不推荐使用</strong></font>)</li><li>‘r+’：可读写，与’a+’的区别是可以写到文件任何位置</li></ol><h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><pre><code>&gt;&gt;&gt; f=open(&apos;file.txt&apos;,&apos;r&apos;,encoding=&apos;utf-8&apos;)#以只读的模式打开一个文件，对读取的文件内容是utf-8编码。&gt;&gt;&gt; f=open(&apos;file.txt&apos;,&apos;r+&apos;,encoding=&apos;utf-8&apos;)#以读写的模式打开一个文件，对读取的文件内容是utf-8编码。&gt;&gt;&gt; f=open(&apos;file.txt&apos;,&apos;a&apos;,encoding=&apos;utf-8&apos;)#以追加的模式打开一个文件，对读取的文件内容是utf-8编码。</code></pre><h1 id="操作文件的方法"><a href="#操作文件的方法" class="headerlink" title="操作文件的方法"></a>操作文件的方法</h1><p>示例文件内容：</p><p><img src="https://i.imgur.com/RMzpzSy.png" alt=""></p><h2 id="读-read-reabline-readlines"><a href="#读-read-reabline-readlines" class="headerlink" title="读 read(),reabline(),readlines()"></a>读 read(),reabline(),readlines()</h2><pre><code>&gt;&gt;&gt; f=open(&apos;file.txt&apos;,&apos;r&apos;,encoding=&apos;gbk&apos;)&gt;&gt;&gt; f.read()#读取全部内容,返回一个字符串python 文件操作python 字符串语法python 列表元祖字典python 中的变量&gt;&gt;&gt; f.read(5)#读取指定长度的字符&gt;&gt;&gt; f.readline()#读取一行内容，返回一个 字符串&gt;&gt;&gt; f.readlines()#读取全部行，返回一个列表&gt;&gt;&gt; f.close()</code></pre><p>说明：上述代码第一个读取操作读取出了所有内容，剩下的读取到的都是空，原因是因为每执行一次读操作，都会记录下当前文件读取指针的位置，接下来的读操作是在上一次的读操作读取到的内容之后继续开始读取的。可以通过下面介绍的tell()方法获取当前指针所在位置，通过seek()方法设置指针位置。</p><h2 id="写-write-writelines"><a href="#写-write-writelines" class="headerlink" title="写 write(),writelines()"></a>写 write(),writelines()</h2><pre><code>&gt;&gt;&gt; f=open(&apos;file.txt&apos;,&apos;w&apos;,encoding=&apos;gbk&apos;)&gt;&gt;&gt; f.write(&apos;python人生&apos;)#接受字符串 作为参数&gt;&gt;&gt; f.writelines([&apos;python生活&apos;,&apos;python前世&apos;])#接受序列(字符串，列表，元祖)作为参数&gt;&gt;&gt; f.close()python人生python生活python前世</code></pre><p>说明：当以只写的模式打开文件的时候会先清空文件内容,另外多个连续写的操作也会有读操作时说到的光标注意事项；另外需要值得一提的时，写操作并不是直接把内容写到磁盘上，而是写到了缓冲区中即内存里。当调用f.close()方法时会把缓冲区的内容写入到磁盘</p><h2 id="关闭文件close"><a href="#关闭文件close" class="headerlink" title="关闭文件close()"></a>关闭文件close()</h2><p>close()方法时用来关闭文件的，这是一种很重要但是容易被忘记的操作，虽然说即使我们不直接调用close()方法，python解释器 也会在程序执行完是帮我们关闭文件，但是依赖于解释器来关闭文件的行为是不安全的，所以，一定要在操作完文件后调用close()方法来关闭文件；为了避免忘记关闭文件，推荐一种打开文件的方式：</p><pre><code>with open(&apos;log&apos;, &apos;r&apos;) as f:     f.readline()     f.read()print(&apos;hello&apos;)#同时操作多个文件with open(&apos;log1&apos;,&apos;r&apos;) as f_read, open(&apos;log2&apos;,&apos;w&apos;) as f_write:    for line in f_read:        f_write.write(line)</code></pre><p>说明：使用with语句操作文件会在with语句块执行完后自动调用close()方法关闭文件，推荐这种写法。</p><h2 id="tell-seek"><a href="#tell-seek" class="headerlink" title="tell(),seek()"></a>tell(),seek()</h2><h3 id="tell"><a href="#tell" class="headerlink" title="tell()"></a>tell()</h3><ol><li>作用：获取当前文件读取指针的位置</li><li>语法格式： file.tell() 注： 此方法没有参数</li></ol><h3 id="seek"><a href="#seek" class="headerlink" title="seek()"></a>seek()</h3><ol><li>作用：用于移动文件读写指针到指定的位置</li><li><p>语法格式：file.seek(offset, whence=0):</p><ol><li>offset: 偏移量，需要向前或者是向后移动的字节数</li><li><p>whence: 可选值，默认为0, 可选值为1或者2，表示从何处开始计算偏移，具体来说，0表示从当前位置开始计算偏移，1表示从文件头位置开始计算偏移，2表示从文件尾开始计算偏移。</p><h3 id="代码演示-1"><a href="#代码演示-1" class="headerlink" title="代码演示"></a>代码演示</h3><blockquote><blockquote><blockquote><p>x = file(‘file.txt’, ‘r’)<br>x.tell()           #获得当前文件读取指针<br>0L                     #当前文件指针在文件头处<br>x.seek(3)          #将文件指针向前移动3个字节<br>x.tell()<br>3L                     #指针已经移动到了第3个字节处<br>x.seek(5,1)        #表示从文件头处开始移动指针，向前移动5个字节<br>x.tell()<br>5L                     #当前文件读取指针已经移动到第5个字节处<br>x.seek(0,0)        #表示将文件指针移动到文件头处<br>x.tell()<br>0L<br>x.seek(0,2)        #表示将文件读取指针移动到文件尾部<br>x.tell()<br>214L                   #可以得到文件大小为214B<br>x.seek(-2,2)       #表示从文件尾部开始移动指针，向后移动2个字节<br>x.tell()<br>212L </p></blockquote></blockquote></blockquote></li></ol></li></ol><h1 id="高效迭代文件内容"><a href="#高效迭代文件内容" class="headerlink" title="高效迭代文件内容"></a>高效迭代文件内容</h1><p>方式一：</p><pre><code>with open(&apos;file.txt&apos;,&apos;r&apos;,encoding=&apos;gbk&apos;) as file:    for line in file.readlines():        do_things(line)</code></pre><p>方式二：</p><pre><code>with open(&apos;file.txt&apos;,&apos;r&apos;,encoding=&apos;gbk&apos;)as file:line=file.readline()while line:    line=file.readline()    print(line)</code></pre><p>方式三：</p><pre><code>with open(&apos;file.txt&apos;,&apos;r&apos;,encoding=&apos;gbk&apos;) as file:    for line in file:        do_things(line)</code></pre><p>说明：</p><p>第一种方式会一次性将文件中的内容加载到内存中然后对内存进行读操作。</p><p>第二种方式从磁盘上读取一条输出一条，不会将文件内容一次性加载到内存。</p><p>第三种方式直接迭代文件对象,for循环会把它当做一个迭代器，读取一行输出一行。</p><p>三种方式执行效率对比（<font color="#FF0000" size="5">本人测试数据，会有偏差</font>）：</p><ol><li>测试文件：1G的大文本文件；多次运行三种方式：第一种内存明显增加，执行时间在1分钟10秒左右；第二种内存没有增加，运行时间在1分钟15秒左右；第三种内存没有增加，运行时间在1分钟左右；</li><li>测试文件：15MB小文本文件;多次运行三种方式：第一种内存明显增加，执行时间在1.2秒左右；第二种内存没有增加，运行时间在1.6秒左右；第三种内存没有增加，运行时间在1.2秒左右；</li></ol><p>由此可知：小文本操作时，第二种方式执行相对较慢，不推荐使用，大文本操作时第一种方式会占用很大内存；另外无论是大文本操作还是小文本操作，第三种方式都是最节省内存执行时间最快的；So，极力推荐使用第三种方式</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上述介绍了基本的文件操作方式和一些注意事项，最后详细介绍了迭代文件内容最高效的方式，希望各位读者可以自己亲自动手尝试一些，这样会让你有更深层次的理解.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  首先，学习python，掌握文件操作这一技能是必不可少的，本篇博文由浅入深，详细介绍python中操作文件的各种方法、各种方法之间的对比以及如何高效的读取文件等；Python中文件操作的三个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;打开文件&lt;/li&gt;
&lt;li&gt;操作文件&lt;/li&gt;
      
    
    </summary>
    
    
      <category term="python基础" scheme="http://waisunny.com/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>python中的编码问题</title>
    <link href="http://waisunny.com/2017/11/21/python%E4%B8%AD%E7%9A%84%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/"/>
    <id>http://waisunny.com/2017/11/21/python中的编码问题/</id>
    <published>2017-11-21T09:22:29.000Z</published>
    <updated>2017-11-26T03:52:42.483Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>初学python让人头疼的莫过于python中的字符编码问题，尤其是在python2中，默认输出的字符是<strong>Ascii</strong>,是不支持中文的，所以要使用中文必须在每个文件的开头写上：‘# coding:utf-8’,这样才能输出中文否则会报一个下面这样的错误：</p><pre><code>SyntaxError: Non-ASCII character &apos;\xe6&apos; in file new1.txt on line 2, but no encoding declared; see http:/www.python.org/peps/pep-0263.html for details</code></pre><p>到了python3中字符的默认输出是‘utf-8’格式的编码，这样就支持中文了；那为什么会存在这么多恶心的编码问题呢，这还得从编码的历史说起。</p><h1 id="编码由来"><a href="#编码由来" class="headerlink" title="编码由来"></a>编码由来</h1><p>大家都知道，计算机是美国人发明的，因此，最早只有127个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码。</p><p>显然，ASCII编码是不支持中文的，为了处理中文，中国人自己 制定了GB2312编码，用来把中文编进去，这样就支持中文展示了。</p><p>你可以想得到的是，全世界有上百种语言，日本把日文编到Shift_JIS里，韩国把韩文编到Euc-kr里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。</p><p>因此，万国码<strong>Unicode</strong>应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。</p><p>Unicode标准也在不断发展，但最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。</p><p>现在，捋一捋ASCII编码和Unicode编码的区别：ASCII编码是1个字节，而Unicode编码通常是2个字节。</p><p>新的问题又出现了：如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。</p><p>所以，本着节约的精神，又出现了把Unicode编码转化为<strong>“可变长编码”的UTF-8编码</strong>。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间：</p><pre><code>字符        ASCII                  Unicode                       UTF-8A          01000001           00000000 01000001                01000001中           x               01001110 00101101           11100100 10111000 10101101</code></pre><p>从上面的表格还可以发现，UTF-8编码有一个额外的好处，就是ASCII编码实际上可以被看成是UTF-8编码的一部分，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。</p><h1 id="计算机系统通用的字符编码工作方式"><a href="#计算机系统通用的字符编码工作方式" class="headerlink" title="计算机系统通用的字符编码工作方式"></a>计算机系统通用的字符编码工作方式</h1><p>搞清楚了ASCII、Unicode和UTF-8的关系，我们就可以总结一下现在计算机系统通用的字符编码工作方式：</p><p>在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。</p><p>用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件。</p><p>浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器：所以你看到很多网页的源码上会有类似<meta charset="UTF-8">的信息，表示该网页正是用的UTF-8编码。</p><h1 id="python中如何处理编码"><a href="#python中如何处理编码" class="headerlink" title="python中如何处理编码"></a>python中如何处理编码</h1><p>字符串在Python内部的表示是unicode编码，因此，在做编码转换时，通常需要以unicode作为中间编码，即先将其他编码的字符串解码（decode）成unicode，再从unicode编码（encode）成另一种编码。 </p><h2 id="decode"><a href="#decode" class="headerlink" title="decode"></a>decode</h2><p>decode的作用是将其他编码的字符串转换成unicode编码，如：</p><pre><code>str1.decode(‘gb2312‘)#表示将gb2312编码的字符串str1转换成unicode编码。 </code></pre><h2 id="encode"><a href="#encode" class="headerlink" title="encode"></a>encode</h2><p>encode的作用是将unicode编码转换成其他编码的字符串，如：</p><pre><code>str2.encode(‘gb2312‘)#表示将unicode编码的字符串str2转换成gb2312编码。 </code></pre><p>因此，转码的时候一定要先搞明白，字符串str是什么编码，然后decode成unicode，然后再encode成其他编码</p><h2 id="代码中字符串的默认编码与代码文件本身的编码一致"><a href="#代码中字符串的默认编码与代码文件本身的编码一致" class="headerlink" title="代码中字符串的默认编码与代码文件本身的编码一致"></a>代码中字符串的默认编码与代码文件本身的编码一致</h2><p>如：s=‘中文‘</p><p>如果是在utf8的文件中，该字符串就是utf8编码，如果是在gb2312的文件中，则其编码为gb2312。这种情况下，要进行编码转换，都需要先用decode方法将其转换成unicode编码，再使用encode方法将其转换成其他编码。</p><p>如果字符串是这样定义：s=u‘中文‘ </p><p>则该字符串的编码就被指定为unicode了，即python的内部编码，而与代码文件本身的编码无关。因此，对于这种情况做编码转换，只需要直接使用encode方法将其转换成指定编码即可。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>如果一个字符串已经是unicode了，再进行解码则将出错，因此通常要对其编码方式是否为unicode进行判断：</p><pre><code>isinstance(s, unicode)  #用来判断是否为unicode</code></pre><p>用非unicode编码形式的str来encode会报错。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;初学python让人头疼的莫过于python中的字符编码问题，尤其是在python2中，默认输出的字符是&lt;strong&gt;Ascii&lt;/str
      
    
    </summary>
    
    
      <category term="python基础" scheme="http://waisunny.com/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Python的可变与不可变数据类型</title>
    <link href="http://waisunny.com/2017/11/20/Python%E7%9A%84%E5%8F%AF%E5%8F%98%E4%B8%8E%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://waisunny.com/2017/11/20/Python的可变与不可变数据类型/</id>
    <published>2017-11-19T20:09:04.000Z</published>
    <updated>2017-11-26T03:52:11.381Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>初学python的时候，可能会有很多疑惑，尤其是最先接触的所谓的“可变数据类型”和“不可变数据类型”。python与C/C++不一样，它的变量使用有自己的特点，当初学python的时候，一定要记住“一切皆为对象，一切皆为对象的引用”这句话，其实这个特点类似于JAVA，所以在python里面大家也不用担心类似于C/C++中的指针的复杂问题。下面本文将对python里面的“可变数据类型”和“不可变数据类型”进行分析。</p><p>首先，我们需要知道在python中哪些是可变数据类型，哪些是不可变数据类型。</p><p><strong>可变数据类型：列表list和字典dict；</strong></p><p><strong>不可变数据类型：整型int、浮点型float、字符串型string和元组tuple。</strong></p><p>然后，我们以int和list为例，来看看“可变数据类型”和“不可变数据类型”到底有什么区别。</p><h1 id="不可变数据类型分析"><a href="#不可变数据类型分析" class="headerlink" title="不可变数据类型分析"></a>不可变数据类型分析</h1><pre><code>&gt;&gt;&gt; x = 1    &gt;&gt;&gt; id(x)    31106520    &gt;&gt;&gt; y = 1    &gt;&gt;&gt; id(y)    31106520    &gt;&gt;&gt; x = 2    &gt;&gt;&gt; id(x)    31106508    &gt;&gt;&gt; y = 2    &gt;&gt;&gt; id(y)    31106508    &gt;&gt;&gt; z = y    &gt;&gt;&gt; id(z)    31106508   &gt;&gt;&gt; x += 2    &gt;&gt;&gt; id(x)    31106484 </code></pre><p>上面这段程序都是对不可变数据类型中的int类型的操作，id()查看的是当前变量的地址值。</p><p>我们先来看x = 1和y = 1两个操作的结果，从上面的输出可以看到x和y在此时的地址值是一样的，也就是说x和y其实是引用了同一个对象，即1，也就是说<strong>内存中对于1只占用了一个地址</strong>，而不管有多少个引用指向了它，都只有一个地址值，只是有一个<strong>引用计数</strong>会记录指向这个地址的引用到底有几个而已。</p><p>当我们进行x = 2赋值时，发现x的地址值变了，虽然还是x这个引用，但是其地址值却变化了，后面的y = 2以及z = y，使得x、y和z都引用了同一个对象，即2，所以地址值都是一样的。</p><p>当x和y都被赋值2后，1这个对象已经没有引用指向它了，所以1这个对象占用的内存，即31106520地址要被“垃圾回收”，即1这个对象在内存中已经不存在了。</p><p>最后，x进行了加2的操作，所以创建了新的对象4，x引用了这个新的对象，而不再引用2这个对象。</p><p>总的来说，python里的不可变大家可以理解为x引用的地址处的值是不能被改变的，也就是31106520地址处的值在没被垃圾回收之前一直都是1，不能改变，如果要把x赋值为2，那么只能将x引用的地址从31106520变为31106508，相当于x = 2这个赋值又创建了一个对象，即2这个对象，然后x、y、z都引用了这个对象，所以int这个数据类型是不可变的，如果想对int类型的变量再次赋值，在内存中相当于又创建了一个新的对象，而不再是之前的对象。从下图中就可以看到上面程序的过程。<br><img src="https://i.imgur.com/44gY2jF.png" alt=""></p><p>从上面的过程可以看出，不可变数据类型的优点就是内存中不管有多少个引用，相同的对象只占用了一块内存，但是它的缺点就是当需要对变量进行运算从而改变变量引用的对象的值时，由于是不可变的数据类型，所以必须创建新的对象，这样就会使得一次次的改变创建了一个个新的对象，不过不再使用的内存会被垃圾回收器回收(<strong>python提供了自动的垃圾回收机制，后面会有博文详解</strong>)。</p><h1 id="可变数据类型分析"><a href="#可变数据类型分析" class="headerlink" title="可变数据类型分析"></a>可变数据类型分析</h1><pre><code>&gt;&gt;&gt; a = [1, 2, 3]    &gt;&gt;&gt; id(a)    41568816    &gt;&gt;&gt; a = [1, 2, 3]    &gt;&gt;&gt; id(a)    41575088    &gt;&gt;&gt; a.append(4)    &gt;&gt;&gt; id(a)    41575088    &gt;&gt;&gt; a += [2]    &gt;&gt;&gt; id(a)    41575088    &gt;&gt;&gt; a    [1, 2, 3, 4, 2]  </code></pre><p>从上面的程序中可以看出，进行两次a = [1, 2, 3]操作，两次a引用的地址值是不同的，也就是说其实创建了两个不同的对象，这一点明显不同于不可变数据类型，所以对于可变数据类型来说，具有同样值的对象是不同的对象，即在内存中保存了多个同样值的对象，地址值不同。</p><p>接着来看后面的操作，我们对列表进行添加操作，分别a.append(4)和a += [2]，发现这两个操作使得a引用的对象值变成了上面的最终结果，但是a引用的地址依旧是41575088，也就是说对a进行的操作不会改变a引用的地址值，只是在地址后面又扩充了新的地址，改变了地址里面存放的值，</p><p><strong>所以可变数据类型的意思就是说对一个变量进行操作时，其值是可变的，值的变化并不会引起新建对象，即地址是不会变的，只是地址中的内容变化了或者地址得到了扩充。下图对这一过程进行了图示，可以很清晰地看到这一过程。</strong><br><img src="https://i.imgur.com/aSEf24o.png" alt=""></p><p>从上述过程可以看到，可变数据类型是允许同一对象的内容，即值可以变化，但是地址是不会变化的。但是需要注意一点，对可变数据类型的操作不能是直接进行新的赋值操作，比如说a = [1, 2, 3, 4, 5, 6, 7]，这样的操作就不是改变值了，而是新建了一个新的对象，这里的可变只是对于类似于append、+=等这种操作。</p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><pre><code>&gt;&gt;&gt; x=3.14&gt;&gt;&gt; y=3.14&gt;&gt;&gt; id(x) 1996197073232&gt;&gt;&gt; id(y)1996197073688&gt;&gt;&gt; y=x&gt;&gt;&gt; id(y)1996197073232</code></pre><p>为什么会出现上述情况呢？同一个3.14在内存中创建了两次，浮点型不是不可变类型吗？原因是因为Python 仅缓存简单整数，因为它认为在 Python 应用程序中这些小整数会经常被用到。Python 缓存的整数范围是(-1, 100)，不过这个范围是会改变的，所以请不要在你的应用程序使用这个特性。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>不可变数据类型，不允许变量的值发生变化，如果改变了变量的值，相当于是新建了一个对象，而对于相同的值的对象，在内存中则只有一个对象，内部会有一个引用计数来记录有多少个变量引用这个对象；</p><p>可变数据类型，允许变量的值发生变化，即如果对变量进行append、+=等这种操作后，只是改变了变量的值，而不会新建一个对象，变量引用的对象的地址也不会变化，不过对于相同的值的不同变量，在内存中则会存在不同的对象，即每个对象都有自己的地址，相当于内存中对于同值的对象保存了多份，这里不存在引用计数，是实实在在的对象。</p><p>最后，大家主要区分开什么是变量值的变化、什么是变量引用的对象地址的变化这些概念就很清楚了，千说万说都不如自己动手写一些程序测试一下看看来得实在，所以建议大家有什么疑惑可以自己写一些基本的程序测试一下便知道结果。如果大家有新的意见，欢迎补充，谢谢。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;初学python的时候，可能会有很多疑惑，尤其是最先接触的所谓的“可变数据类型”和“不可变数据类型”。python与C/C++不一样，它的变
      
    
    </summary>
    
    
      <category term="python基础" scheme="http://waisunny.com/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>python中的字符串</title>
    <link href="http://waisunny.com/2017/11/19/python%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://waisunny.com/2017/11/19/python中的字符串/</id>
    <published>2017-11-18T17:39:38.000Z</published>
    <updated>2017-11-26T03:52:59.870Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字符串介绍"><a href="#字符串介绍" class="headerlink" title="字符串介绍"></a>字符串介绍</h1><p>基本字符串操作，索引、分片、乘法、判断成员资格、求长度、取最大最小值等，但请记住字符串是不可变的，so 通过分片赋值都是不合法的。</p><pre><code>&gt;&gt;&gt; x=&apos;Dany&apos;&gt;&gt;&gt; x[0]D&gt;&gt;&gt; x[1,3]an&gt;&gt;&gt; len(x)4&gt;&gt;&gt; x*3DanyDanyDany&gt;&gt;&gt; x[1:3]=&apos;co&apos;#非法操作，会出错的Traceback (most recent call last):File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: &apos;str&apos; object does not support item assignment</code></pre><h1 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h1><h2 id="方式一-‘-’"><a href="#方式一-‘-’" class="headerlink" title="方式一 ‘%’"></a>方式一 ‘%’</h2><p>使用%，在 <strong>%</strong> 左侧放置一个字符串（需要被格式化的字符串），右侧放置希望被格式化成的值，可以使用一个值，如一个字符串或者一个数字；（也可以使用多个值的元组或者下章将会讨论到的字典，前提是需要格式化多个值），一般情况下使用元组</p><pre><code>&gt;&gt;&gt; format=&quot;hello %s . My Name is %s&quot;&gt;&gt;&gt; words=(&apos;Word&apos;,&apos;Dany&apos;)&gt;&gt;&gt; format%wordshello Word . My Name is Dany</code></pre><p>说明：格式化操作符的右操作数可以是任意类型，如果右操作数是元组的话，则其中的每一个元素都会被单独格式化，每个值都需要一个对应的转换说明符，并且元组作为转换表达式的一部分存在时，必须使用圆括号括起来。</p><p>转换说明符：它们标记了需要插入转换值的位置。s表示值会被格式化为字符串–如果不是字符串，则会用str函数将其转换为字符串。</p><p><strong>如果使用列表或者其他序列代替元组，那么序列会被解释为一个值，只有元组和字典可以格式化一个以上的值。</strong></p><pre><code>&gt;&gt;&gt; str=&quot;hello %s . My Name is %s&quot;&gt;&gt;&gt; words=[&apos;Word&apos;,&apos;Dany&apos;]&gt;&gt;&gt; str%wordsTraceback (most recent call last):File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: not enough arguments for format string</code></pre><p>格式化整数，<strong>%d</strong></p><pre><code>&gt;&gt;&gt; str=&quot;My age is %d&quot;&gt;&gt;&gt; vales=23&gt;&gt;&gt; str%valesMy age is 23</code></pre><p>格式化实数（浮点数），<strong>%.2f </strong> 一个句点’.’在加上希望保留的小数位。</p><pre><code>&gt;&gt;&gt; str=&quot;Hello,My Height is %.2f m&quot;&gt;&gt;&gt; vales=(1.765)&gt;&gt;&gt; str%valesHello,My Height is 1.76 m&gt;&gt;&gt; str=&quot;Pi with three decimal:%.3f&quot;&gt;&gt;&gt; str math import pi&gt;&gt;&gt; str%piPi with three decimal:3.141</code></pre><h2 id="方式二-‘模板字符串’"><a href="#方式二-‘模板字符串’" class="headerlink" title="方式二 ‘模板字符串’"></a>方式二 ‘模板字符串’</h2><p>模板字符串：string模块提供的另外一种格式化字符的方式。</p><p>substitute这个模板方法会用传递进来的关键字参数foo替换字符串中的$foo,并返回替换后的值。</p><pre><code>&gt;&gt;&gt; from string import Template #导入模板&gt;&gt;&gt; s=Template(&apos;$x. glorious $x!&apos;)#包装字符串&gt;&gt;&gt; s.substitute(x=&apos;slurm&apos;)#调用模板方法格式换字符串slurm. glorious slurm!</code></pre><p>如果替换字段是单词的一部分，那么参数名就必须用括号括起来，从而准确指明结尾：</p><pre><code>&gt;&gt;&gt; s=Template(&quot;It&apos;s ${x}tastic!&quot;)&gt;&gt;&gt; s.substitute(x=&apos;slurm&apos;)It&apos;s slurmtastic!</code></pre><p>可以使用$$插入美元符号</p><pre><code>&gt;&gt;&gt; s=Templatte(&quot;Make $$ selling $x!&quot;)&gt;&gt;&gt; s.substitute(x=&apos;slurm&apos;)Make $ selling slurm!</code></pre><p>除了关键字参数外，还可以使用字典变量提供值/名称对</p><pre><code>&gt;&gt;&gt; s=Template(&quot;A $thing must never $action.&quot;)&gt;&gt;&gt; d={}&gt;&gt;&gt; d[&apos;thing&apos;]=&apos;gentleman&apos;&gt;&gt;&gt; d[&apos;action&apos;]=&apos;show his socks&apos;&gt;&gt;&gt; s.substitute(d)A gentleman must never show his socks.</code></pre><p>说明：safe_substitute相比substitute不会因为缺少值或者不正确使用$字符而出错</p><h2 id="方式三-‘format函数’"><a href="#方式三-‘format函数’" class="headerlink" title="方式三 ‘format函数’"></a>方式三 ‘format函数’</h2><pre><code>&gt;&gt;&gt; s_info=&quot;{0}&apos;s age is {1}&quot;.format(&apos;Dany&apos;,23)&gt;&gt;&gt; s_infoDany&apos;s age is 23&gt;&gt;&gt; s_info=&quot;{name}&apos;s age is {age}&quot;.format(name=&apos;Dany&apos;,age=23)&gt;&gt;&gt; s_infoDany&apos;s age is 23</code></pre><p>说明：推荐使用第三种，简明直观。</p><h1 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h1><h2 id="方式一-‘-’-1"><a href="#方式一-‘-’-1" class="headerlink" title="方式一 ‘+’"></a>方式一 ‘+’</h2><pre><code>website = &apos;http:\\&apos; + &apos;python&apos; + &apos;.org&apos;</code></pre><h2 id="方式二-‘join方法’"><a href="#方式二-‘join方法’" class="headerlink" title="方式二 ‘join方法’"></a>方式二 ‘join方法’</h2><pre><code>listStr = [&apos;http:\\&apos;, &apos;python&apos;, &apos;.org&apos;] website = &apos;&apos;.join(listStr)</code></pre><h2 id="方式三-‘格式化-替换-’"><a href="#方式三-‘格式化-替换-’" class="headerlink" title="方式三 ‘格式化(替换)’"></a>方式三 ‘格式化(替换)’</h2><pre><code>website = &apos;%s%s%s&apos; % (&apos;http:\\&apos;, &apos;python&apos;, &apos;.org&apos;)</code></pre><h2 id="三种方式比较"><a href="#三种方式比较" class="headerlink" title="三种方式比较"></a>三种方式比较</h2><p>方法1，使用简单直接，但是网上不少人说这种方法效率低，之所以说python 中使用 + 进行字符串连接的操作效率低下，是因为python中字符串是不可变的类型，使用 + 连接两个字符串时会生成一个新的字符串，生成<strong>新的字符串就需要重新申请内存</strong>，当连续相加的字符串很多时(a+b+c+d+e+f+…) ，效率低下就是必然的了</p><p>方法2，使用略复杂，但对多个字符进行连接时效率高，只会有一次内存的申请。而且如果是对list的字符进行连接的时候，这种方法必须是首选</p><p>方法3：字符串格式化，这种方法非常常用，本人也推荐使用该方法</p><h3 id="实验对比-VS-join方法"><a href="#实验对比-VS-join方法" class="headerlink" title="实验对比 + VS join方法"></a>实验对比 + VS join方法</h3><p>实验一：</p><pre><code>from time import timedef method1():    t = time()    for i in xrange(100000):            s =&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.    org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;py    thon.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org    &apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;pytho    n.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;    python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.o    rg&apos;print (time() - t)def method2():    t = time()    for i in xrange(100000):        s = &apos;&apos;.join    ([&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;pytho    n.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;    python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.o    rg&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;pyt    hon.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;    ,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python    .org&apos;])print (time() -t)method1()method2()</code></pre><p>结果：</p><pre><code>1.381000041960.137000083923</code></pre><p>实验二：</p><pre><code>from time import timedef method3():    t = time()    for i in xrange(100000):        s = &apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;    print (time() - t)def method4():    t = time()    for i in xrange(100000):        s = &apos;&apos;.join([&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;])    print (time() -t)method3()method4()</code></pre><p>结果：</p><pre><code>0.02500009536740.0599999427795</code></pre><p>上面两个实验出现了完全不同的结果，分析这两个实验唯一不同的是：字符串连接个数。</p><p><strong>结论：加号连接效率低是在连续进行多个字符串连接的时候出现的，如果连接的个数较少，加号连接效率反而比join连接效率高</strong></p><h1 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h1><h2 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h2><p>非常重要的一个字符串方法，它是split方法的逆方法，用来连接序列中的元素，返回字符串。</p><pre><code>&gt;&gt;&gt; strs=[&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;]&gt;&gt;&gt; &apos;+&apos;.join(strs)1+2+3+4&gt;&gt;&gt; strs=&apos;liwei&apos;,&apos;lijie&apos;&gt;&gt;&gt; &apos;--love--&gt;&apos;.join(strs)liwei--love--&gt;lijie&gt;&gt;&gt; strs=[1,2,3,4,5]&gt;&gt;&gt; &apos;+&apos;.join(strs)#出错，因为join需要连接的序列元素必须都是字符串Traceback (most recent call last):File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: sequence item 0: expected str instance, int found</code></pre><h2 id="lower方法"><a href="#lower方法" class="headerlink" title="lower方法"></a>lower方法</h2><p>返回字符串的小写字母版</p><pre><code>&gt;&gt;&gt; strs=&apos;Dany is A Good Boy&apos;&gt;&gt;&gt; strs.lower()dany is a good boy</code></pre><h2 id="upper方法"><a href="#upper方法" class="headerlink" title="upper方法"></a>upper方法</h2><p>返回字符串的大写字母版</p><pre><code>&gt;&gt;&gt; strs=&apos;dany is A Good Boy&apos;&gt;&gt;&gt; strs.upper()DANY IS A GOOd BOY</code></pre><h2 id="replace方法"><a href="#replace方法" class="headerlink" title="replace方法"></a>replace方法</h2><p>方法返回某字符串的所有匹配项均被替换后得到的字符串</p><pre><code>&gt;&gt;&gt; strs=&apos;Dany Is is nice boy&apos;&gt;&gt;&gt; strs.replace(&apos;is&apos;,&apos;very&apos;)Dany Is very nice boy</code></pre><h2 id="split方法"><a href="#split方法" class="headerlink" title="split方法"></a>split方法</h2><p>将字符串分割成序列，返回的数据类型是列表</p><pre><code>&gt;&gt;&gt; strs=&apos;1+2+3+4&apos;&gt;&gt;&gt; strs.split(&apos;+&apos;)[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;]&gt;&gt;&gt; strs=&apos;1,2,3.4/5&apos;&gt;&gt;&gt; strs.split(&apos;,&apos;)[&apos;1&apos;,&apos;2&apos;,&apos;3.4/5&apos;]&gt;&gt;&gt; strs=&apos;1 2   3,4&apos;&gt;&gt;&gt; print(strs.split())#不指定分隔符会默认把所有的空格作为分隔符（空格，制表，换行）[&apos;1&apos;,&apos;2&apos;,&apos;3,4&apos;]</code></pre><h2 id="strip方法"><a href="#strip方法" class="headerlink" title="strip方法"></a>strip方法</h2><p>去除两侧的空格，不包含内部的</p><pre><code>&gt;&gt;&gt; strs=&apos;    123 3323  34      &apos;&gt;&gt;&gt; strs.strip()123 3323  34&gt;&gt;&gt; strs=&apos;!*12321!*221!*1231!*&apos;&gt;&gt;&gt; print(strs.strip(&apos;!*&apos;))#去除指定的字符，但只是去除两侧的12321!*221!*1231</code></pre><h2 id="startswith方法"><a href="#startswith方法" class="headerlink" title="startswith方法"></a>startswith方法</h2><p>判断是否以某一个字符串开头，返回布尔值</p><pre><code>&gt;&gt;&gt; strs=&apos;Dany is a good boy&apos;&gt;&gt;&gt; strs.startswith(&apos;Da&apos;) #注意这里区分大小写True</code></pre><h2 id="find方法"><a href="#find方法" class="headerlink" title="find方法"></a>find方法</h2><p>查找某一段字符串在一段字符串中出现的第一个位置并返回索引值</p><pre><code>&gt;&gt;&gt; strs=&apos;Dany is a good boy，Dany&apos;&gt;&gt;&gt; strs.find(&apos;Dany&apos;)0</code></pre><h2 id="count方法"><a href="#count方法" class="headerlink" title="count方法"></a>count方法</h2><p>返回某一段字符串出现的次数</p><pre><code>&gt;&gt;&gt; strs=&apos;Dany is a good boy，Dany&apos;&gt;&gt;&gt; strs.count(&apos;Dany&apos;)2</code></pre><h2 id="center方法"><a href="#center方法" class="headerlink" title="center方法"></a>center方法</h2><p>使字符串居中</p><pre><code>&gt;&gt;&gt; strs=&apos;DanyInfo&apos;&gt;&gt;&gt; strs.center(30,&apos;*&apos;)#参数1：字符串总长度，参数2：填充的字符***********DanyInfo***********</code></pre><h2 id="format方法"><a href="#format方法" class="headerlink" title="format方法"></a>format方法</h2><p>字符串格式化</p><pre><code>&gt;&gt;&gt; s_info=&quot;{0}&apos;s age is {1}&quot;.format(&apos;Dany&apos;,23)&gt;&gt;&gt; s_infoDany&apos;s age is 23&gt;&gt;&gt; s_info=&quot;{name}&apos;s age is {age}&quot;.format(name=&apos;Dany&apos;,age=23)&gt;&gt;&gt; s_infoDany&apos;s age is 23</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>字符串就介绍这么多，基本上覆盖到我们平常用到的所有字符串相关大知识点，另外在强调一点，字符串是不可变的，不可变类型和可变类型的详细介绍可参考我的下一篇博文。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;字符串介绍&quot;&gt;&lt;a href=&quot;#字符串介绍&quot; class=&quot;headerlink&quot; title=&quot;字符串介绍&quot;&gt;&lt;/a&gt;字符串介绍&lt;/h1&gt;&lt;p&gt;基本字符串操作，索引、分片、乘法、判断成员资格、求长度、取最大最小值等，但请记住字符串是不可变的，so 通过分片赋值
      
    
    </summary>
    
    
      <category term="python基础" scheme="http://waisunny.com/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>python中的变量</title>
    <link href="http://waisunny.com/2017/11/18/python%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F/"/>
    <id>http://waisunny.com/2017/11/18/python中的变量/</id>
    <published>2017-11-17T17:06:42.000Z</published>
    <updated>2017-11-26T03:52:50.531Z</updated>
    
    <content type="html"><![CDATA[<p>定义变量的目的：简单来说，变量是为了存储程序运算过程中的一些中间结果，为了方便日后调用。</p><p><strong>记住:python中一切皆为对象，一切皆为对象的引用，变量=对象。</strong></p><h1 id="变量命名规则"><a href="#变量命名规则" class="headerlink" title="变量命名规则"></a>变量命名规则</h1><ol><li>要具有描述性</li><li>变量名只能_,数字，字母组成，不可以是空格或特殊字符(#?&lt;.，￥$*!~)</li><li>不能以中文为变量名</li><li>不能以数字开头</li><li>保留字符是不能被使用</li></ol><h1 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h1><p>1.定义一个整数变量:</p><pre><code>a = 1</code></pre><p>2.定义一个字符串变量:</p><pre><code>t_007 = &apos;T007&apos;</code></pre><p>3.定义一个布尔值：</p><pre><code>Answer = True</code></pre><p>在Python中，等号=是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，例如：</p><pre><code>a = 123 # a是整数print(a)a = &apos;ABC&apos; # a变为字符串print(a)</code></pre><p>这种变量本身类型不固定的语言称之为<strong>动态语言</strong>，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下：</p><pre><code>int a = 123; //a是整数类型变量a = &quot;ABC&quot;; //错误：不能把字符串赋给整型变量</code></pre><p>和静态语言相比，动态语言更灵活。</p><p>可以看出，Python 中不但变量名无需事先声明，而且也无需类型声明。Python 语言中，<br>对象的类型和内存占用都是运行时确定的。尽管代码被编译成字节码，Python 仍然是一种<strong>解释型语言</strong>。在创建——也就是赋值时，解释器会根据语法和右侧的操作数来决定新对象的类型。在对象创建后，一个该对象的应用会被赋值给左侧的变量。 </p><h1 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h1><pre><code>&gt;&gt;&gt; x=1 #直接=赋值&gt;&gt;&gt; x=y=1# 链式复制&gt;&gt;&gt; x+=1 #增量赋值(x=x+1)&gt;&gt;&gt; x,y,z=(1,2,&apos;a&apos;)# 多元赋值 ,=号后面是一个元祖，即用小括号括起来，其实可以不加小括号，但为了提高代码可读性建议加上</code></pre><p>说明：赋值并不是直接将一个值赋给一个变量， 尽管你可能根据其它语言编程经验认为应该如此。在 Python 语言中，对象是通过引用传递的。在赋值时，不管这个对象是新创建的，还是一个已经存在的，都是将该对象的引用（并不是值）赋值给变量。</p><h1 id="存储机制"><a href="#存储机制" class="headerlink" title="存储机制"></a>存储机制</h1><p>声明：<strong>a = ‘ABC’</strong>时，Python解释器干了两件事情：</p><ol><li>在内存中创建了一个’ABC’的字符串；</li><li>在内存中创建了一个名为a的变量，并把它指向’ABC’。</li></ol><p>也可以把一个变量a赋值给另一个变量b，这个操作实际上<strong>是把变量b指向变量a所指向的数据</strong>，例如下面的代码：</p><pre><code>a = &apos;ABC&apos;b = aa = &apos;XYZ&apos;print(b)</code></pre><p>最后一行打印出变量b的内容到底是’ABC’呢还是’XYZ’？如果从数学意义上理解，就会错误地得出b和a相同，也应该是’XYZ’，但实际上b的值是’ABC’，让我们一行一行地执行代码，就可以看到到底发生了什么事：</p><p>1.执行a = ‘ABC’，解释器创建了字符串’ABC’和变量a，并把a指向’ABC’：</p><p><img src="https://i.imgur.com/ldl7FxP.png" alt=""></p><p>2.执行b = a，解释器创建了变量b，并把b指向a指向的字符串’ABC’：</p><p><img src="https://i.imgur.com/JZ6sixs.png" alt=""></p><p>3.执行a = ‘XYZ’，解释器创建了字符串’XYZ’，并把a的指向改为’XYZ’，但b并没有更改：</p><p><img src="https://i.imgur.com/VEUY64z.png" alt=""></p><p>所以，最后打印变量b的结果自然是’ABC’了。</p><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><p>所谓常量就是不能变的变量，比如常用的数学常数π就是一个常量。在Python中，通常用<strong>全部大写的变量名表示常量</strong>：</p><pre><code>PI = 3.14159265359</code></pre><p>但事实上PI仍然是一个变量，Python根本没有任何机制保证PI不会被改变，所以，用全部大写的变量名表示常量只是一个习惯上的用法，如果你一定要改变变量PI的值，也没人能拦住你。</p><h1 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h1><p>最后解释一下整数的除法为什么也是精确的。在Python中，有两种除法，一种除法是/：</p><pre><code>&gt;&gt;&gt; 10 / 33.3333333333333335 #这是python3中的结果python2中值为3</code></pre><p><strong>/</strong> python3中除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数：</p><pre><code>&gt;&gt;&gt; 9 / 33.0</code></pre><p>还有一种除法是 <strong>//</strong> ，称为地板除，两个整数的除法仍然是整数：</p><pre><code>&gt;&gt;&gt; 10 // 33</code></pre><p>你没有看错，整数的地板除 <strong>//</strong> 永远是整数，即使除不尽。要做精确的除法，使用 <strong>/</strong> 就可以。</p><p>因为 <strong>//</strong> 除法只取结果的整数部分，所以Python还提供一个余数运算，可以得到两个整数相除的余数：</p><pre><code>&gt;&gt;&gt; 10 % 31</code></pre><p>无论整数做 <strong>//</strong> 除法还是取余数 <strong>%</strong> ，结果永远是整数，所以，整数运算结果永远是精确的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;定义变量的目的：简单来说，变量是为了存储程序运算过程中的一些中间结果，为了方便日后调用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;记住:python中一切皆为对象，一切皆为对象的引用，变量=对象。&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;变量命名规则&quot;&gt;&lt;a href=&quot;#变量命名
      
    
    </summary>
    
    
      <category term="python基础" scheme="http://waisunny.com/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>setuptools和pip安装教程</title>
    <link href="http://waisunny.com/2017/11/17/setuptools%E5%92%8Cpip%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    <id>http://waisunny.com/2017/11/17/setuptools和pip安装教程/</id>
    <published>2017-11-16T16:03:08.000Z</published>
    <updated>2017-11-26T03:53:07.966Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装setuptools"><a href="#安装setuptools" class="headerlink" title="安装setuptools"></a>安装setuptools</h1><p>①下载setuptools源码<strong>setuptools-25.2.0.tar.gz</strong>，地址：<a href="https://pypi.python.org/pypi/setuptools" title="setuptools下载" target="_blank" rel="external">https://pypi.python.org/pypi/setuptools</a><br><img src="https://i.imgur.com/a29kEga.png" alt=""><br>②这是一个压缩文件，将其解压到桌面，并进入该文件夹；按住shift键后，在文件夹空白处点击鼠标右键，选择：在此处打开命令窗口，输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python setup.py install</span><br></pre></td></tr></table></figure><p>回车，看到如下图内容即表示安装成功：<br><img src="https://i.imgur.com/epT3f5n.png" alt=""></p><p>③安装完后在当前窗口中输入 <strong>easy_install</strong> 回车，进行检测，如果提示：<br><strong>error: No urls, filenames, or requirements specified (see –help</strong>) 说明安装成功，它在提示你命令后面需要跟参数。 如果提示： <strong>‘easy_install’</strong> 不是内部或外部命令，也不是可运行的程序或批处理文件。 请检查系统环境变量path是否配置了<strong>‘C:\Python27\Scripts’</strong></p><h1 id="安装pip"><a href="#安装pip" class="headerlink" title="安装pip"></a>安装pip</h1><h2 id="使用easy-install安装pip"><a href="#使用easy-install安装pip" class="headerlink" title="使用easy_install安装pip"></a>使用easy_install安装pip</h2><p>如果setuptools安装好后，可以直接用easy_install来安装pip，如下图：<br><img src="https://i.imgur.com/I0axT0o.png" alt=""></p><h2 id="手动安装pip"><a href="#手动安装pip" class="headerlink" title="手动安装pip"></a>手动安装pip</h2><p>如果还想手动安装的话，和安装setuptools步骤完全一样</p><p>①下载pip压缩包<strong>pip-9.0.1.tar.gz</strong>，地址：<a href="https://pypi.python.org/pypi/pip" title="pip下载" target="_blank" rel="external">https://pypi.python.org/pypi/pip</a>，如下图：<img src="https://i.imgur.com/gGKpfRK.png" alt=""></p><p>②这是一个压缩文件，将其解压到桌面，并进入该文件夹，按住shift键后，在文件夹空白处点击鼠标右键，选择：在此处打开命令窗口，输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python setup.py install</span><br></pre></td></tr></table></figure><p>回车，看到如下图内容即表示安装成功：<br><img src="https://i.imgur.com/vZev7uY.png" alt=""></p><p>③安装成功后输入 <strong>pip</strong> 回车，进行检测如果提示： <strong>Did not provide a command</strong> 说明安装成功，因为pip后面也需要跟参数；如果提示： <strong>‘pip’ </strong>不是内部或外部命令，也不是可运行的程序或批处理文件，请检查环境变量path是否配置了<strong>‘C:\Python27\Scripts’</strong></p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>卸载pip:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m pip uninstall pip setuptools</span><br></pre></td></tr></table></figure><p>升级pip:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m pip install --upgrade pip</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安装setuptools&quot;&gt;&lt;a href=&quot;#安装setuptools&quot; class=&quot;headerlink&quot; title=&quot;安装setuptools&quot;&gt;&lt;/a&gt;安装setuptools&lt;/h1&gt;&lt;p&gt;①下载setuptools源码&lt;strong&gt;setupto
      
    
    </summary>
    
    
      <category term="python环境部署" scheme="http://waisunny.com/tags/python%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>python 环境部署-Windows</title>
    <link href="http://waisunny.com/2017/11/16/python-%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2-Windows/"/>
    <id>http://waisunny.com/2017/11/16/python-环境部署-Windows/</id>
    <published>2017-11-15T16:53:48.000Z</published>
    <updated>2017-11-26T03:52:21.074Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h1><p>①下载python解释器：    </p><p>进入python官网：<a href="http://www.python.org" target="_blank" rel="external">http://www.python.org</a> 点击Downlods，选择Windows，然后看到如下界面：</p><p><img src="https://i.imgur.com/L62Jf03.jpg" alt=""></p><p>圈出来的一个是python3版本一个是python2版本，建议都安装，日后可根据需求使用，<strong>建议使用python3</strong>，虽然说现在市场上大部分是使用python2,但是python2最终会被python3替换掉，一些新项目都是使用python3开发的。另外没必要过于纠结两个版本，他们在一些语法上使用是有些许不同，但整体相似。详情参考:<a href="https://www.zhihu.com/question/19698598" title="python2和python3的区别" target="_blank" rel="external">https://www.zhihu.com/question/19698598</a></p><p>下载好后直接安装即可，<strong>记录住安装目录</strong>。    </p><h1 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h1><p>②配置环境变量：    </p><p>步骤(Win10)：右键单击电脑属性—&gt;高级系统设置—&gt;环境变量—&gt;编辑系统变量Path—&gt;将刚才的安装路径添加进去，如下图：</p><p><img src="https://i.imgur.com/Akxo4lX.jpg" alt=""><br>我配置了python3和python2的环境变量，并把python3的放在了第一位，系统会采用环境变量靠前的python版本；环境变量设置的路径就是你python的安装路径，以python2为例，如下图：</p><p><img src="https://i.imgur.com/9DFsk0G.jpg" alt=""></p><h1 id="检验是否安装成功"><a href="#检验是否安装成功" class="headerlink" title="检验是否安装成功"></a>检验是否安装成功</h1><p>打开cmd命令框，快捷键是windows+r ,输入cmd–&gt;回车—&gt;在弹出的命令框中输入 <strong>python</strong>,看到如下图内容即表示配置成功：</p><p><img src="https://i.imgur.com/jbijBPp.jpg" alt=""></p><h1 id="完善"><a href="#完善" class="headerlink" title="完善"></a>完善</h1><p>为了方便后续的python版本切换，建议将python安装路径下的python.exe程序重命名为对应版本的名称，即python2.7版本的命名为：python2.exe，python3.6版本的命名为python3.exe；这样我们就可以在命令框中直接输入对应的名称就可以使用各版本的python，不用切换环境变量的先后顺序了。如下图：</p><p><img src="https://i.imgur.com/Jvns0hw.jpg" alt=""></p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>这是最基本的python环境部署，后续在实际开发过程中我们还要安装很多类库、插件等；推荐安装pip,使用pip安装类库等十分方便。</p><p>如何安装pip,详见：<a href="http://waisunny.com/2017/11/17/setuptools%E5%92%8Cpip%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/" title="pip安装">http://waisunny.com/2017/11/17/setuptools%E5%92%8Cpip%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第一步&quot;&gt;&lt;a href=&quot;#第一步&quot; class=&quot;headerlink&quot; title=&quot;第一步&quot;&gt;&lt;/a&gt;第一步&lt;/h1&gt;&lt;p&gt;①下载python解释器：    &lt;/p&gt;
&lt;p&gt;进入python官网：&lt;a href=&quot;http://www.python.org
      
    
    </summary>
    
    
      <category term="python环境部署" scheme="http://waisunny.com/tags/python%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
</feed>
