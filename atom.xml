<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WaiBlog|码农的技术小窝</title>
  
  <subtitle>所有的努力都值得期许，每一份梦想都应该灌溉！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://waisunny.com/"/>
  <updated>2018-01-06T09:36:05.240Z</updated>
  <id>http://waisunny.com/</id>
  
  <author>
    <name>_learner</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python—包剖析</title>
    <link href="http://waisunny.com/2017/12/30/python%E2%80%94%E5%8C%85%E5%89%96%E6%9E%90/"/>
    <id>http://waisunny.com/2017/12/30/python—包剖析/</id>
    <published>2017-12-29T17:11:03.000Z</published>
    <updated>2018-01-06T09:36:05.240Z</updated>
    
    <content type="html"><![CDATA[<p>包是一个有层次的文件目录结构, 它定义了一个由模块和子包组成的 Python 应用程序执行<br>环境。Python 1.5 加入了包, 用来帮助解决如下问题:</p><ol><li>为平坦的名称空间加入有层次的组织结构</li><li>允许程序员把有联系的模块组合到一起</li><li>允许分发者使用目录结构而不是一大堆混乱的文件</li><li>帮助解决有冲突的模块名称</li></ol><p>与类和模块相同, 包也使用句点属性标识来访问他们的元素。 使用标准的 import 和<br>from-import 语句导入包中的模块。<br><a id="more"></a></p><h1 id="包的目录结构"><a href="#包的目录结构" class="headerlink" title="包的目录结构"></a>包的目录结构</h1><pre><code>Phone/    __init__.py    common_util.py    Voicedta/        __init__.py        Pots.py    Fax/        __init__.py        G3.py    Mobile/        __init__.py        Analog.py        Digital.py    Pager/        __init__.py        Numeric.py</code></pre><p>Phone 是最顶层的包, Voicedta 等是它的子包。 </p><p>从上面的目录结构我们发现每一个包中都包含一个__init__.py文件。</p><p>这个文件有什么作用呢？</p><ol><li>__init__.py的第一个作用就是包的标识，如果没有该文件，该目录就不会认为是包。</li><li>__init__.py的另外一个作用就是定义包中的__all__变量，该变量包含执行 from module import * 这样的语句时应该导入的模块的名字. 它由一个模块名字符串列表组成。</li></ol><h1 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h1><h2 id="import语句"><a href="#import语句" class="headerlink" title="import语句"></a>import语句</h2><pre><code>import Phone.Mobile.Analog #导入子包中的模块Phone.Mobile.Analog.dial() #调用子包模块中的函数dial()</code></pre><h2 id="from-import语句"><a href="#from-import语句" class="headerlink" title="from-import语句"></a>from-import语句</h2><pre><code>from Phone import MobileMobile.Analog.dial(&apos;555-1212&apos;)from Phone.Mobile import AnalogAnalog.dial(&apos;555-1212&apos;)from package.module import *</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;包是一个有层次的文件目录结构, 它定义了一个由模块和子包组成的 Python 应用程序执行&lt;br&gt;环境。Python 1.5 加入了包, 用来帮助解决如下问题:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为平坦的名称空间加入有层次的组织结构&lt;/li&gt;
&lt;li&gt;允许程序员把有联系的模块组合到一起&lt;/li&gt;
&lt;li&gt;允许分发者使用目录结构而不是一大堆混乱的文件&lt;/li&gt;
&lt;li&gt;帮助解决有冲突的模块名称&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;与类和模块相同, 包也使用句点属性标识来访问他们的元素。 使用标准的 import 和&lt;br&gt;from-import 语句导入包中的模块。&lt;br&gt;
    
    </summary>
    
      <category term="python" scheme="http://waisunny.com/categories/python/"/>
    
    
      <category term="python基础" scheme="http://waisunny.com/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>python—模块剖析</title>
    <link href="http://waisunny.com/2017/12/28/python%E2%80%94%E6%A8%A1%E5%9D%97%E5%89%96%E6%9E%90/"/>
    <id>http://waisunny.com/2017/12/28/python—模块剖析/</id>
    <published>2017-12-28T11:12:17.000Z</published>
    <updated>2018-01-06T09:28:52.009Z</updated>
    
    <content type="html"><![CDATA[<p>在计算机程序的开发过程中，随着程序代码越写越多，在一个文件里代码就会越来越长，越来越不容易维护。为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在Python中，一个.py文件就称之为一个模块（Module）。</p><p>使用模块有什么好处？</p><p>最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括Python内置的模块和来自第三方的模块。<br><a id="more"></a></p><h1 id="导入模块"><a href="#导入模块" class="headerlink" title="导入模块"></a>导入模块</h1><h2 id="模块导入原理"><a href="#模块导入原理" class="headerlink" title="模块导入原理"></a>模块导入原理</h2><p>模块的导入需要一个叫做”路径搜索”的过程。 即在文件系统”预定义区域”中查找 mymodule.py<br>文件(如果你导入 mymodule 的话)。 这些预定义区域只不过是你的 Python 搜索路径的集合。</p><p>路径搜索和搜索路径是两个不同的概念, 前者是指查找某个文件的操作, 后者是去查找一组目录。</p><p>解释器启动之后可以通过Python的sys.path属性获得当前搜索路径集合：</p><pre><code>&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.path[&apos;C:\\Python36\\DLLs&apos;, &apos;C:\\Python36\\lib&apos;, &apos;C:\\Python36&apos;, &apos;C:\\Python36\\lib\\site-packages&apos;, &apos;C:\\Python36\\lib\\site-packages\\pip-9.0.1-py3.6.egg&apos;, &apos;C:\\Python36\\lib\\site-packages\\pymysql-0.7.11-py3.6.egg&apos;, &apos;C:\\Python36\\lib\\site-packages\\requests-2.18.4-py3.6.egg&apos;, &apos;C:\\Python36\\lib\\site-packages\\certifi-2017.7.27.1-py3.6.egg&apos;]</code></pre><p>如果你知道你需要导入的模块是什么,而它的路径不在搜索路径里, 那么只需要向sys.path 添加即可：</p><pre><code>sys.path.append(&apos;/home/wesc/py/lib&apos;)</code></pre><p>由于append()方法是把元素放在集合尾部，<strong>解释器是按照搜索路径顺序查找匹配的第一个模块名称</strong>，如果你有特殊需要, 那么应该使用列表的 insert() 方法操作。</p><p>补充：sys.path集合中值得顺序是：当前目录—&gt;环境变量PYTHONPATH中配置的目录—&gt;python的安装设置相关的默认路径</p><h2 id="模块导入方式"><a href="#模块导入方式" class="headerlink" title="模块导入方式"></a>模块导入方式</h2><h3 id="import-语句"><a href="#import-语句" class="headerlink" title="import 语句"></a>import 语句</h3><pre><code>import mymodule</code></pre><p>这种方式导入模块，就在当前的名称空间(namespace)建立了一个到该模块的引用。这种引用必须使用全称，也就是说，当使用在被导入模块中定义的函数时，必须包含模块的名字。所以不能只使用funcname，而应该使用 mymodule.funcname</p><p>当前的名称空间(namespace)，意思就是说如果在一个模块的顶层导入, 那么它的作用域就是全局的; 如果在函数中导入, 那么它的作用域是局部的。</p><p>如果mymodule模块是被第一次导入, 它将被加载并执行。</p><h3 id="from-import语句"><a href="#from-import语句" class="headerlink" title="from-import语句"></a>from-import语句</h3><pre><code>from module import name1[ name2[,....nameN]</code></pre><p>from-import语句导入模块的指定属性。name1、name2… 直接被导入到当前名称空间里去，这意味着你不需要使用属性/句点属性标识来访问模块的标识符，可直接使用name1、name2。</p><p>值得提一下的是：</p><pre><code>from module import *</code></pre><p>上面这句话是把module模块中的’所有‘名称导入到当前名称空间中，但是：</p><ol><li><p>如果module中定义了__all__变量，那只能导入__all__中的名称。</p><pre><code># module.py__all__ = [&apos;a&apos;, &apos;b&apos;]a = 10b = 20c=50</code></pre><p> 只会导入 a、b两个名称。</p> <font color="red">__all__只针对 from module import * 语句起作用。</font></li><li><p>没有定义__all__变量时，会导入所有非’<em>‘开头的名称，在python中以’</em>‘开头认为是私有的。</p><pre><code># module.pya = 10_b = 20c=50</code></pre><p>只会导入 a、c两个名称。</p></li></ol><p>另外，我们认为 “from module import *” 不是良好的编程风格, 因为它”污染”当前名称<br>空间, 而且很可能覆盖当前名称空间中现有的名字。</p><p>我们只在两种场合下建议使用这样的方法, 一个场合是：目标模块中的属性非常多, 反复键入<br>模块名很不方便, 例如 Tkinter (Python/Tk) 和 NumPy (Numeric Python) 模块, 可能还有<br>socket 模块。另一个场合是在交互解释器下, 因为这样可以减少输入次数。</p><h2 id="扩展的import语句-as"><a href="#扩展的import语句-as" class="headerlink" title="扩展的import语句(as)"></a>扩展的import语句(as)</h2><p>意思是给自己导入的模块或模块中的名称起别名。</p><pre><code>import Tkinter as tkfrom cqi import FieldStorage as fiesto</code></pre><h2 id="导入模块执行机制"><a href="#导入模块执行机制" class="headerlink" title="导入模块执行机制"></a>导入模块执行机制</h2><p>第一次载入时执行模块(执行是指模块的顶层代码将被直接执行)，一个模块只被执行一次，无论被导入多少次，这样可以阻止多重导入时代码被多次执行。这个机制是通过sys.modules控制的。</p><p>导入模块时，是创建一个名为模块名称的对象，该对象引用模块的名字空间，这样就可以通过这个对象访问模块中的函数及变量。当多次导入同一个模块时，后面的import语句只是简单的创建一个到模块名字空间的引用而已。</p><p>sys.modules是一个字典，保存着所有被导入模块的模块名到模块对象的映射。这个字典用来决定是否需要使用import语句来导入一个模块的最新拷贝。</p><h2 id="模块导入规范"><a href="#模块导入规范" class="headerlink" title="模块导入规范"></a>模块导入规范</h2><p>我们推荐所有的模块在 Python 模块的开头部分导入。 而且最好按照这样的顺序:</p><ol><li>Python 标准库模块</li><li>Python 第三方模块</li><li>应用程序自定义模块</li></ol><p>然后使用一个空行分割这三类模块的导入语句。 这将确保模块使用固定的习惯导入, 有助于减<br>少每个模块需要的 import 语句数目。</p><h1 id="模块内建函数"><a href="#模块内建函数" class="headerlink" title="模块内建函数"></a>模块内建函数</h1><h2 id="import-函数"><a href="#import-函数" class="headerlink" title="__import__函数"></a>__import__函数</h2><pre><code>__import__(module_name[, globals[, locals[, fromlist]]])</code></pre><p><strong>import</strong>() 函数作为实际上导入模块的函数, 这意味着 import 语句调用 <strong>import</strong>() 函数完成它的工作。提供这个函数是为了让有特殊需要的用户覆盖它, 实现自定义的导入算法。</p><pre><code>#这两句话相等mymodule = __import__ (’module_name’)import module_name</code></pre><h2 id="global-和locals"><a href="#global-和locals" class="headerlink" title="global()和locals()"></a>global()和locals()</h2><p>globals() 和 locals() 内建函数分别返回调用者全局和局部名称空间的字典。 在一个函数内<br>部, 局部名称空间代表在函数执行时候定义的所有名字, locals() 函数返回的就是包含这些名字<br>的字典。 globals() 会返回函数可访问的全局名字。</p><p>在全局名称空间下, globals() 和 locals() 返回相同的字典, 因为这时的局部名称空间就是<br>全局空间。</p><pre><code>def foo():    print &apos;\ncalling foo()...&apos;    aString = &apos;bar&apos;    anInt = 42    print &quot;foo()&apos;s globals:&quot;, globals().keys()    print &quot;foo()&apos;s locals:&quot;, locals().keys()print &quot;__main__&apos;s globals:&quot;, globals().keys()print &quot;__main__&apos;s locals:&quot;, locals().keys() foo()</code></pre><p>执行这个脚本, 我们得到如下的输出:</p><pre><code>&gt;&gt;&gt; $ namespaces.py__main__&apos;s globals: [&apos;__doc__&apos;, &apos;foo&apos;, &apos;__name__&apos;, &apos;__builtins__&apos;]__main__&apos;s locals: [&apos;__doc__&apos;, &apos;foo&apos;, &apos;__name__&apos;, &apos;__builtins__&apos;]</code></pre><h2 id="reload"><a href="#reload" class="headerlink" title="reload()"></a>reload()</h2><p>reload() 内建函数可以重新导入一个已经导入的模块。 它的语法如下:</p><pre><code>reload(module)</code></pre><p>上述是python2中的写法，在python3中写法如下：</p><pre><code>import importlibimportlib.reload(module)</code></pre><p>使用 reload() 的时候有一些标准。 首先模块必须是全部<br>导入(不是使用 from-import), 而且它必须被成功导入。另外 reload() 函数的参数必须是模块自<br>身而不是包含模块名的字符串。 也就是说必须类似 reload(sys) 而不是 reload(‘sys’)。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>说了那么多，主要记住,模块导入原理，根据sys.path搜索的；模块执行机制，根据sys.modules控制的；以及模块的导入方式就可以了，接下来会有博文介绍python中包的概念。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在计算机程序的开发过程中，随着程序代码越写越多，在一个文件里代码就会越来越长，越来越不容易维护。为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在Python中，一个.py文件就称之为一个模块（Module）。&lt;/p&gt;
&lt;p&gt;使用模块有什么好处？&lt;/p&gt;
&lt;p&gt;最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括Python内置的模块和来自第三方的模块。&lt;br&gt;
    
    </summary>
    
      <category term="python" scheme="http://waisunny.com/categories/python/"/>
    
    
      <category term="python基础" scheme="http://waisunny.com/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>python中的下划线</title>
    <link href="http://waisunny.com/2017/12/24/python%E4%B8%AD%E7%9A%84%E4%B8%8B%E5%88%92%E7%BA%BF/"/>
    <id>http://waisunny.com/2017/12/24/python中的下划线/</id>
    <published>2017-12-24T15:56:58.000Z</published>
    <updated>2017-12-24T08:24:47.582Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章讨论Python中下划线<em>的使用。跟Python中很多用法类似，下划线</em>的不同用法绝大部分（不全是）都是一种惯例约定。<br><a id="more"></a></p><h1 id="单个下划线（-）"><a href="#单个下划线（-）" class="headerlink" title="单个下划线（_）"></a>单个下划线（_）</h1><p>主要有三种情况：</p><ol><li><p>解释器中<br>_符号是指交互解释器中最后一次执行语句的返回结果。这种用法最初出现在CPython解释器中，其他解释器后来也都跟进了。</p><pre><code>&gt;&gt;&gt; _Traceback (most recent call last):File &quot;&quot;, line 1, in NameError: name &apos;_&apos; is not defined&gt;&gt;&gt; 42&gt;&gt;&gt; _42&gt;&gt;&gt; &apos;alright!&apos; if _ else &apos;:(&apos;&apos;alright!&apos;&gt;&gt;&gt; _&apos;alright!&apos;</code></pre></li><li><p>作为名称使用<br>这个跟上面有点类似。_用作被丢弃的名称。按照惯例，这样做可以让阅读你代码的人知道，这是个不会被使用的特定名称。举个例子，你可能无所谓一个循环计数的值：</p><pre><code>n = 42for _ in range(n):    do_something()</code></pre></li><li><p>i18n<br>_还可以被用作函数名。这种情况，单下划线经常被用作国际化和本地化字符串翻译查询的函数名。这种惯例好像起源于C语言。举个例子，在 <a href="https://docs.djangoproject.com/en/dev/topics/i18n/translation/" target="_blank" rel="external">Django documentation for translation</a> 中你可能会看到：</p><pre><code>from django.utils.translation import ugettext as _from django.http import HttpResponsedef my_view(request):    output = _(&quot;Welcome to my site.&quot;)    return HttpResponse(output)</code></pre></li></ol><p>第二种和第三种用法会引起冲突，所以在任意代码块中，如果使用了_作i18n翻译查询函数，就应该避免再用作被丢弃的变量名。</p><h1 id="单下划线前缀的名称（例如-shahriar）"><a href="#单下划线前缀的名称（例如-shahriar）" class="headerlink" title="单下划线前缀的名称（例如_shahriar）"></a>单下划线前缀的名称（例如_shahriar）</h1><p>单下划线开头被常用于模块中，在一个模块中以单下划线开头的变量和函数被默认当作内部函数,“私有成员”，如果使用 from a<em>module import * 导入时，这部分变量和函数不会被导入,除非模块/包的\</em>_all__列表明确包含了这些名称。不过值得注意的是，如果使用 import a_module 这样导入模块，仍然可以用 a_module._some_var 这样的形式访问到这样的对象。</p><h1 id="双下划线前缀的名称（例如-shahriar）"><a href="#双下划线前缀的名称（例如-shahriar）" class="headerlink" title="双下划线前缀的名称（例如__shahriar）"></a>双下划线前缀的名称（例如__shahriar）</h1><p>以双下划线做前缀的名称（特别是方法名）并不是一种惯例；它对解释器有特定含义。Python会改写这些名称，以免与子类中定义的名称产生冲突。Python documentation中提到，任何__spam这种形式（至少以两个下划线做开头，绝大部分都还有一个下划线做结尾）的标识符，都会文本上被替换为_classname__spam，其中classname是当前类名，并带上一个下划线做前缀。</p><p>看下面这个例子：</p><pre><code>&gt;&gt;&gt; class A(object):...     def _internal_use(self):...         pass...     def __method_name(self):...         pass... &gt;&gt;&gt; dir(A())[&apos;_A__method_name&apos;, ..., &apos;_internal_use&apos;]</code></pre><p>正如所料，_internal<em>use没有变化，但\</em>_method_name被改写成了_ClassName__method_name。现在创建一个A的子类B（这可不是个好名字），就不会轻易的覆盖掉A中的__method_name了：</p><pre><code>&gt;&gt;&gt; class B(A):...     def __method_name(self):...         pass... &gt;&gt;&gt; dir(B())[&apos;_A__method_name&apos;, &apos;_B__method_name&apos;, ..., &apos;_internal_use&apos;]</code></pre><p>这种特定的行为差不多等价于Java中的final方法和C++中的正常方法（非虚方法）。</p><h1 id="前后都带有双下划线的名称（例如-init-）"><a href="#前后都带有双下划线的名称（例如-init-）" class="headerlink" title="前后都带有双下划线的名称（例如 __init__）"></a>前后都带有双下划线的名称（例如 __init__）</h1><p>这些是Python的特殊方法名，这仅仅是一种惯例，一种确保Python系统中的名称不会跟用户自定义的名称发生冲突的方式。通常你可以覆写这些方法，在Python调用它们时，产生你想得到的行为。例如，当写一个类的时候经常会覆写__init__方法。Python 官方推荐永远不要将这样的命名方式应用于自己的变量或函数，而是按照文档说明来使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章讨论Python中下划线&lt;em&gt;的使用。跟Python中很多用法类似，下划线&lt;/em&gt;的不同用法绝大部分（不全是）都是一种惯例约定。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://waisunny.com/categories/Python/"/>
    
    
      <category term="python基础" scheme="http://waisunny.com/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Python黑魔法—上下文管理器</title>
    <link href="http://waisunny.com/2017/12/21/Python%E9%BB%91%E9%AD%94%E6%B3%95%E2%80%94%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8/"/>
    <id>http://waisunny.com/2017/12/21/Python黑魔法—上下文管理器/</id>
    <published>2017-12-20T16:51:59.000Z</published>
    <updated>2017-12-24T09:46:16.171Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是上下文管理器"><a href="#什么是上下文管理器" class="headerlink" title="什么是上下文管理器"></a>什么是上下文管理器</h1><p>上下文管理器顾名思义是管理上下文的,也就是负责冲锋和垫后,而让主人专心完成自己的事情。我们在编写程序的时候，通常会将一系列操作放到一个语句块中，当某一条件为真时执行该语句快。有时候，我们需要再执行一个语句块时保持某种状态，并且在离开语句块后结束这种状态。例如对文件的操作，我们在打开一个文件进行读写操作时需要保持文件处于打开状态，而等操作完成之后要将文件关闭。所以，上下文管理器的任务是：代码块执行前准备，代码块执行后收拾。上下文管理器是在Python2.5加入的功能，它能够让你的代码可读性更强并且错误更少。</p><p>需求的产生<br>在正常的管理各种系统资源(文件、锁定和连接)，在涉及到异常时通常是个棘手的问题。异常很可能导致控制流跳过负责释放关键资源的语句。例如打开一个文件进行操作时，如果意外情况发生（磁盘已满、特殊的终端信号让其终止等），就会抛出异常，这样可能最后的文件关闭操作就不会执行。如果这样的问题频繁出现，则可能耗尽系统资源。</p><p>是的，这样的问题并不是不可避免。在没有接触到上下文管理器之前，我们可以用“try/finally”语句来解决这样的问题。或许在有些人看来，“try/finally”语句显得有些繁琐。上下文管理器就是被设计用来简化“try/finally”语句的，这样可以让程序更加简洁。<br><a id="more"></a></p><h1 id="With语句"><a href="#With语句" class="headerlink" title="With语句"></a>With语句</h1><p>With语句用于执行上下文操作，它也是复合语句的一种，其基本语法如下所示：</p><pre><code>with context_expr [as var]:    with_suite</code></pre><p>With 语句仅能工作于支持上下文管理协议(context management protocol)的对象。也就是说只有内建了”上下文管理”的对象才能和 with 一起工作。Python内置了一些支持该协议的对象，如下所列是一个简短列表：</p><ol><li>file</li><li>decimal.Context</li><li>thread.LockType</li><li>threading.Lock</li><li>threading.RLock</li><li>threading.Condition</li><li>threading.Semaphore</li><li>threading.BoundedSemaphore</li></ol><p>由以上列表可以看出，file 是已经内置了对上下文管理协议的支持。所以我们可以用下边的方法来操作文件：</p><pre><code>with open(&apos;/etc/passwd&apos;, &apos;r&apos;) as f:    for eachLine in f:        # ...do stuff with eachLine or f...</code></pre><p>上边的代码试图打开一个文件,如果一切正常,把文件对象赋值给 f。然后用迭代器遍历文件中的每一行,当完成时,关闭文件。无论是在这一段代码的开始,中间,还是结束时发生异常,会执行清理的代码,此外文件仍会被自动的关闭。</p><h1 id="自定义上下文管理器"><a href="#自定义上下文管理器" class="headerlink" title="自定义上下文管理器"></a>自定义上下文管理器</h1><p>要实现上下文管理器，必须实现两个方法：一个负责进入语句块的准备操作，另一个负责离开语句块的善后操作。Python类包含两个特殊的方法，分别名为：<strong>__enter__ 和 __exit__</strong>。</p><p>__enter__: 该方法进入运行时上下文环境，并返回自身或另一个与运行时上下文相关的对象。返回值会赋给 as 从句后面的变量，as 从句是可选的。</p><p>__exit__: 该方法退出当前运行时上下文并返回一个布尔值，该布尔值标明了“如果 with<em>suit 的退出是由异常引发的，该异常是否须要被忽略”。如果 \</em>_exit__() 的返回值等于 False，那么这个异常将被重新引发一次；如果 __exit__() 的返回值等于 True，那么这个异常就被无视掉，继续执行后面的代码。</p><p>With 语句的实际执行流程是这样的：</p><ol><li>执行 context_exp 以获取上下文管理器</li><li>加载上下文管理器的 __exit__() 方法以备稍后调用</li><li>调用上下文管理器的 __enter__() 方法</li><li>如果有 as var 从句，则将 __enter__() 方法的返回值赋给 var</li><li>执行子代码块 with_suit</li><li>调用上下文管理器的 __exit__() 方法，如果 with<em>suit 的退出是由异常引发的，那么该异常的 type、value 和 traceback 会作为参数传给 \</em>_exit__()，否则传三个 None。</li><li>如果 with<em>suit 的退出由异常引发，并且 \</em>_exit__() 的返回值等于 False，那么这个异常将被重新引发一次；如果 __exit__() 的返回值等于 True，那么这个异常就被无视掉，继续执行后面的代码</li></ol><p>下面我们自己来实现一个支持上下文管理协议的类：</p><pre><code>class Query(object):    def __init__(self, name):        self.name = name    def __enter__(self):        print(&apos;Begin&apos;)        return self    def __exit__(self, exc_type, exc_value, traceback):        if exc_type:            print(&apos;Error&apos;)        else:            print(&apos;End&apos;)    def query(self):        print(&apos;Query info about %s...&apos; % self.name)</code></pre><p>这样我们就可以把自己写的资源对象用于with语句：</p><pre><code>with Query(&apos;_learner&apos;) as q:    q.query()</code></pre><p>执行结果：</p><pre><code>BeginQuery info about _learner...End</code></pre><h1 id="上下文管理工具（contextlib模块）"><a href="#上下文管理工具（contextlib模块）" class="headerlink" title="上下文管理工具（contextlib模块）"></a>上下文管理工具（contextlib模块）</h1><p><strong>contextlib</strong>模块提供更易用的上下文管理器。</p><h2 id="contextmanager"><a href="#contextmanager" class="headerlink" title="@contextmanager"></a>@contextmanager</h2><p>编写<strong>enter</strong>和<strong>exit</strong>仍然很繁琐，因此Python的标准库contextlib提供了更简单的写法，上面的代码可以改写如下：</p><pre><code>from contextlib import contextmanagerclass Query(object):    def __init__(self, name):        self.name = name    def query(self):        print(&apos;Query info about %s...&apos; % self.name)@contextmanagerdef create_query(name):    print(&apos;Begin&apos;)    q = Query(name)    yield q    print(&apos;End&apos;)</code></pre><p><strong>@contextmanager</strong>这个decorator接受一个generator，用yield语句把with … as var把变量输出出去，然后，with语句就可以正常地工作了：</p><pre><code>with create_query(&apos;_learner&apos;) as q:    q.query()</code></pre><p>执行结果：</p><pre><code>BeginQuery info about _learner...End</code></pre><p>很多时候，我们希望在某段代码执行前后自动执行特定代码，也可以用@contextmanager实现。例如：</p><pre><code>@contextmanagerdef tag(name):    print(&quot;&lt;%s&gt;&quot; % name)    yield    print(&quot;&lt;/%s&gt;&quot; % name)with tag(&quot;h1&quot;):    print(&quot;hello&quot;)    print(&quot;world&quot;)</code></pre><p>上述代码执行结果为：</p><pre><code>&lt;h1&gt;helloworld&lt;/h1&gt;</code></pre><p>代码的执行顺序是：</p><ol><li>with语句首先执行yield之前的语句，因此打印出<h1\>；</h1\></li><li>yield调用会执行with语句内部的所有语句，因此打印出hello和world；</li><li>最后执行yield之后的语句，打印出。</li></ol><p>因此，@contextmanager让我们通过编写generator来简化上下文管理。</p><h2 id="closing"><a href="#closing" class="headerlink" title="@closing"></a>@closing</h2><p>如果一个对象没有实现上下文，我们就不能把它用于with语句。这个时候，可以用closing()来把该对象变为上下文对象。例如，用with语句使用urlopen()：</p><pre><code>from contextlib import closingfrom urllib.request import urlopenwith closing(urlopen(&apos;https://www.python.org&apos;)) as page:    for line in page:        print(line)</code></pre><p><strong>closing</strong>也是一个经过<strong>@contextmanager</strong>装饰的generator，这个generator编写起来其实非常简单：</p><pre><code>@contextmanagerdef closing(thing):    try:        yield thing    finally:        thing.close()</code></pre><p>重写上面的例子：</p><pre><code>from contextlib import  contextmanagerfrom urllib.request import urlopen@contextmanagerdef closing(thing):    try:        yield thing    finally:        thing.close()with closing(urlopen(&apos;https://www.python.org&apos;)) as page:    for line in page:        print(line)</code></pre><p>它的作用就是把任意对象变为上下文对象，并支持with语句。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是上下文管理器&quot;&gt;&lt;a href=&quot;#什么是上下文管理器&quot; class=&quot;headerlink&quot; title=&quot;什么是上下文管理器&quot;&gt;&lt;/a&gt;什么是上下文管理器&lt;/h1&gt;&lt;p&gt;上下文管理器顾名思义是管理上下文的,也就是负责冲锋和垫后,而让主人专心完成自己的事情。我们在编写程序的时候，通常会将一系列操作放到一个语句块中，当某一条件为真时执行该语句快。有时候，我们需要再执行一个语句块时保持某种状态，并且在离开语句块后结束这种状态。例如对文件的操作，我们在打开一个文件进行读写操作时需要保持文件处于打开状态，而等操作完成之后要将文件关闭。所以，上下文管理器的任务是：代码块执行前准备，代码块执行后收拾。上下文管理器是在Python2.5加入的功能，它能够让你的代码可读性更强并且错误更少。&lt;/p&gt;
&lt;p&gt;需求的产生&lt;br&gt;在正常的管理各种系统资源(文件、锁定和连接)，在涉及到异常时通常是个棘手的问题。异常很可能导致控制流跳过负责释放关键资源的语句。例如打开一个文件进行操作时，如果意外情况发生（磁盘已满、特殊的终端信号让其终止等），就会抛出异常，这样可能最后的文件关闭操作就不会执行。如果这样的问题频繁出现，则可能耗尽系统资源。&lt;/p&gt;
&lt;p&gt;是的，这样的问题并不是不可避免。在没有接触到上下文管理器之前，我们可以用“try/finally”语句来解决这样的问题。或许在有些人看来，“try/finally”语句显得有些繁琐。上下文管理器就是被设计用来简化“try/finally”语句的，这样可以让程序更加简洁。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://waisunny.com/categories/Python/"/>
    
    
      <category term="python基础" scheme="http://waisunny.com/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>python黑魔法——迭代器与生成器</title>
    <link href="http://waisunny.com/2017/12/19/python%E9%BB%91%E9%AD%94%E6%B3%95%E2%80%94%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <id>http://waisunny.com/2017/12/19/python黑魔法—迭代器与生成器/</id>
    <published>2017-12-18T17:44:06.000Z</published>
    <updated>2017-12-24T10:01:32.048Z</updated>
    
    <content type="html"><![CDATA[<p>在了解Python的数据结构时，容器(container)、可迭代对象(iterable)、迭代器(iterator)、生成器(generator)、列表/集合/字典推导式(list,set,dict comprehension)众多概念参杂在一起，难免让初学者一头雾水，我将用一篇文章试图将这些概念以及它们之间的关系捋清楚。<br><img src="https://i.imgur.com/RLHjcHO.png" alt=""></p><h1 id="容器-container"><a href="#容器-container" class="headerlink" title="容器(container)"></a>容器(container)</h1><p>容器是一种把多个元素组织在一起的数据结构，容器中的元素可以逐个地迭代获取，可以用in, not in关键字判断元素是否包含在容器中。通常这类数据结构把所有的元素存储在内存中（也有一些特例，并不是所有的元素都放在内存，比如迭代器和生成器对象）在Python中，常见的容器对象有：</p><p>list, deque, ….</p><p>set, frozensets, ….</p><p>dict, defaultdict, OrderedDict, Counter, ….</p><p>tuple, namedtuple, …</p><p>str</p><p># </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在了解Python的数据结构时，容器(container)、可迭代对象(iterable)、迭代器(iterator)、生成器(generator)、列表/集合/字典推导式(list,set,dict comprehension)众多概念参杂在一起，难免让初学者一头雾水，我
      
    
    </summary>
    
      <category term="Python" scheme="http://waisunny.com/categories/Python/"/>
    
    
      <category term="python基础" scheme="http://waisunny.com/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>python函数式编程</title>
    <link href="http://waisunny.com/2017/12/15/python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>http://waisunny.com/2017/12/15/python函数式编程/</id>
    <published>2017-12-15T11:03:42.000Z</published>
    <updated>2018-01-07T10:40:02.750Z</updated>
    
    <content type="html"><![CDATA[<p>函数式编程是使用一系列函数去解决问题，按照一般编程思维，面对问题时我们的思考方式是“怎么干”，而函数函数式编程的思考方式是我要“干什么”。 </p><p>Python 不是也不大可能会成为一种函数式编程语言，但是它支持许多有价值的函数式编程语言构建。<br><a id="more"></a></p><p>#lambda表达式(匿名函数)</p><p>语法：</p><pre><code>lambda [arg1[,arg2,....argN]]: expression</code></pre><p>定义一个计算两个数乘积的函数,并返回结果值：</p><p>普通函数定义方式：</p><pre><code>def funcTake(a,b):    return a*b&gt;&gt;&gt; funcTake(2,3)6</code></pre><p>匿名函数定义方式：</p><pre><code>&gt;&gt;&gt; funcTake=lambda a,b:a*b #定义一个匿名函数并将函数赋值给变量funcTake&gt;&gt;&gt; funcTake(2,4)8</code></pre><p>匿名函数和普通函数一样，可以不带参数，也支持默认参数，可变参数，关键字参数等。</p><pre><code>&gt;&gt;&gt; func=lambda:True  #无参数&gt;&gt;&gt; func&lt;function &lt;lambda&gt; at 0x000001CC2BAEA510&gt;&gt;&gt;&gt; func()True&gt;&gt;&gt; func=lambda a,b=5:a*b #默认参数&gt;&gt;&gt; func(2)10&gt;&gt;&gt; func=lambda a,*args,**kw:[ a* i for i in args if i in kw.values()] #可变参数和关键字参数&gt;&gt;&gt; func(3,2,3,num=2,num2=5)[6]</code></pre><p>#高阶函数</p><p>变量可以指向函数；函数的参数可以接收变量；一个函数可以接收另一个函数作为参数的函数就是高阶函数。</p><pre><code>def funcA(a,b):    return a+bfun=funcA #将函数赋值给变量，其实就是给函数funcA()增加了一个引用。&gt;&gt;&gt; fun(2,3)5def funcB(num1,num2,func):#将函数作为参数传入    return func(num1,num2)&gt;&gt;&gt; funcB(2,3,funcA)5</code></pre><p>下面介绍四个内置的高阶函数。</p><h2 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h2><p>语法：</p><pre><code>filter(func,seq)</code></pre><p>调用一个布尔函数 func 来迭代遍历每个 seq 中的元素； p返回一个使 func 返回值为 ture 的元素构成的filter对象。python2中返回的是一个过滤后的序列。</p><p>用代码的形式阐述filter函数的实现机制：</p><pre><code>def filter(bool_func,seq):    filtered_seq=[]    for item in seq:        if bool_func(item):            filtered_seq.append(item)    return filtered_seq</code></pre><p>下面我们用filter()函数过滤掉1~10以内的所有偶数：</p><pre><code>&gt;&gt;&gt; def odd(num):...     return num%2...&gt;&gt;&gt; result=filter(odd,range(1,11))&gt;&gt;&gt; result&lt;filter object at 0x000001CC2BB1A390&gt;&gt;&gt;&gt; list(result)[1, 3, 5, 7, 9]</code></pre><p>上面的例子可以用lambda表达式一句话搞定：</p><pre><code>&gt;&gt;&gt; result=filter(lambda num :num%2,range(1,11))&gt;&gt;&gt; result&lt;filter object at 0x0000011EE27AF9E8&gt;&gt;&gt;&gt; list(result)[1, 3, 5, 7, 9]</code></pre><h2 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h2><p>语法：</p><pre><code>map(func, seq1[,seq2...])</code></pre><p>将函数 func 作用于给定序列（s)的每个元素，并用一个列表来提供返回值；python2中如果 func 为 None， func 表现为一个身份函数，返回一个含有每个序列中元素集合的 n 个元组的列表。</p><font color="red">python2中返回一个新的列表，<strong>注意是列表不是序列</strong> ，而python3中返回的是一个map对象。</font><p>用代码的形式阐述map函数的实现机制：</p><pre><code>def map(func,seq):    mapped_seq=[]    for item in seq:        mapped_seq.append(func(item))    return mapped_seq</code></pre><p>看个简单的例子：</p><pre><code>&gt;&gt;&gt; result=map((lambda x: x+2), [0, 1, 2, 3, 4, 5])&gt;&gt;&gt; result&lt;map object at 0x0000011EE27DA438&gt;&gt;&gt;&gt; list(result)[2, 3, 4, 5, 6, 7]</code></pre><p>把列表所有数字转为字符串：</p><pre><code>&gt;&gt;&gt; result=map(str,[1,2,3,4,5,6])&gt;&gt;&gt; list(result)[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;]</code></pre><p>map()函数作用于多个序列：</p><pre><code>&gt;&gt;&gt; result=map(lambda x,y:x+y,[1,3,5],[2,4,6])&gt;&gt;&gt; list(result)[3, 7, 11]&gt;&gt;&gt; result=map(lambda x,y:(x+y,x-y),[1,3,5],[2,4,6])&gt;&gt;&gt; list(result)[(3, -1), (7, -1), (11, -1)]</code></pre><p>另外，python2中map()函数支持None参数</p><pre><code>&gt;&gt;&gt; result=map(None,[1,3,5],[2,4,6])  #结果等价于zip()函数&gt;&gt;&gt; result[(1, 2), (3, 4), (5, 6)]</code></pre><p>python3中不在支持None参数：</p><pre><code>&gt;&gt;&gt; result=map(None,[1,3,5],[2,4,6])&gt;&gt;&gt; list(result)Traceback (most recent call last):File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: &apos;NoneType&apos; object is not callable</code></pre><h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h2><p>语法:</p><pre><code>reduce(func, seq[, init])</code></pre><p>它通过取出序列的头两个元素，将他们传入二元函数来获得一个单一的值来实现。然后又用这<br>个值和序列的下一个元素来获得又一个值，然后继续直到整个序列的内容都遍历完毕以及最后的值<br>会被计算出来为止；如果初始值 init 给定，第一个比较会是 init 和第一个序列元素而不是序列的头两个元素。</p><font color="red">在Python 3里,reduce()函数已经被从全局名字空间里移除了，它现在被放置在fucntools模块里 用的话要先引入。</font><p>用代码的形式阐述reduce函数的实现机制：</p><pre><code>def reduce(bin_func,seq,init=None):    Iseq=list(seq)    if init is None:        res=lseq.pop(0) #获取第一个元素并移除。    else:        res=init    for item in Iseq:        res=bin_func(res,item)    return res</code></pre><p>简单的例子，计算1~100的和：</p><pre><code>&gt;&gt;&gt; from functools import reduce&gt;&gt;&gt; result=reduce(lambda x,y:x+y,range(1,101))&gt;&gt;&gt; result5050&gt;&gt;&gt; result=reduce(lambda x,y:x+y,range(1,101),1)&gt;&gt;&gt; result5051</code></pre><h2 id="sorted"><a href="#sorted" class="headerlink" title="sorted()"></a>sorted()</h2><p>sorted()也是一个高阶函数。用sorted()排序的关键在于实现一个映射函数。</p><p>python3中用法如下：</p><p>语法:</p><pre><code>sorted(iterable[, key][, reverse]) </code></pre><p>sorted的第一个参数是一个迭代器，第二个参数是用来排序的key，第三个参数的排序顺序：正序还是倒序。</p><p>第一个参数是迭代器：</p><pre><code>&gt;&gt;&gt; sorted([36, 5, -12, 9, -21])[-21, -12, 5, 9, 36]</code></pre><p>第二个参数是用来排序的key：</p><pre><code>&gt;&gt;&gt; sorted([36, 5, -12, 9, -21], key=abs)[5, 9, -12, -21, 36]</code></pre><p>key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序。</p><p>第三个参数决定正向还是反向排序，要进行反向排序，可以传入第三个参数reverse=True：</p><pre><code>&gt;&gt;&gt; sorted([&apos;bob&apos;, &apos;about&apos;, &apos;Zoo&apos;, &apos;Credit&apos;], key=str.lower, reverse=True)[&apos;Zoo&apos;, &apos;Credit&apos;, &apos;bob&apos;, &apos;about&apos;] #忽略大小写反序排列</code></pre><p>python2中的用法如下：</p><p>语法：</p><pre><code>sorted(iterable[,cmp][, key][, reverse]) #多了一个cmp参数。</code></pre><p>看一个例子:</p><pre><code>def reversed_cmp(x, y):    if x &gt; y:        return -1    if x &lt; y:        return 1    return 0&gt;&gt;&gt; sorted([2,5,6,2,1,3],reversed_cmp) #倒序排[6,5,3,2,2,1]</code></pre><p>其他参数与python3中的用法一致。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最后我们可以看到，函数式编程有如下好处：</p><ol><li>代码更简单了。</li><li>数据集，操作，返回值都放到了一起。</li><li>你在读代码的时候，没有了循环体，于是就可以少了些临时变量，以及变量倒来倒去逻辑。</li><li>你的代码变成了在描述你要干什么，而不是怎么去干。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;函数式编程是使用一系列函数去解决问题，按照一般编程思维，面对问题时我们的思考方式是“怎么干”，而函数函数式编程的思考方式是我要“干什么”。 &lt;/p&gt;
&lt;p&gt;Python 不是也不大可能会成为一种函数式编程语言，但是它支持许多有价值的函数式编程语言构建。&lt;br&gt;
    
    </summary>
    
      <category term="python" scheme="http://waisunny.com/categories/python/"/>
    
    
      <category term="python基础" scheme="http://waisunny.com/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>python函数参数总结</title>
    <link href="http://waisunny.com/2017/12/13/python%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E6%80%BB%E7%BB%93/"/>
    <id>http://waisunny.com/2017/12/13/python函数参数总结/</id>
    <published>2017-12-13T11:03:42.000Z</published>
    <updated>2018-01-05T03:13:56.897Z</updated>
    
    <content type="html"><![CDATA[<p>定义函数的时候，我们把参数的名字和位置确定下来，函数的接口定义就完成了。对于函数的调用者来说，只需要知道如何传递正确的参数，以及函数将返回什么样的值就够了，函数内部的复杂逻辑被封装起来，调用者无需了解。</p><p>Python的函数定义非常简单，但灵活度却非常大。除了正常定义的必选参数外，还可以使用默认参数、可变参数和关键字参数，使得函数定义出来的接口，不但能处理复杂的参数，还可以简化调用者的代码。<br><a id="more"></a></p><p>#位置参数<br>我们定义一个计算x*y的函数：</p><pre><code>def power(x,y):    return x*y</code></pre><p>对于power(x)函数，参数x,y就是位置参数。</p><p>调用power函数时，必须传入两个参数x,y：</p><pre><code>&gt;&gt;&gt; power(5,4)20&gt;&gt;&gt; power(15,2)30</code></pre><p>#默认参数</p><p>我们定义一个显示学生信息的函数:</p><pre><code>def showSudentInfo(name,age=20):    print(&apos;{}:{}&apos;.format(name,age))</code></pre><p>调用函数时必须传入name参数而age参数是可选的：</p><pre><code>&gt;&gt;&gt; showSudentInfo(&apos;_learner&apos;)_learner:20&gt;&gt;&gt; showSudentInfo(&apos;jack&apos;,18)jack:18</code></pre><p>说明：大部分学生的年龄都是20岁，所以我们设置age参数的默认值是20，这样就简化了函数的调用，另外，设置默认参数需要注意几点：</p><ol><li><p>必选参数在前，默认参数在后，否则Python的解释器会报错（思考一下为什么默认参数不能放在必选参数前面）；</p></li><li><p>如何设置默认参数。</p><ol><li>当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。</li><li>使用默认参数有什么好处？最大的好处是能降低调用函数的难度。</li></ol></li></ol><font color="red">但是，默认参数使用不当会掉坑里，最大的坑，看下面这个列子：</font><pre><code>def func(li=[]):    li.append(&apos;end&apos;)    return li</code></pre><p>调用函数：</p><pre><code>&gt;&gt;&gt; func([1,2,3])[1, 2, 3, &apos;end&apos;]&gt;&gt;&gt; func()[&apos;end&apos;]&gt;&gt;&gt; func()[&apos;end&apos;, &apos;end&apos;]&gt;&gt;&gt; func()[&apos;end&apos;, &apos;end&apos;,&apos;end&apos;]</code></pre><p>由结果可知，前两次调用一切正常，当连续使用默认参数的形式调用的时候结果不对了，按我们理解的后两次func()调用 输出的结果应该也是[‘end’]，为啥不是呢？</p><p>原因是这样的：python函数在定义的时候，默认参数L的值就被计算出来了，即[]，[]所占用的内存地址也不会变了，除非重新赋值，因为[]是一个可变对象，每次给他li.append(‘end’)添加值，只是改变了其值，其所指向的对象地址没有变。所以多次调用func()操作的是同一个li,所以就出现了上述情况。</p><p>修改一下这个例子,输出id值：</p><pre><code>def func(li=[]):    li.append(&apos;end&apos;)    print(id(li))    return li</code></pre><p>调用函数：</p><pre><code>&gt;&gt;&gt; func([1,2,3])1497991838664[1, 2, 3, &apos;end&apos;]&gt;&gt;&gt; func()1497991837896[&apos;end&apos;]&gt;&gt;&gt; func()1497991837896[&apos;end&apos;, &apos;end&apos;]&gt;&gt;&gt; func()1497991837896[&apos;end&apos;, &apos;end&apos;,&apos;end&apos;]</code></pre><p>能看出，后面三次调用操作的是同一个对象li。</p><font color="red">定义默认参数要牢记一点：默认参数必须指向不变对象！</font><p>上述列子的改进方案：</p><pre><code>def func(li=None):    if not li:        li=[]    li.append(&apos;end&apos;)    return li</code></pre><p>调用函数：</p><pre><code>&gt;&gt;&gt; func([1,2,3])[1, 2, 3, &apos;end&apos;]&gt;&gt;&gt; func()[&apos;end&apos;]&gt;&gt;&gt; func()[&apos;end&apos;, &apos;end&apos;]&gt;&gt;&gt; func()[&apos;end&apos;, &apos;end&apos;,&apos;end&apos;]</code></pre><p>#可变参数</p><p>顾名思义，可变参数就是传入的参数个数是可变的，可以是1个、2个到任意个，还可以是0个。</p><p>定义可变参数在参数前面加了一个*号。在函数内部，参数numbers接收到的是一个tuple。</p><pre><code>def func(*numbers):    sum=0    for num in numbers:        sum=sum+num    return sum</code></pre><p>调用函数：</p><pre><code>&gt;&gt;&gt; func(1,2,3)6&gt;&gt;&gt; tup=(1,3,5,8)&gt;&gt;&gt; func(*tup)17&gt;&gt;&gt; li=[1,3,5,8]&gt;&gt;&gt; func(*li)17</code></pre><p>#关键字参数</p><p>可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。请看示例：</p><pre><code>def person(name, age, **kw):    print(&apos;name:&apos;, name, &apos;age:&apos;, age, &apos;other:&apos;, kw)</code></pre><p>函数person除了必选参数name和age外，还接受关键字参数kw。在调用该函数时，可以只传入必选参数：</p><pre><code>&gt;&gt;&gt; person(&apos;Michael&apos;, 30)name: Michael age: 30 other: {}</code></pre><p>也可以传入任意个数的关键字参数：</p><pre><code>&gt;&gt;&gt; person(&apos;Bob&apos;, 35, city=&apos;Beijing&apos;)name: Bob age: 35 other: {&apos;city&apos;: &apos;Beijing&apos;}&gt;&gt;&gt; person(&apos;Adam&apos;, 45, gender=&apos;M&apos;, job=&apos;Engineer&apos;)name: Adam age: 45 other: {&apos;gender&apos;: &apos;M&apos;, &apos;job&apos;: &apos;Engineer&apos;}</code></pre><p>关键字参数有什么用？它可以扩展函数的功能。比如，在person函数里，我们保证能接收到name和age这两个参数，但是，如果调用者愿意提供更多的参数，我们也能收到。试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。</p><p>和可变参数类似，也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去：</p><pre><code>&gt;&gt;&gt; extra = {&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;}&gt;&gt;&gt; person(&apos;Jack&apos;, 24, **extra)name: Jack age: 24 other: {&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;}</code></pre><font color="red">**extra表示把extra这个dict的所有key-value用关键字参数传入到函数的**kw参数，kw将获得一个dict，注意kw获得的dict是extra的一份拷贝，对kw的改动不会影响到函数外的extra。</font><p>#命名关键字参数</p><p>如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数。这种方式定义的函数如下：</p><pre><code>def person(name, age, *, city, job):    print(name, age, city, job)</code></pre><p>和关键字参数<em>*kw不同，命名关键字参数需要一个特殊分隔符</em>，*后面的参数被视为命名关键字参数。</p><p>调用方式如下：</p><pre><code>&gt;&gt;&gt; person(&apos;Jack&apos;, 24, city=&apos;Beijing&apos;, job=&apos;Engineer&apos;)Jack 24 Beijing Engineer</code></pre><p>如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了：</p><pre><code>def person(name, age, *args, city, job):    print(name, age, args, city, job)</code></pre><p>调用方式如下：</p><pre><code>&gt;&gt;&gt; person(&apos;_learner&apos;, 23, &apos;酷爱Python&apos;,city=&apos;北京&apos;,job=&apos;程序员&apos;)_learner 23 (&apos;酷爱Python&apos;,) 北京 程序员</code></pre><p>命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错：</p><pre><code>&gt;&gt;&gt; person(&apos;Jack&apos;, 24, &apos;Beijing&apos;, &apos;Engineer&apos;)Traceback (most recent call last):File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: person() takes 2 positional arguments but 4 were given</code></pre><p>由于调用时缺少参数名city和job，Python解释器把这4个参数均视为位置参数，但person()函数仅接受2个位置参数。</p><p>命名关键字参数可以有缺省值，从而简化调用：</p><pre><code>def person(name, age, *, city=&apos;Beijing&apos;, job):    print(name, age, city, job)</code></pre><p>由于命名关键字参数city具有默认值，调用时，可不传入city参数：</p><pre><code>&gt;&gt;&gt; person(&apos;Jack&apos;, 24, job=&apos;Engineer&apos;)Jack 24 Beijing Engineer</code></pre><h1 id="参数组合"><a href="#参数组合" class="headerlink" title="参数组合"></a>参数组合</h1><p>在Python中定义函数，可以用必选(位置)参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选(位置)参数、默认参数、可变参数、命名关键字参数和关键字参数。</p><p>比如定义一个函数，包含上述若干种参数：</p><pre><code>def f1(a, b, c=0, *args, **kw):    print(&apos;a =&apos;, a, &apos;b =&apos;, b, &apos;c =&apos;, c, &apos;args =&apos;, args, &apos;kw =&apos;, kw)def f2(a, b, c=0, *, d, **kw):    print(&apos;a =&apos;, a, &apos;b =&apos;, b, &apos;c =&apos;, c, &apos;d =&apos;, d, &apos;kw =&apos;, kw)</code></pre><p>在函数调用的时候，Python解释器自动按照参数位置和参数名把对应的参数传进去。</p><pre><code>&gt;&gt;&gt; f1(1, 2)a = 1 b = 2 c = 0 args = () kw = {}&gt;&gt;&gt; f1(1, 2, c=3)a = 1 b = 2 c = 3 args = () kw = {}&gt;&gt;&gt; f1(1, 2, 3, &apos;a&apos;, &apos;b&apos;)a = 1 b = 2 c = 3 args = (&apos;a&apos;, &apos;b&apos;) kw = {}&gt;&gt;&gt; f1(1, 2, 3, &apos;a&apos;, &apos;b&apos;, x=99)a = 1 b = 2 c = 3 args = (&apos;a&apos;, &apos;b&apos;) kw = {&apos;x&apos;: 99}&gt;&gt;&gt; f2(1, 2, d=99, ext=None)a = 1 b = 2 c = 0 d = 99 kw = {&apos;ext&apos;: None}</code></pre><p>最神奇的是通过一个tuple和dict，你也可以调用上述函数：</p><pre><code>&gt;&gt;&gt; args = (1, 2, 3, 4)&gt;&gt;&gt; kw = {&apos;d&apos;: 99, &apos;x&apos;: &apos;#&apos;}&gt;&gt;&gt; f1(*args, **kw)a = 1 b = 2 c = 3 args = (4,) kw = {&apos;d&apos;: 99, &apos;x&apos;: &apos;#&apos;}&gt;&gt;&gt; args = (1, 2, 3)&gt;&gt;&gt; kw = {&apos;d&apos;: 88, &apos;x&apos;: &apos;#&apos;}&gt;&gt;&gt; f2(*args, **kw)a = 1 b = 2 c = 3 d = 88 kw = {&apos;x&apos;: &apos;#&apos;}</code></pre><font color="red">所以，对于任意函数，都可以通过类似func(<em>args, *</em>kw)的形式调用它，无论它的参数是如何定义的。<br>虽然可以组合多达5种参数，但不要同时使用太多的组合，否则函数接口的可理解性很差。</font>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;定义函数的时候，我们把参数的名字和位置确定下来，函数的接口定义就完成了。对于函数的调用者来说，只需要知道如何传递正确的参数，以及函数将返回什么样的值就够了，函数内部的复杂逻辑被封装起来，调用者无需了解。&lt;/p&gt;
&lt;p&gt;Python的函数定义非常简单，但灵活度却非常大。除了正常定义的必选参数外，还可以使用默认参数、可变参数和关键字参数，使得函数定义出来的接口，不但能处理复杂的参数，还可以简化调用者的代码。&lt;br&gt;
    
    </summary>
    
      <category term="python" scheme="http://waisunny.com/categories/python/"/>
    
    
      <category term="python基础" scheme="http://waisunny.com/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>解决RabbitMq无法接收消息的问题</title>
    <link href="http://waisunny.com/2017/12/03/%E8%A7%A3%E5%86%B3RabbitMq%E6%97%A0%E6%B3%95%E6%8E%A5%E6%94%B6%E6%B6%88%E6%81%AF%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://waisunny.com/2017/12/03/解决RabbitMq无法接收消息的问题/</id>
    <published>2017-12-02T17:18:57.000Z</published>
    <updated>2018-01-04T03:04:24.334Z</updated>
    
    <content type="html"><![CDATA[<p>前两天在产品迭代过程中遇到一个问题，再往RabbitMQ发送消息的时候，消息无法进入到队列里；</p><p>最开始，我以为是服务瞬间消费掉了，消费端出现了啥问题导致被消费的消息没进入到数据库中，但是，我分析消费端代码和异常信息，都没有发现消费端有啥问题；</p><p>于是，我先把RabbitMQ消费端停掉，继续发送消息，发现消息压根就没进入到队列里，刨除掉了消费端的问题；然后接着分析发送端代码，感觉一切也ok呀，没有啥问题；刨除掉自己代码的问题，那只有一种可能会不会是RabbitMQ服务出问题了，不接受消息了…<br><a id="more"></a></p><p>然后，查看RabbitMQ服务器内存、CPU、磁盘后发现，内存、CPU指标正常，磁盘的剩余空间只剩下500M左右，通过RabbitMQ网站发现另一个队列堆积了大量的消息并且没有消费端，找到了相应的负责人后，把消息处理掉，瞬间就好使了。附上一张图：<br><img src="https://i.imgur.com/CKuo2o2.png" alt=""><br>当途中圈出来的变成<font color="red">红色</font>的时候说明你的磁盘空间不够用了，估计就是消息堆积导致的.</p><p>另外：正常情况在生产环境下都会设置报警机制，RabbitMQ服务端默认配置是当内存使用达到40%，磁盘空闲空间小于50M，即启动内存报警，磁盘报警；由于我上述问题是在测试环境下遇到的，测试环境没有设置报警机制。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前两天在产品迭代过程中遇到一个问题，再往RabbitMQ发送消息的时候，消息无法进入到队列里；&lt;/p&gt;
&lt;p&gt;最开始，我以为是服务瞬间消费掉了，消费端出现了啥问题导致被消费的消息没进入到数据库中，但是，我分析消费端代码和异常信息，都没有发现消费端有啥问题；&lt;/p&gt;
&lt;p&gt;于是，我先把RabbitMQ消费端停掉，继续发送消息，发现消息压根就没进入到队列里，刨除掉了消费端的问题；然后接着分析发送端代码，感觉一切也ok呀，没有啥问题；刨除掉自己代码的问题，那只有一种可能会不会是RabbitMQ服务出问题了，不接受消息了…&lt;br&gt;
    
    </summary>
    
      <category term="消息队列" scheme="http://waisunny.com/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
      <category term="RabbitMQ" scheme="http://waisunny.com/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>python之异常处理</title>
    <link href="http://waisunny.com/2017/11/27/python%E4%B9%8B%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>http://waisunny.com/2017/11/27/python之异常处理/</id>
    <published>2017-11-26T17:19:07.000Z</published>
    <updated>2017-12-23T14:28:41.204Z</updated>
    
    <content type="html"><![CDATA[<p>在谈如何处理python中的异常前，我们先来明白两个概念–&gt;<strong>错误和异常</strong>。</p><p><strong>错误</strong>：从软件方面来说, 错误是语法或是逻辑上的。语法错误指示软件的结构上有错误, 导致不能被解释器解释或编译器无法编译。 这些错误必须在程序执行前纠正。当程序的语法正确后, 剩下的就是逻辑错误了. 逻辑错误可能是由于不完整或是不合法的输入所致; 在其他情况下, 还可能是逻辑无法生成, 计算, 或是输出结果需要的过程无法执行。这些错误通常分别被称为域错误和范围错误。当 Python 检测到一个错误时, 解释器就会指出当前流已经无法继续执行下去. 这时候就出现了异常。</p><p><strong>异常</strong>：对异常的最好描述是: 它是因为程序出现了错误而在正常控制流以外采取的行为. 这个行为又分为两个阶段: 首先是引起异常发生的错误, 然后是检测(和采取可能的措施)阶段即处理异常阶段。<br><a id="more"></a></p><h1 id="python中的异常"><a href="#python中的异常" class="headerlink" title="python中的异常"></a>python中的异常</h1><p>所有的标准/内建异常都是从根异常派生的.目前,有 3 个直接从 BaseException 派生的异常子<br>类:SystemExit,KeyboardInterrupt 和 Exception。 </p><p>SystemExit：python解释器请求退出。</p><p>KeyboardInterrupt：用户中断执行(通常是输入^C)。</p><p>Exception 常规语法错误；所有的内建异常都是其子类。</p><p><strong>列举几个最常用的内建异常：</strong></p><p><strong>NameError</strong>:尝试访问一个未声明的变量</p><p><strong>ZeroDivisionError</strong>: 除数为零</p><p><strong>SyntaxError</strong>: Python 语法错误（SyntaxError 异常是唯一不是在运行时发生的异常. 它代表 Python 代码中有一个不正确的结构, 在它改正之前程序无法执行）</p><p><strong>IndexError</strong>:请求的索引超出序列范围</p><p><strong>KeyError</strong>:请求一个不存在的字典关键字</p><p><strong>IOError</strong>: 输入/输出错误</p><p><strong>AttributeError</strong>: 尝试访问未知的对象属性</p><h1 id="检测和处理异常"><a href="#检测和处理异常" class="headerlink" title="检测和处理异常"></a>检测和处理异常</h1><p>使用try语句来检测异常。try 语句有两种主要形式: try-except 和 try-finally。这两个语句是互斥的, 也就是说你只能使用其中的一种. 一个 try 语句可以对应一个或多个 except 子句, 但只能对应一个finally 子句, 或是一个 try-except-finally 复合语句。</p><p>另外值得说明的是，python中的try语句支持else语句，</p><p>接下来看几个例子：</p><p>1.try-except语句</p><pre><code>try:    x=int(input(&apos;input x:&apos;))    y=int(input(&apos;input y:&apos;))    print(&apos;x/y=%.2f&apos;%(x/y))except ZeroDivisionError:    print(&apos;除数不能为0&apos;)</code></pre><p>2.带有多个except的try语句  </p><pre><code>try:      x = int(input(&apos;input x:&apos;))      y = int(input(&apos;input y:&apos;))      print(&apos;x/y = &apos;,x/y)  except ZeroDivisionError: #捕捉除0异常      print(&quot;ZeroDivision&quot;)  except TypeError as e: #捕捉类型异常并将异常对象输出      print(e) except ValueError as e: #捕捉值异常并将异常对象输出      print(e) </code></pre><p>3.处理多个异常的except语句（异常必须放在一个元组里）</p><pre><code>try:      x = int(input(&apos;input x:&apos;))      y = int(input(&apos;input y:&apos;))      print(&apos;x/y = &apos;,x/y)   except (TypeError,ValueError,ZeroDivisionError) as e: #捕捉多个异常，并将异常对象输出      print(e) </code></pre><p>4.try-except-else（在try范围中没有异常被检测到时，执行 else 子句）</p><pre><code>try:      x = int(input(&apos;input x:&apos;))      y = int(input(&apos;input y:&apos;))      print(&apos;x/y = &apos;,x/y)  except ZeroDivisionError as e: #捕捉除0异常      print(e)  else: #当try块中的语句没有发生异常完全执行成功时执行    print(&apos;it work well&apos;)  </code></pre><p>5.finally 语句（不管是否出现异常，最后都会执行finally的语句块内容，用于清理工作。所以，你可以在 finally 语句中关闭文件，这样就确保了文件能正常关闭）</p><pre><code>try:      x = int(input(&apos;input x:&apos;))      y = int(input(&apos;input y:&apos;))      print(&apos;x/y = &apos;,x/y)  except (TypeError,ValueError,ZeroDivisionError) as e: #捕捉多个异常      print(e)  else: #没有异常时执行      print(&apos;it work well&apos;)  finally: #不管是否有异常都会执行      print(&quot;Cleaning up&quot;)  </code></pre><p>6.捕获所有异常</p><pre><code>try:      x = int(input(&apos;input x:&apos;))      y = int(input(&apos;input y:&apos;))      print(&apos;x/y = &apos;,x/y)  except BaseException as e: #捕捉所有异常      print(e)  try:      x = int(input(&apos;input x:&apos;))      y = int(input(&apos;input y:&apos;))      print(&apos;x/y = &apos;,x/y)  except: #捕捉所有异常 这种方法不推荐     pass</code></pre><p>为什么用BaseException而不是Exception已经在文章开头说过。</p><p><strong>说明：</strong></p><ol><li>在python2中将异常对象输出支持使用exception,e这种语法，而在python3中不在支持，只能将‘,’换成 as 关键字。</li><li>当try语句中发生异常后，try语句中剩余的代码将不会在执行，当存在多个处理器（except字句）时，解释器将这一串解释器中查找匹配的异常，如果找到对应的处理器，执行流将会跳转到这里。</li><li>在使用finally语句时，如果 finally 中的代码引发了另一个异常或由于 return,break,continue 语<br>法而终止,原来的异常将丢失而且无法重新引发。</li><li>异常抛出之后，如果没有被接收，那么程序会抛给它的上一层，比如函数调用的地方，要是还是没有接收，那继续抛出，如果程序最后都没有处理这个异常，那它就丢给操作系统了 – 你的程序崩溃了，这点和C++一样的。</li></ol><h1 id="主动触发异常"><a href="#主动触发异常" class="headerlink" title="主动触发异常"></a>主动触发异常</h1><p>raise主动触发异常，我们可以使用raise语句自己触发异常</p><p>raise语法格式如下：</p><pre><code>raise [Exception [, args [, traceback]]]</code></pre><p>语句中Exception是异常的类型（例如，NameError）参数是一个异常参数值。该参数是可选的，如果不提供，异常的参数是”None”。最后一个参数是可选的（在实践中很少使用），如果存在，是跟踪异常对象。</p><pre><code>try:    raise TypeError(&apos;类型错误&apos;)except TypeError as e:    print(e)结果：类型错误</code></pre><h1 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h1><p>断言是一句必须等价于布尔真的判断，通过assert实现；断言语句如果成功不采取任何措施否则除法AssertionError(断言错误)的异常；用法如下：</p><pre><code>assert expression[,aeguments]</code></pre><p>AssertionError异常和其他的异常一样可以用try-except语句块捕捉,但是如果没有捕捉,它将<br>终止程序运行而且提供一个如下的 traceback：</p><pre><code>&gt;&gt;&gt; assert 1==0Traceback (most recent call last):File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;AssertionError</code></pre><p>使用try-except捕获AssertionError异常：</p><pre><code>&gt;&gt;&gt; try:...     assert 1==0,&apos;1!=0&apos;... except AssertionError as args:...     print(&apos;%s:%s&apos;%(args.__class__.__name__,args))...AssertionError:1!=0</code></pre><h1 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h1><p>自定义异常的前提是继承异常类，可以是基类异常（BaseException），也可以其他内建异常。</p><pre><code>&gt;&gt;&gt; class myException(Exception):...     def __init__(self,msg):...         self.msg=msg...     def __str__(self):...         return self.msg...&gt;&gt;&gt; try:...     raise myException(&apos;类型错误&apos;)... except myException as e:...     print(e)...类型错误</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在谈如何处理python中的异常前，我们先来明白两个概念–&amp;gt;&lt;strong&gt;错误和异常&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;错误&lt;/strong&gt;：从软件方面来说, 错误是语法或是逻辑上的。语法错误指示软件的结构上有错误, 导致不能被解释器解释或编译器无法编译。 这些错误必须在程序执行前纠正。当程序的语法正确后, 剩下的就是逻辑错误了. 逻辑错误可能是由于不完整或是不合法的输入所致; 在其他情况下, 还可能是逻辑无法生成, 计算, 或是输出结果需要的过程无法执行。这些错误通常分别被称为域错误和范围错误。当 Python 检测到一个错误时, 解释器就会指出当前流已经无法继续执行下去. 这时候就出现了异常。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;异常&lt;/strong&gt;：对异常的最好描述是: 它是因为程序出现了错误而在正常控制流以外采取的行为. 这个行为又分为两个阶段: 首先是引起异常发生的错误, 然后是检测(和采取可能的措施)阶段即处理异常阶段。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://waisunny.com/categories/Python/"/>
    
    
      <category term="python基础" scheme="http://waisunny.com/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>python之文件操作</title>
    <link href="http://waisunny.com/2017/11/25/python%E4%B9%8B%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <id>http://waisunny.com/2017/11/25/python之文件操作/</id>
    <published>2017-11-25T15:35:28.000Z</published>
    <updated>2018-01-03T02:17:52.136Z</updated>
    
    <content type="html"><![CDATA[<p>首先，学习python，掌握文件操作这一技能是必不可少的，本篇博文由浅入深，详细介绍python中操作文件的各种方法、各种方法之间的对比以及如何高效的读取文件等；另外，牢记文件操作的三个步骤：(1)打开文件;(2)操作文件(3)关闭文件。</p><a id="more"></a><h1 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h1><p>Python中的file()与open()都能够打开文件，对文件进行操作，也具有相似的用法和参数，并且返回的都是一个文件对象；但是，这两种文件打开方式有本质的区别，file是一个类，用file()来打开文件，相当于是在构造文件类；而用open()打开文件，是用python的内建函数来操作，这是不一样的，另外python3已经不再支持file()了；So，<font color="#FF0000" size="4"><strong>强烈建议使用open()函数</strong></font>。</p><h2 id="open"><a href="#open" class="headerlink" title="open()"></a>open()</h2><p>打开指定路径的文件，如果文件不存在会自动创建，返回一个文件对象。</p><pre><code>open(file[, mode[, buffering[, encoding[, errors[, newline[, closefd=True]]]]]])</code></pre><p>open函数有很多的参数，常用的是file，mode和encoding</p><ol><li>file：文件路径包含文件名，需要加引号</li><li>mode：文件打开模式，见下面3</li><li>encoding：表示的是返回的数据采用何种编码，一般采用utf8或者gbk；</li><li>buffering(可选):控制着文件的缓冲，如果参数是0(或者是False)，I/O(输人/输出)就是无缓冲的(所有的读写操作都直接针对硬盘); 如果是1(或者是true), I/O就是有缓冲的(意味着Python使用内存来代替硬盘，让程序更快，只有使用flush或者close时才会更新硬盘上的数据;如果是大于1的数字代表缓冲区的大小(单位是字节)；如果是-1(或者是任何负数)代表使用默认的缓冲区大小；使用默认时会采用下面策略来选择：对于二进制文件模式时，采用固定块内存缓冲区方式，内存块的大小根据系统设备的分配的磁盘块来决定，如果获取系统磁盘块的大小失败，就使用内部常量io.DEFAULT_BUFFER_SIZE定义的大小。一般的操作系统上，块的大小是4096或者8192字节大小。对于交互的文本文件（采用isatty()判断为True）时，采用一行缓冲区的方式。其它文本文件使用跟二进制一样的方式。</li></ol><h2 id="文件模式"><a href="#文件模式" class="headerlink" title="文件模式"></a>文件模式</h2><ol><li>‘r’：读模式</li><li>‘w’：写模式，会先清空文件内容</li><li>‘a’：追加模式</li><li>‘b’：二进制模式（可添加到其他模式中使用，如：’rb’：表示读取二进制文件）</li><li>‘+’：读/写模式（可添加到其他模式中使用）</li><li>‘a+’：可读写模式，写只能写在文件末尾</li><li>‘w+’：可读写，与’a+’的区别是要清空文件内容(<font color="#FF0000" size="3"><strong>不推荐使用</strong></font>)</li><li>‘r+’：可读写，与’a+’的区别是可以写到文件任何位置</li></ol><h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><pre><code>&gt;&gt;&gt; f=open(&apos;file.txt&apos;,&apos;r&apos;,encoding=&apos;utf-8&apos;)#以只读的模式打开一个文件，对读取的文件内容是utf-8编码。&gt;&gt;&gt; f=open(&apos;file.txt&apos;,&apos;r+&apos;,encoding=&apos;utf-8&apos;)#以读写的模式打开一个文件，对读取的文件内容是utf-8编码。&gt;&gt;&gt; f=open(&apos;file.txt&apos;,&apos;a&apos;,encoding=&apos;utf-8&apos;)#以追加的模式打开一个文件，对读取的文件内容是utf-8编码。</code></pre><h1 id="操作文件的方法"><a href="#操作文件的方法" class="headerlink" title="操作文件的方法"></a>操作文件的方法</h1><p><strong>示例文件内容：</strong></p><p><img src="https://i.imgur.com/RMzpzSy.png" alt=""></p><h2 id="读-read-reabline-readlines"><a href="#读-read-reabline-readlines" class="headerlink" title="读 read(),reabline(),readlines()"></a>读 read(),reabline(),readlines()</h2><pre><code>&gt;&gt;&gt; f=open(&apos;file.txt&apos;,&apos;r&apos;,encoding=&apos;gbk&apos;)&gt;&gt;&gt; f.read()#读取全部内容,返回一个字符串python 文件操作python 字符串语法python 列表元祖字典python 中的变量&gt;&gt;&gt; f.read(5)#读取指定长度的字符&gt;&gt;&gt; f.readline()#读取一行内容，返回一个 字符串&gt;&gt;&gt; f.readlines()#读取全部行，返回一个列表&gt;&gt;&gt; f.close()</code></pre><p>说明：上述代码第一个读取操作读取出了所有内容，剩下的读取到的都是空，原因是因为每执行一次读操作，都会记录下当前文件读取指针的位置，接下来的读操作是在上一次的读操作读取到的内容之后继续开始读取的。可以通过下面介绍的tell()方法获取当前指针所在位置，通过seek()方法设置指针位置。</p><h2 id="写-write-writelines"><a href="#写-write-writelines" class="headerlink" title="写 write(),writelines()"></a>写 write(),writelines()</h2><pre><code>&gt;&gt;&gt; f=open(&apos;file.txt&apos;,&apos;w&apos;,encoding=&apos;gbk&apos;)&gt;&gt;&gt; f.write(&apos;python人生&apos;)#接受字符串 作为参数&gt;&gt;&gt; f.writelines([&apos;python生活&apos;,&apos;python前世&apos;])#接受序列(字符串，列表，元祖)作为参数&gt;&gt;&gt; f.close()python人生python生活python前世</code></pre><p>说明：当以只写的模式打开文件的时候会先清空文件内容,另外多个连续写的操作也会有读操作时说到的光标注意事项；另外需要值得一提的时，写操作并不是直接把内容写到磁盘上，而是写到了缓冲区中即内存里。当调用f.close()方法时会把缓冲区的内容写入到磁盘</p><h2 id="关闭文件close"><a href="#关闭文件close" class="headerlink" title="关闭文件close()"></a>关闭文件close()</h2><p>close()方法时用来关闭文件的，这是一种很重要但是容易被忘记的操作，虽然说即使我们不直接调用close()方法，python解释器 也会在程序执行完是帮我们关闭文件，但是依赖于解释器来关闭文件的行为是不安全的，所以，一定要在操作完文件后调用close()方法来关闭文件；为了避免忘记关闭文件，推荐一种打开文件的方式：</p><pre><code>with open(&apos;log&apos;, &apos;r&apos;) as f:     f.readline()     f.read()print(&apos;hello&apos;)#同时操作多个文件with open(&apos;log1&apos;,&apos;r&apos;) as f_read, open(&apos;log2&apos;,&apos;w&apos;) as f_write:    for line in f_read:        f_write.write(line)</code></pre><p>说明：使用with语句操作文件会在with语句块执行完后自动调用close()方法关闭文件，推荐这种写法。</p><h2 id="flush"><a href="#flush" class="headerlink" title="flush"></a>flush</h2><p>flush() 方法是用来刷新缓冲区的，即将缓冲区中的数据立刻写入文件，同时清空缓冲区，不需要是被动的等待输出缓冲区写入。一般情况下，文件关闭后会自动刷新缓冲区，但有时你需要在关闭前刷新它，这时就可以使用 flush() 方法。</p><pre><code>file.flush()#没有返回值</code></pre><h2 id="tell-seek"><a href="#tell-seek" class="headerlink" title="tell(),seek()"></a>tell(),seek()</h2><h3 id="tell"><a href="#tell" class="headerlink" title="tell()"></a>tell()</h3><ol><li>作用：获取当前文件读取指针的位置</li><li>语法格式： file.tell() 注： 此方法没有参数</li></ol><h3 id="seek"><a href="#seek" class="headerlink" title="seek()"></a>seek()</h3><ol><li>作用：用于移动文件读写指针到指定位置</li><li>语法格式：file.seek(offset,whence=0)；(1) offset:偏移量，需要向前或者向后移动的字节数(中文是3个字节)，(2) 可选值，默认为0, 可选值为1或者2，表示从何处开始计算偏移，具体来说，0表示从当前位置开始计算偏移，1表示从文件头位置开始计算偏移，2表示从文件尾开始计算偏移。</li></ol><h3 id="代码展示"><a href="#代码展示" class="headerlink" title="代码展示"></a>代码展示</h3><pre><code>&gt;&gt;&gt; x = file(&apos;file.txt&apos;, &apos;r&apos;)   &gt;&gt;&gt; x.tell()           #获得当前文件读取指针  0L                     #当前文件指针在文件头处  &gt;&gt;&gt; x.seek(3)          #将文件指针向前移动3个字节  &gt;&gt;&gt; x.tell()  3L                     #指针已经移动到了第3个字节处  &gt;&gt;&gt; x.seek(5,1)        #表示从文件头处开始移动指针，向前移动5个字节  &gt;&gt;&gt; x.tell()                 5L                     #当前文件读取指针已经移动到第5个字节处  &gt;&gt;&gt; x.seek(0,0)        #表示将文件指针移动到文件头处  &gt;&gt;&gt; x.tell()  0L  &gt;&gt;&gt; x.seek(0,2)        #表示将文件读取指针移动到文件尾部  &gt;&gt;&gt; x.tell()                 214L                   #可以得到文件大小为214B  &gt;&gt;&gt; x.seek(-2,2)       #表示从文件尾部开始移动指针，向后移动2个字节  &gt;&gt;&gt; x.tell() 212L </code></pre><h1 id="高效迭代文件内容"><a href="#高效迭代文件内容" class="headerlink" title="高效迭代文件内容"></a>高效迭代文件内容</h1><p>方式一：</p><pre><code>with open(&apos;file.txt&apos;,&apos;r&apos;,encoding=&apos;gbk&apos;) as file:    for line in file.readlines():        do_things(line)</code></pre><p>方式二：</p><pre><code>with open(&apos;file.txt&apos;,&apos;r&apos;,encoding=&apos;gbk&apos;)as file:    line=file.readline()    while line:        line=file.readline()        do_things(line)</code></pre><p>方式三：</p><pre><code>with open(&apos;file.txt&apos;,&apos;r&apos;,encoding=&apos;gbk&apos;) as file:    for line in file:        do_things(line)</code></pre><p>说明：</p><p>第一种方式会一次性将文件中的内容加载到内存中然后对内存进行读操作。</p><p>第二种方式从磁盘上读取一条输出一条，不会将文件内容一次性加载到内存。</p><p>第三种方式直接迭代文件对象,for循环会把它当做一个迭代器，读取一行输出一行。</p><p>三种方式执行效率对比（<font color="#FF0000" size="5">本人测试数据，会有偏差</font>）：</p><ol><li>测试文件：1G的大文本文件；多次运行三种方式：第一种内存明显增加，执行时间在1分钟10秒左右；第二种内存没有增加，运行时间在1分钟15秒左右；第三种内存没有增加，运行时间在1分钟左右；</li><li>测试文件：15MB小文本文件;多次运行三种方式：第一种内存明显增加，执行时间在1.2秒左右；第二种内存没有增加，运行时间在1.6秒左右；第三种内存没有增加，运行时间在1.2秒左右；</li></ol><p>由此可知：小文本操作时，第二种方式执行相对较慢，不推荐使用，大文本操作时第一种方式会占用很大内存；另外无论是大文本操作还是小文本操作，第三种方式都是最节省内存执行时间最快的；So，极力推荐使用第三种方式</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上述介绍了基本的文件操作方式和一些注意事项，最后详细介绍了迭代文件内容最高效的方式，希望各位读者可以自己亲自动手尝试一些，这样会让你有更深层次的理解.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先，学习python，掌握文件操作这一技能是必不可少的，本篇博文由浅入深，详细介绍python中操作文件的各种方法、各种方法之间的对比以及如何高效的读取文件等；另外，牢记文件操作的三个步骤：(1)打开文件;(2)操作文件(3)关闭文件。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://waisunny.com/categories/Python/"/>
    
    
      <category term="python基础" scheme="http://waisunny.com/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>python深浅拷贝剖析</title>
    <link href="http://waisunny.com/2017/11/24/python%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%89%96%E6%9E%90/"/>
    <id>http://waisunny.com/2017/11/24/python深浅拷贝剖析/</id>
    <published>2017-11-24T13:07:50.000Z</published>
    <updated>2017-12-23T14:54:38.650Z</updated>
    
    <content type="html"><![CDATA[<p>在Python中一切都是对象，比如说:3, 3.14, ‘Hello’, [1,2,3,4],（’12’,5,6）,{‘a’:1}……，为什么会存在‘拷贝’这一概念，主要是因为python中的可变与不可变对象的存在。</p><p>拷贝概念的引入就是针对:可变对象的共享引用潜在的副作用而提出的。</p><p>共享引用（两个变量引用同一块内存空间）：</p><pre><code>&gt;&gt;&gt; list=[1,2,3]&gt;&gt;&gt; list2=list&gt;&gt;&gt; id(list)1624535010824&gt;&gt;&gt; id(list2)1624535010824</code></pre><a id="more"></a><h1 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h1><p>案列：假设你想创建一对小夫妻的通用档案，名为 person.然后你分别为他俩拷贝一份</p><pre><code>&gt;&gt;&gt; person=[&apos;name&apos;,[&apos;savings&apos;,100.00],&apos;JJ&apos;]&gt;&gt;&gt; hubby=person[:]#切片&gt;&gt;&gt; wifey=list(person)#工厂函数list()&gt;&gt;&gt; [id(x) for x in (person,hubby,wifey)][1689804830152, 1689804830856, 1689804999752]&gt;&gt;&gt; person[0]=&apos;Jack&apos;&gt;&gt;&gt; [x for x in (person,hubby,wifey)][[&apos;Jack&apos;, [&apos;savings&apos;, 100.0], &apos;JJ&apos;], [&apos;name&apos;, [&apos;savings&apos;, 100.0], &apos;JJ&apos;], [&apos;name&apos;, [&apos;savings&apos;, 100.0], &apos;JJ&apos;]]&gt;&gt;&gt; person[1][1]=60&gt;&gt;&gt; [x for x in (person,hubby,wifey)][[&apos;Jack&apos;, [&apos;savings&apos;, 60], &apos;JJ&apos;], [&apos;name&apos;, [&apos;savings&apos;, 60], &apos;JJ&apos;], [&apos;name&apos;, [&apos;savings&apos;, 60], &apos;JJ&apos;]]&gt;&gt;&gt;&gt;</code></pre><p>剖析：上面的例子中我们定义了一个列表person,然后使用切片方法和工厂函数list()生成了两个<strong>“新”</strong>列表，hubby和wifey；然后使用内建函数id()查看三个列表的id值,三个列表的id值均不同，这是为什么呢？然后，我们修改了person的第一个元素，发现只有person列表的值变化了，另外两个列表没有变化，但是当我们修改person(也可以是其他两个列表中的一个)的第二个元素的值时，三个列表都发生了变化，这是为啥子呢？</p><p>原因：我们仅仅做了一个<strong>浅拷贝</strong>。<font size="5" color="red">对一个对象进行浅拷贝其实是新创建了一个类型跟原对象一样,其内容是原来对象元素的引用的对象</font>,换句话说,这个拷贝的对象本身是新的（<strong>所以三个列表id值不同</strong>）,但是它的内容不是。序列类型对象的浅拷贝是默认类型拷贝,并可以以下几种方式实施:(1)切片操作[:],(2)利用工厂函数,比如 list(),dict()等,(3)使用 copy 模块的 copy 函数。</p><p>上面的解释貌似只解释了一个问题，第二个问题是为啥呢？</p><p>原因：在这几个列表的两个对象中,第一个对象是不可变的(是个字符串类型),而第二个是可变的(一个列表).正因为如此,当进行浅拷贝时,字符串被显式的拷贝,并新创建了一个字符串对象,而列表元素只是把它的引用复制了一下,并不是它的成员（<font size="4" color="red">简单的理解，浅拷贝只能拷贝一层</font>）。所以改变名字没有任何问题,但是更改他们银行账号的任何信息都会引发问题。</p><p>接下来我们看一下三个列表中，每个元素的id值的变化：</p><p>修改前：</p><pre><code>&gt;&gt;&gt; [id(x) for x in person][1689774975888, 1689804999944, 1689804828320]&gt;&gt;&gt; [id(x) for x in hubby][1689774975888, 1689804999944, 1689804828320]&gt;&gt;&gt; [id(x) for x in wifey][1689774975888, 1689804999944, 1689804828320]&gt;&gt;&gt;</code></pre><p>修改后：</p><pre><code>&gt;&gt;&gt; [id(x) for x in person][1689804828600, 1689804830984, 1689804828320]&gt;&gt;&gt; [id(x) for x in hubby][1689774975888, 1689804830984, 1689804828320]&gt;&gt;&gt; [id(x) for x in wifey][1689774975888, 1689804830984, 1689804828320]&gt;&gt;&gt;</code></pre><h1 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h1><p>我们用深拷贝的方式实现上面的案列：</p><pre><code>&gt;&gt;&gt; import copy&gt;&gt;&gt; person=[&apos;name&apos;,[&apos;savings&apos;,100.00],&apos;JJ&apos;]&gt;&gt;&gt; hubby=copy.deepcopy(person)&gt;&gt;&gt; wifey=copy.copy(person)&gt;&gt;&gt; [id(x) for x in (person,hubby,wifey)][1689806469640, 1689804999688, 1689804830152]&gt;&gt;&gt; person[0]=&apos;Jack&apos;&gt;&gt;&gt; [x for x in (person,hubby,wifey)][[&apos;Jack&apos;, [&apos;savings&apos;, 100.0], &apos;JJ&apos;], [&apos;name&apos;, [&apos;savings&apos;, 100.0], &apos;JJ&apos;], [&apos;name&apos;, [&apos;savings&apos;, 100.0], &apos;JJ&apos;]]&gt;&gt;&gt; person[1][1]=60&gt;&gt;&gt; [x for x in (person,hubby,wifey)]  #结果不一样了[[&apos;Jack&apos;, [&apos;savings&apos;, 60], &apos;JJ&apos;], [&apos;name&apos;, [&apos;savings&apos;, 100.0], &apos;JJ&apos;], [&apos;name&apos;, [&apos;savings&apos;, 60], &apos;JJ&apos;]]&gt;&gt;&gt;</code></pre><p>注意点</p><p>第一,非容器类型(比如数字,字符串和其他“原子”类型的对象,像代码,类型和 xrange 对象等)没有被拷贝一说。</p><p>第二,如果元组变量只包含原子类型对象,对它的深拷贝将不会进行.如果我们把账户信息改成元组类型,那么即便按我们的要求使用深拷贝操作也只能得到一个浅拷贝。</p><pre><code>&gt;&gt;&gt; import copy&gt;&gt;&gt; person = [&apos;name&apos;, (&apos;savings&apos;, 100.00)]&gt;&gt;&gt; newPerson = copy.deepcopy(person)&gt;&gt; [id(x) for x in (person, newPerson)][1689804999752, 1689804999944]&gt;&gt;&gt; [id(x) for x in person][1689774975888, 1689805087240]&gt;&gt;&gt; [id(x) for x in newPerson][1689774975888, 1689805087240]&gt;&gt;&gt;</code></pre><p>说明：原子类型对象：数值（所有的数值类型），字符串</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><font size="4" color="red"><br><strong>深浅拷贝都是对源对象的复制，占用不同的内存空间</strong><br><br><strong>如果源对象只有一级目录的话，源做任何改动，不影响深浅拷贝对象</strong><br><br><strong>如果源对象不止一级目录的话，源做任何改动，都要影响浅拷贝，但不影响深拷贝</strong><br><br><strong>序列对象的切片以及使用工厂函数list(),dict()等是浅拷贝，即只拷贝顶级的对象。</strong><br></font>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Python中一切都是对象，比如说:3, 3.14, ‘Hello’, [1,2,3,4],（’12’,5,6）,{‘a’:1}……，为什么会存在‘拷贝’这一概念，主要是因为python中的可变与不可变对象的存在。&lt;/p&gt;
&lt;p&gt;拷贝概念的引入就是针对:可变对象的共享引用潜在的副作用而提出的。&lt;/p&gt;
&lt;p&gt;共享引用（两个变量引用同一块内存空间）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; list=[1,2,3]
&amp;gt;&amp;gt;&amp;gt; list2=list
&amp;gt;&amp;gt;&amp;gt; id(list)
1624535010824
&amp;gt;&amp;gt;&amp;gt; id(list2)
1624535010824
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Python" scheme="http://waisunny.com/categories/Python/"/>
    
    
      <category term="python基础" scheme="http://waisunny.com/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>python 对象</title>
    <link href="http://waisunny.com/2017/11/22/python-%E5%AF%B9%E8%B1%A1/"/>
    <id>http://waisunny.com/2017/11/22/python-对象/</id>
    <published>2017-11-22T09:44:18.000Z</published>
    <updated>2017-12-24T03:09:48.983Z</updated>
    
    <content type="html"><![CDATA[<p>在python中一切皆为对象，Python 使用对象模型来存储数据。构造任何类型的值都是一个对象。</p><p>所有的 Python 对像都拥有三个特性：<strong>身份、类型、值</strong>。</p><p><strong>身份</strong>：每一个对象都有一个唯一的身份标识自己，任何对象的身份可以使用内建函数 id()来得到。<br>这个值可以被认为是该对象的内存地址。您极少会用到这个值，也不用太关心它究竟是什么。</p><p><strong>类型</strong>：对象的类型决定了该对象可以保存什么类型的值，可以进行什么样的操作，以及遵循什么样的规则。您可以用内建函数 type()查看 Python 对象的类型。因为在 Python 中类型也是对象。</p><p><strong>值</strong>：对象表示的数据项</p><p>Python 有一系列的基本（内建）数据类型，必要时也可以创建自定义类型来满足你的应用程序的需求。绝大多数应用程序通常使用<strong>标准类型</strong>，对特定的数据存储则通过创建和实例化类<br>来实现<br><a id="more"></a></p><h1 id="python-标准类型"><a href="#python-标准类型" class="headerlink" title="python 标准类型"></a>python 标准类型</h1><ol><li><p>数字（分为几个子类型，其中有三个是整型）</p><ol><li>Integer 整型</li><li>Boolean布尔型</li><li>Long integer长整型</li><li>Float浮点型</li><li>Complex number复数型</li></ol></li><li><p>String 字符串 </p></li><li><p>List 列表</p></li><li><p>Tuple 元组</p></li><li><p>Dictionary 字典</p></li></ol><h2 id="标准类型操作符"><a href="#标准类型操作符" class="headerlink" title="标准类型操作符"></a>标准类型操作符</h2><h3 id="值比较"><a href="#值比较" class="headerlink" title="值比较"></a>值比较</h3><pre><code>&gt;&gt;&gt; 2 == 2True&gt;&gt;&gt; 2.46 &lt;= 8.33True&gt;&gt;&gt; 5+4j &gt;= 2-3jTrue&gt;&gt;&gt; &apos;abc&apos; == &apos;xyz&apos;False&gt;&gt;&gt; &apos;abc&apos; &gt; &apos;xyz&apos;False                            &gt;&gt;&gt; &apos;abc&apos; &lt; &apos;xyz&apos;True&gt;&gt;&gt; [3, &apos;abc&apos;] == [&apos;abc&apos;, 3]False&gt;&gt;&gt; [3, &apos;abc&apos;] == [3, &apos;abc&apos;]True不同于很多其它语言，多个比较操作可以在同一行上进行，求值顺序为从左到右。&gt;&gt;&gt; 3 &lt; 4 &lt; 7 # same as ( 3 &lt; 4 ) and ( 4 &lt; 7 )True&gt;&gt;&gt; 4 &gt; 3 == 3 # same as ( 4 &gt; 3 ) and ( 3 == 3 )True&gt;&gt;&gt; 4 &lt; 3 &lt; 5 != 2 &lt; 7False</code></pre><p>我们会注意到比较操作是针对对象的值进行的，也就是说比较的是对象的数值而不是对象本身。</p><h3 id="身份比较"><a href="#身份比较" class="headerlink" title="身份比较"></a>身份比较</h3><p>python 提供了 is 和 is no操作符来测试两个变量是否指向同一个对象。</p><pre><code>&gt;&gt;&gt; a=3&gt;&gt;&gt; b=3&gt;&gt;&gt; a is b # 等价于 id(a)==id(b)True&gt;&gt;&gt; l=[1,2,3]&gt;&gt;&gt; ll=[1,2,3]&gt;&gt;&gt; l is llFalse #可变类型的赋值操作是新创建一个对象，详见：[Python的可变与不可变数据类型](http://waisunny.com/2017/11/20/Python%E7%9A%84%E5%8F%AF%E5%8F%98%E4%B8%8E%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/)</code></pre><h2 id="标准类型内建函数"><a href="#标准类型内建函数" class="headerlink" title="标准类型内建函数"></a>标准类型内建函数</h2><p>Python 提供了一些内建函数用于这些基本对象类型：cmp(), repr(), str(), type(), 和等同于 repr()函数的单反引号(``) 运算符。</p><ol><li>cmp(obj1, obj2)： 比较 obj1 和 obj2, 根据比较结果返回整数 i:<ol><li>i &lt; 0 if obj1 &lt; obj2</li><li>i &gt; 0 if obj1 &gt; obj2</li><li>i == 0 if obj1 == obj2</li></ol></li><li><p>repr(obj) 或 <code>obj</code> 返回一个对象的字符串表示</p></li><li><p>str(obj) 返回对象适合可读性好的字符串表示</p></li><li><p>type(obj) 得到一个对象的类型，并返回相应的 type 对象</p></li></ol><p>说明：cmp()函数在python3中已被舍弃，详情参考：<a href="http://blog.csdn.net/sushengmiyan/article/details/11332589" title="cmp函数在python3中的替换版本" target="_blank" rel="external">http://blog.csdn.net/sushengmiyan/article/details/11332589</a></p><h2 id="标准类型工厂函数"><a href="#标准类型工厂函数" class="headerlink" title="标准类型工厂函数"></a>标准类型工厂函数</h2><p>工厂函数:看上去有点象函数， 实质上他们是类。当你<strong>调用它们时，实际上是生成了该类型的一个实<br>例</strong>， 就象工厂生产货物一样。</p><p>在以前的python版本中称为内建函数，现在是工厂函数：</p><p>int(), long(), float(), complex()，str()</p><p>unicode(), basestring(),list(), tuple(),type()</p><p>python后来版本增加的工厂函数：</p><p>dict(),bool(),set(), frozenset(), object(),file()</p><p>classmethod(),staticmethod(), super(), property()</p><pre><code>&gt;&gt;&gt; list()[]&gt;&gt;&gt; dict&lt;class &apos;dict&apos;&gt;&gt;&gt;&gt; list()[]&gt;&gt;&gt; dict(){}&gt;&gt;&gt; float()0.0&gt;&gt;&gt; int()0&gt;&gt;&gt; bool()False</code></pre><h2 id="标准类型分类"><a href="#标准类型分类" class="headerlink" title="标准类型分类"></a>标准类型分类</h2><h3 id="存储模型"><a href="#存储模型" class="headerlink" title="存储模型"></a>存储模型</h3><ol><li><p>标量/原子类型： 数值（所有数值类型），字符串</p></li><li><p>容器类型：列表、元祖、字典</p></li></ol><h3 id="更新模型"><a href="#更新模型" class="headerlink" title="更新模型"></a>更新模型</h3><ol><li>可变类性：列表、字典</li><li>不可变类型：数字、字符串、元祖</li></ol><h3 id="访问模型"><a href="#访问模型" class="headerlink" title="访问模型"></a>访问模型</h3><ol><li>直接访问：数字</li><li>顺序访问：字符串、列表、元祖</li><li>映射访问：字典</li></ol><h1 id="python其他内建类型"><a href="#python其他内建类型" class="headerlink" title="python其他内建类型"></a>python其他内建类型</h1><ol><li>类型(type)</li><li>Null 对象 (None)</li><li>文件</li><li>集合/固定集合（set）</li><li>函数/方法</li><li>模块</li><li>类</li></ol><h1 id="python内部类型"><a href="#python内部类型" class="headerlink" title="python内部类型"></a>python内部类型</h1><ol><li>代码（编译过的python源代码片段）</li><li>帧(python的执行帧栈)</li><li>跟踪记录(Traceback)</li><li>切片</li><li>省略</li><li>range</li></ol><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>解释：<strong>内建</strong> ：是由python的解释器本身支持的，不需要任何import就可以使用的，而且也找不到.py的源码。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在python中一切皆为对象，Python 使用对象模型来存储数据。构造任何类型的值都是一个对象。&lt;/p&gt;
&lt;p&gt;所有的 Python 对像都拥有三个特性：&lt;strong&gt;身份、类型、值&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;身份&lt;/strong&gt;：每一个对象都有一个唯一的身份标识自己，任何对象的身份可以使用内建函数 id()来得到。&lt;br&gt;这个值可以被认为是该对象的内存地址。您极少会用到这个值，也不用太关心它究竟是什么。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;类型&lt;/strong&gt;：对象的类型决定了该对象可以保存什么类型的值，可以进行什么样的操作，以及遵循什么样的规则。您可以用内建函数 type()查看 Python 对象的类型。因为在 Python 中类型也是对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;值&lt;/strong&gt;：对象表示的数据项&lt;/p&gt;
&lt;p&gt;Python 有一系列的基本（内建）数据类型，必要时也可以创建自定义类型来满足你的应用程序的需求。绝大多数应用程序通常使用&lt;strong&gt;标准类型&lt;/strong&gt;，对特定的数据存储则通过创建和实例化类&lt;br&gt;来实现&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://waisunny.com/categories/Python/"/>
    
    
      <category term="python基础" scheme="http://waisunny.com/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Python的可变与不可变数据类型</title>
    <link href="http://waisunny.com/2017/11/22/Python%E7%9A%84%E5%8F%AF%E5%8F%98%E4%B8%8E%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://waisunny.com/2017/11/22/Python的可变与不可变数据类型/</id>
    <published>2017-11-21T20:09:04.000Z</published>
    <updated>2017-12-24T03:09:43.999Z</updated>
    
    <content type="html"><![CDATA[<p>初学python的时候，可能会有很多疑惑，尤其是最先接触的所谓的“可变数据类型”和“不可变数据类型”。python与C/C++不一样，它的变量使用有自己的特点，当初学python的时候，一定要记住“一切皆为对象，一切皆为对象的引用”这句话，其实这个特点类似于JAVA，所以在python里面大家也不用担心类似于C/C++中的指针的复杂问题。下面本文将对python里面的“可变数据类型”和“不可变数据类型”进行分析。</p><p>首先，我们需要知道在python中哪些是可变数据类型，哪些是不可变数据类型。</p><p><strong>可变数据类型：列表list和字典dict；</strong></p><p><strong>不可变数据类型：整型int、浮点型float、字符串型string和元组tuple。</strong></p><p>然后，我们以int和list为例，来看看“可变数据类型”和“不可变数据类型”到底有什么区别。</p><a id="more"></a><h1 id="不可变数据类型分析"><a href="#不可变数据类型分析" class="headerlink" title="不可变数据类型分析"></a>不可变数据类型分析</h1><pre><code>&gt;&gt;&gt; x = 1    &gt;&gt;&gt; id(x)    31106520    &gt;&gt;&gt; y = 1    &gt;&gt;&gt; id(y)    31106520    &gt;&gt;&gt; x = 2    &gt;&gt;&gt; id(x)    31106508    &gt;&gt;&gt; y = 2    &gt;&gt;&gt; id(y)    31106508    &gt;&gt;&gt; z = y    &gt;&gt;&gt; id(z)    31106508   &gt;&gt;&gt; x += 2    &gt;&gt;&gt; id(x)    31106484 </code></pre><p>上面这段程序都是对不可变数据类型中的int类型的操作，id()查看的是当前变量的地址值。</p><p>我们先来看x = 1和y = 1两个操作的结果，从上面的输出可以看到x和y在此时的地址值是一样的，也就是说x和y其实是引用了同一个对象，即1，也就是说<strong>内存中对于1只占用了一个地址</strong>，而不管有多少个引用指向了它，都只有一个地址值，只是有一个<strong>引用计数</strong>会记录指向这个地址的引用到底有几个而已。</p><p>当我们进行x = 2赋值时，发现x的地址值变了，虽然还是x这个引用，但是其地址值却变化了，后面的y = 2以及z = y，使得x、y和z都引用了同一个对象，即2，所以地址值都是一样的。</p><p>当x和y都被赋值2后，1这个对象已经没有引用指向它了，所以1这个对象占用的内存，即31106520地址要被“垃圾回收”，即1这个对象在内存中已经不存在了。</p><p>最后，x进行了加2的操作，所以创建了新的对象4，x引用了这个新的对象，而不再引用2这个对象。</p><p>总的来说，python里的不可变大家可以理解为x引用的地址处的值是不能被改变的，也就是31106520地址处的值在没被垃圾回收之前一直都是1，不能改变，如果要把x赋值为2，那么只能将x引用的地址从31106520变为31106508，相当于x = 2这个赋值又创建了一个对象，即2这个对象，然后x、y、z都引用了这个对象，所以int这个数据类型是不可变的，如果想对int类型的变量再次赋值，在内存中相当于又创建了一个新的对象，而不再是之前的对象。从下图中就可以看到上面程序的过程。<br><img src="https://i.imgur.com/44gY2jF.png" alt=""></p><p>从上面的过程可以看出，不可变数据类型的优点就是内存中不管有多少个引用，相同的对象只占用了一块内存，但是它的缺点就是当需要对变量进行运算从而改变变量引用的对象的值时，由于是不可变的数据类型，所以必须创建新的对象，这样就会使得一次次的改变创建了一个个新的对象，不过不再使用的内存会被垃圾回收器回收(<strong>python提供了自动的垃圾回收机制，后面会有博文详解</strong>)。</p><h1 id="可变数据类型分析"><a href="#可变数据类型分析" class="headerlink" title="可变数据类型分析"></a>可变数据类型分析</h1><pre><code>&gt;&gt;&gt; a = [1, 2, 3]    &gt;&gt;&gt; id(a)    41568816    &gt;&gt;&gt; a = [1, 2, 3]    &gt;&gt;&gt; id(a)    41575088    &gt;&gt;&gt; a.append(4)    &gt;&gt;&gt; id(a)    41575088    &gt;&gt;&gt; a += [2]    &gt;&gt;&gt; id(a)    41575088    &gt;&gt;&gt; a    [1, 2, 3, 4, 2]  </code></pre><p>从上面的程序中可以看出，进行两次a = [1, 2, 3]操作，两次a引用的地址值是不同的，也就是说其实创建了两个不同的对象，这一点明显不同于不可变数据类型，所以对于可变数据类型来说，具有同样值的对象是不同的对象，即在内存中保存了多个同样值的对象，地址值不同。</p><p>接着来看后面的操作，我们对列表进行添加操作，分别a.append(4)和a += [2]，发现这两个操作使得a引用的对象值变成了上面的最终结果，但是a引用的地址依旧是41575088，也就是说对a进行的操作不会改变a引用的地址值，只是在地址后面又扩充了新的地址，改变了地址里面存放的值，</p><p><strong>所以可变数据类型的意思就是说对一个变量进行操作时，其值是可变的，值的变化并不会引起新建对象，即地址是不会变的，只是地址中的内容变化了或者地址得到了扩充。下图对这一过程进行了图示，可以很清晰地看到这一过程。</strong><br><img src="https://i.imgur.com/aSEf24o.png" alt=""></p><p>从上述过程可以看到，可变数据类型是允许同一对象的内容，即值可以变化，但是地址是不会变化的。但是需要注意一点，对可变数据类型的操作不能是直接进行新的赋值操作，比如说a = [1, 2, 3, 4, 5, 6, 7]，这样的操作就不是改变值了，而是新建了一个新的对象，这里的可变只是对于类似于append、+=等这种操作。</p><p>另外看下面的例子：</p><pre><code>&gt;&gt;&gt; list=[1,3,4]&gt;&gt;&gt; list1=[1,3,4]&gt;&gt;&gt; id(list)1916536781128&gt;&gt;&gt; id(list1)1916536780296&gt;&gt;&gt; list2=list3=[1,3,4]  #等价于  list2=[1,3,4]  list2=list3&gt;&gt;&gt; id(list2)1916536781000&gt;&gt;&gt; id(list3)1916536781000</code></pre><p>可以看出，对可变数据类型的直接进行新的赋值操作的确是新建了一个对象，但是将一个可变类型赋值给另一个可变类性的操作并没有创建新的对象，<br>只是原对象增加了一个引用而已。</p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><pre><code>&gt;&gt;&gt; x=3.14&gt;&gt;&gt; y=3.14&gt;&gt;&gt; id(x) 1996197073232&gt;&gt;&gt; id(y)1996197073688&gt;&gt;&gt; y=x&gt;&gt;&gt; id(y)1996197073232</code></pre><p>为什么会出现上述情况呢？同一个3.14在内存中创建了两次，浮点型不是不可变类型吗？原因是因为Python 仅缓存简单整数，因为它认为在 Python 应用程序中这些小整数会经常被用到。Python 缓存的整数范围是(-1, 100)，不过这个范围是会改变的，所以请不要在你的应用程序使用这个特性。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>不可变数据类型，不允许变量的值发生变化，如果改变了变量的值，相当于是新建了一个对象，而对于相同的值的对象，在内存中则只有一个对象，内部会有一个引用计数来记录有多少个变量引用这个对象；</p><p>可变数据类型，允许变量的值发生变化，即如果对变量进行append、+=等这种操作后，只是改变了变量的值，而不会新建一个对象，变量引用的对象的地址也不会变化，不过对于相同的值的不同变量（a=[1,2,3]与b=[1,2,3]是两个不同的对象），在内存中则会存在不同的对象，即每个对象都有自己的地址，相当于内存中对于同值的对象保存了多份，这里不存在引用计数，是实实在在的对象。</p><p>最后，大家主要区分开什么是变量值的变化、什么是变量引用的对象地址的变化这些概念就很清楚了，千说万说都不如自己动手写一些程序测试一下看看来得实在，所以建议大家有什么疑惑可以自己写一些基本的程序测试一下便知道结果。如果大家有新的意见，欢迎补充，谢谢。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;初学python的时候，可能会有很多疑惑，尤其是最先接触的所谓的“可变数据类型”和“不可变数据类型”。python与C/C++不一样，它的变量使用有自己的特点，当初学python的时候，一定要记住“一切皆为对象，一切皆为对象的引用”这句话，其实这个特点类似于JAVA，所以在python里面大家也不用担心类似于C/C++中的指针的复杂问题。下面本文将对python里面的“可变数据类型”和“不可变数据类型”进行分析。&lt;/p&gt;
&lt;p&gt;首先，我们需要知道在python中哪些是可变数据类型，哪些是不可变数据类型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可变数据类型：列表list和字典dict；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不可变数据类型：整型int、浮点型float、字符串型string和元组tuple。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;然后，我们以int和list为例，来看看“可变数据类型”和“不可变数据类型”到底有什么区别。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://waisunny.com/categories/Python/"/>
    
    
      <category term="python基础" scheme="http://waisunny.com/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>python中的编码问题</title>
    <link href="http://waisunny.com/2017/11/20/python%E4%B8%AD%E7%9A%84%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/"/>
    <id>http://waisunny.com/2017/11/20/python中的编码问题/</id>
    <published>2017-11-20T09:22:29.000Z</published>
    <updated>2017-12-24T03:09:36.700Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>初学python让人头疼的莫过于python中的字符编码问题，尤其是在python2中，默认输出的字符是<strong>Ascii</strong>,是不支持中文的，所以要使用中文必须在每个文件的开头写上：‘# coding:utf-8’,这样才能输出中文否则会报一个下面这样的错误：</p><pre><code>SyntaxError: Non-ASCII character &apos;\xe6&apos; in file new1.txt on line 2, but no encoding declared; see http:/www.python.org/peps/pep-0263.html for details</code></pre><p>到了python3中字符的默认输出是‘utf-8’格式的编码，这样就支持中文了；那为什么会存在这么多恶心的编码问题呢，这还得从编码的历史说起。</p><a id="more"></a><h1 id="编码由来"><a href="#编码由来" class="headerlink" title="编码由来"></a>编码由来</h1><p>大家都知道，计算机是美国人发明的，因此，最早只有127个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码。</p><p>显然，ASCII编码是不支持中文的，为了处理中文，中国人自己 制定了GB2312编码，用来把中文编进去，这样就支持中文展示了。</p><p>你可以想得到的是，全世界有上百种语言，日本把日文编到Shift_JIS里，韩国把韩文编到Euc-kr里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。</p><p>因此，万国码<strong>Unicode</strong>应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。</p><p>Unicode标准也在不断发展，但最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。</p><p>现在，捋一捋ASCII编码和Unicode编码的区别：ASCII编码是1个字节，而Unicode编码通常是2个字节。</p><p>新的问题又出现了：如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。</p><p>所以，本着节约的精神，又出现了把Unicode编码转化为<strong>“可变长编码”的UTF-8编码</strong>。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间：</p><pre><code>字符        ASCII                  Unicode                       UTF-8A          01000001           00000000 01000001                01000001中           x               01001110 00101101           11100100 10111000 10101101</code></pre><p>从上面的表格还可以发现，UTF-8编码有一个额外的好处，就是ASCII编码实际上可以被看成是UTF-8编码的一部分，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。</p><h1 id="计算机系统通用的字符编码工作方式"><a href="#计算机系统通用的字符编码工作方式" class="headerlink" title="计算机系统通用的字符编码工作方式"></a>计算机系统通用的字符编码工作方式</h1><p>搞清楚了ASCII、Unicode和UTF-8的关系，我们就可以总结一下现在计算机系统通用的字符编码工作方式：</p><p>在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。</p><p>用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件。</p><p>浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器：所以你看到很多网页的源码上会有类似<meta charset="UTF-8">的信息，表示该网页正是用的UTF-8编码。</p><h1 id="python中如何处理编码"><a href="#python中如何处理编码" class="headerlink" title="python中如何处理编码"></a>python中如何处理编码</h1><p>字符串在Python内部的表示是unicode编码，因此，在做编码转换时，通常需要以unicode作为中间编码，即先将其他编码的字符串解码（decode）成unicode，再从unicode编码（encode）成另一种编码。 </p><h2 id="decode"><a href="#decode" class="headerlink" title="decode"></a>decode</h2><p>decode的作用是将其他编码的字符串转换成unicode编码，如：</p><pre><code>str1.decode(‘gb2312‘)#表示将gb2312编码的字符串str1转换成unicode编码。 </code></pre><h2 id="encode"><a href="#encode" class="headerlink" title="encode"></a>encode</h2><p>encode的作用是将unicode编码转换成其他编码的字符串，如：</p><pre><code>str2.encode(‘gb2312‘)#表示将unicode编码的字符串str2转换成gb2312编码。 </code></pre><p>因此，转码的时候一定要先搞明白，字符串str是什么编码，然后decode成unicode，然后再encode成其他编码</p><h2 id="代码中字符串的默认编码与代码文件本身的编码一致"><a href="#代码中字符串的默认编码与代码文件本身的编码一致" class="headerlink" title="代码中字符串的默认编码与代码文件本身的编码一致"></a>代码中字符串的默认编码与代码文件本身的编码一致</h2><p>如：s=‘中文‘</p><p>如果是在utf8的文件中，该字符串就是utf8编码，如果是在gb2312的文件中，则其编码为gb2312。这种情况下，要进行编码转换，都需要先用decode方法将其转换成unicode编码，再使用encode方法将其转换成其他编码。</p><p>如果字符串是这样定义：s=u‘中文‘ </p><p>则该字符串的编码就被指定为unicode了，即python的内部编码，而与代码文件本身的编码无关。因此，对于这种情况做编码转换，只需要直接使用encode方法将其转换成指定编码即可。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>如果一个字符串已经是unicode了，再进行解码则将出错，因此通常要对其编码方式是否为unicode进行判断：</p><pre><code>isinstance(s, unicode)  #用来判断是否为unicode</code></pre><p>用非unicode编码形式的str来encode会报错。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;初学python让人头疼的莫过于python中的字符编码问题，尤其是在python2中，默认输出的字符是&lt;strong&gt;Ascii&lt;/strong&gt;,是不支持中文的，所以要使用中文必须在每个文件的开头写上：‘# coding:utf-8’,这样才能输出中文否则会报一个下面这样的错误：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SyntaxError: Non-ASCII character &amp;apos;\xe6&amp;apos; in file new1.txt on 
line 2, but no encoding declared; see http:/
www.python.org/peps/pep-0263.html for details
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;到了python3中字符的默认输出是‘utf-8’格式的编码，这样就支持中文了；那为什么会存在这么多恶心的编码问题呢，这还得从编码的历史说起。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://waisunny.com/categories/Python/"/>
    
    
      <category term="python基础" scheme="http://waisunny.com/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>python str()和repr()的区别</title>
    <link href="http://waisunny.com/2017/11/19/python-str%E5%92%8Crepr%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://waisunny.com/2017/11/19/python-str和repr的区别/</id>
    <published>2017-11-19T11:05:34.000Z</published>
    <updated>2017-12-24T07:58:18.829Z</updated>
    
    <content type="html"><![CDATA[<p>尽管str(),repr()和<code>运算在特性和功能方面都非常相似，事实上repr()和</code>做的是完全一样的事情，它们返回的是一个对象的“官方”字符串表示，也就是说绝大多数情况下可以通过求值运算（使用内建函数eval()）重新得到该对象。</p><p>但str()则有所不同，str()致力于生成一个对象的可读性好的字符串表示，它的返回结果通常无法用于eval()求值，但很适合用于print语句输出。需要再次提醒的是，并不是所有repr()返回的字符串都能够用 eval()内建函数得到原来的对象。 也就是说 repr() 输出对 Python比较友好，而str()的输出对用户比较友好。</p><p>虽然如此，很多情况下这三者的输出仍然都是完全一样的。 大家可以看下下面的代码，来进行对比<br><a id="more"></a></p><pre><code>&gt;&gt;&gt; s = &apos;Hello, world.&apos;&gt;&gt;&gt; str(s)&apos;Hello, world.&apos;&gt;&gt;&gt; repr(s)&quot;&apos;Hello, world.&apos;&quot;&gt;&gt;&gt; str(0.1)&apos;0.1&apos;&gt;&gt;&gt; repr(0.1)&apos;0.10000000000000001&apos;&gt;&gt;&gt; x = 10 * 3.25&gt;&gt;&gt; y = 200 * 200&gt;&gt;&gt; s = &apos;The value of x is &apos; + repr(x) + &apos;, and y is &apos; + repr(y) + &apos;...&apos;&gt;&gt;&gt; print(s)The value of x is 32.5, and y is 40000...&gt;&gt;&gt; # The repr() of a string adds string quotes and backslashes:... hello = &apos;hello, world\n&apos;&gt;&gt;&gt; hellos = repr(hello)&gt;&gt;&gt; print (hellos)&apos;hello, world\n&apos;&gt;&gt;&gt; # The argument to repr() may be any Python object:... repr((x, y, (&apos;spam&apos;, &apos;eggs&apos;)))&quot;(32.5, 40000, (&apos;spam&apos;, &apos;eggs&apos;))&quot;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;尽管str(),repr()和&lt;code&gt;运算在特性和功能方面都非常相似，事实上repr()和&lt;/code&gt;做的是完全一样的事情，它们返回的是一个对象的“官方”字符串表示，也就是说绝大多数情况下可以通过求值运算（使用内建函数eval()）重新得到该对象。&lt;/p&gt;
&lt;p&gt;但str()则有所不同，str()致力于生成一个对象的可读性好的字符串表示，它的返回结果通常无法用于eval()求值，但很适合用于print语句输出。需要再次提醒的是，并不是所有repr()返回的字符串都能够用 eval()内建函数得到原来的对象。 也就是说 repr() 输出对 Python比较友好，而str()的输出对用户比较友好。&lt;/p&gt;
&lt;p&gt;虽然如此，很多情况下这三者的输出仍然都是完全一样的。 大家可以看下下面的代码，来进行对比&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://waisunny.com/categories/Python/"/>
    
    
      <category term="python基础" scheme="http://waisunny.com/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>python中的字符串</title>
    <link href="http://waisunny.com/2017/11/19/python%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://waisunny.com/2017/11/19/python中的字符串/</id>
    <published>2017-11-18T17:39:38.000Z</published>
    <updated>2017-12-21T10:05:50.766Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字符串介绍"><a href="#字符串介绍" class="headerlink" title="字符串介绍"></a>字符串介绍</h1><p>基本字符串操作，索引、分片、乘法、判断成员资格、求长度、取最大最小值等，但请记住字符串是不可变的，so 通过分片赋值都是不合法的。</p><pre><code>&gt;&gt;&gt; x=&apos;Dany&apos;&gt;&gt;&gt; x[0]D&gt;&gt;&gt; x[1,3]an&gt;&gt;&gt; len(x)4&gt;&gt;&gt; x*3DanyDanyDany&gt;&gt;&gt; x[1:3]=&apos;co&apos;#非法操作，会出错的Traceback (most recent call last):File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: &apos;str&apos; object does not support item assignment</code></pre><a id="more"></a><h1 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h1><h2 id="方式一-‘-’"><a href="#方式一-‘-’" class="headerlink" title="方式一 ‘%’"></a>方式一 ‘%’</h2><p>使用%，在 <strong>%</strong> 左侧放置一个字符串（需要被格式化的字符串），右侧放置希望被格式化成的值，可以使用一个值，如一个字符串或者一个数字；（也可以使用多个值的元组或者下章将会讨论到的字典，前提是需要格式化多个值），一般情况下使用元组</p><pre><code>&gt;&gt;&gt; format=&quot;hello %s . My Name is %s&quot;&gt;&gt;&gt; words=(&apos;Word&apos;,&apos;Dany&apos;)&gt;&gt;&gt; format%wordshello Word . My Name is Dany</code></pre><p>说明：格式化操作符的右操作数可以是任意类型，如果右操作数是元组的话，则其中的每一个元素都会被单独格式化，每个值都需要一个对应的转换说明符，并且元组作为转换表达式的一部分存在时，必须使用圆括号括起来。</p><p>转换说明符：它们标记了需要插入转换值的位置。s表示值会被格式化为字符串–如果不是字符串，则会用str函数将其转换为字符串。</p><p><strong>如果使用列表或者其他序列代替元组，那么序列会被解释为一个值，只有元组和字典可以格式化一个以上的值。</strong></p><pre><code>&gt;&gt;&gt; str=&quot;hello %s . My Name is %s&quot;&gt;&gt;&gt; words=[&apos;Word&apos;,&apos;Dany&apos;]&gt;&gt;&gt; str%wordsTraceback (most recent call last):File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: not enough arguments for format string</code></pre><p>格式化整数，<strong>%d</strong></p><pre><code>&gt;&gt;&gt; str=&quot;My age is %d&quot;&gt;&gt;&gt; vales=23&gt;&gt;&gt; str%valesMy age is 23</code></pre><p>格式化实数（浮点数），<strong>%.2f </strong> 一个句点’.’在加上希望保留的小数位。</p><pre><code>&gt;&gt;&gt; str=&quot;Hello,My Height is %.2f m&quot;&gt;&gt;&gt; vales=(1.765)&gt;&gt;&gt; str%valesHello,My Height is 1.76 m&gt;&gt;&gt; str=&quot;Pi with three decimal:%.3f&quot;&gt;&gt;&gt; str math import pi&gt;&gt;&gt; str%piPi with three decimal:3.141</code></pre><h2 id="方式二-‘模板字符串’"><a href="#方式二-‘模板字符串’" class="headerlink" title="方式二 ‘模板字符串’"></a>方式二 ‘模板字符串’</h2><p>模板字符串：string模块提供的另外一种格式化字符的方式。</p><p>substitute这个模板方法会用传递进来的关键字参数foo替换字符串中的$foo,并返回替换后的值。</p><pre><code>&gt;&gt;&gt; from string import Template #导入模板&gt;&gt;&gt; s=Template(&apos;$x. glorious $x!&apos;)#包装字符串&gt;&gt;&gt; s.substitute(x=&apos;slurm&apos;)#调用模板方法格式换字符串slurm. glorious slurm!</code></pre><p>如果替换字段是单词的一部分，那么参数名就必须用括号括起来，从而准确指明结尾：</p><pre><code>&gt;&gt;&gt; s=Template(&quot;It&apos;s ${x}tastic!&quot;)&gt;&gt;&gt; s.substitute(x=&apos;slurm&apos;)It&apos;s slurmtastic!</code></pre><p>可以使用$$插入美元符号</p><pre><code>&gt;&gt;&gt; s=Templatte(&quot;Make $$ selling $x!&quot;)&gt;&gt;&gt; s.substitute(x=&apos;slurm&apos;)Make $ selling slurm!</code></pre><p>除了关键字参数外，还可以使用字典变量提供值/名称对</p><pre><code>&gt;&gt;&gt; s=Template(&quot;A $thing must never $action.&quot;)&gt;&gt;&gt; d={}&gt;&gt;&gt; d[&apos;thing&apos;]=&apos;gentleman&apos;&gt;&gt;&gt; d[&apos;action&apos;]=&apos;show his socks&apos;&gt;&gt;&gt; s.substitute(d)A gentleman must never show his socks.</code></pre><p>说明：safe_substitute相比substitute不会因为缺少值或者不正确使用$字符而出错</p><h2 id="方式三-‘format函数’"><a href="#方式三-‘format函数’" class="headerlink" title="方式三 ‘format函数’"></a>方式三 ‘format函数’</h2><pre><code>&gt;&gt;&gt; s_info=&quot;{0}&apos;s age is {1}&quot;.format(&apos;Dany&apos;,23)&gt;&gt;&gt; s_infoDany&apos;s age is 23&gt;&gt;&gt; s_info=&quot;{name}&apos;s age is {age}&quot;.format(name=&apos;Dany&apos;,age=23)&gt;&gt;&gt; s_infoDany&apos;s age is 23</code></pre><p>说明：推荐使用第三种，简明直观。</p><h1 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h1><h2 id="方式一-‘-’-1"><a href="#方式一-‘-’-1" class="headerlink" title="方式一 ‘+’"></a>方式一 ‘+’</h2><pre><code>website = &apos;http:\\&apos; + &apos;python&apos; + &apos;.org&apos;</code></pre><h2 id="方式二-‘join方法’"><a href="#方式二-‘join方法’" class="headerlink" title="方式二 ‘join方法’"></a>方式二 ‘join方法’</h2><pre><code>listStr = [&apos;http:\\&apos;, &apos;python&apos;, &apos;.org&apos;] website = &apos;&apos;.join(listStr)</code></pre><h2 id="方式三-‘格式化-替换-’"><a href="#方式三-‘格式化-替换-’" class="headerlink" title="方式三 ‘格式化(替换)’"></a>方式三 ‘格式化(替换)’</h2><pre><code>website = &apos;%s%s%s&apos; % (&apos;http:\\&apos;, &apos;python&apos;, &apos;.org&apos;)</code></pre><h2 id="三种方式比较"><a href="#三种方式比较" class="headerlink" title="三种方式比较"></a>三种方式比较</h2><p>方法1，使用简单直接，但是这种方法效率低，耗内存，之所以说python 中使用 + 进行字符串连接的操作效率低，是因为python中字符串是不可变的类型，使用 + 连接两个字符串时会生成一个新的字符串，生成<strong>新的字符串就需要重新申请内存</strong>，当连续相加的字符串很多时(a+b+c+d+e+f+…) ，效率低下就是必然的了</p><p>方法2，使用略复杂，但对多个字符进行连接时效率高，只会有一次内存的申请。而且如果是对list的字符进行连接的时候，这种方法必须是首选</p><p>方法3：字符串格式化，这种方法非常常用，本人也推荐使用该方法</p><h3 id="实验对比-‘-’-VS-‘join方法’"><a href="#实验对比-‘-’-VS-‘join方法’" class="headerlink" title="实验对比 ‘+’ VS ‘join方法’"></a>实验对比 ‘+’ VS ‘join方法’</h3><p>实验一：</p><pre><code>from time import timedef method1():    t = time()    for i in xrange(100000):            s =&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.    org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;py    thon.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org    &apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;pytho    n.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;    python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.o    rg&apos;print (time() - t)def method2():    t = time()    for i in xrange(100000):        s = &apos;&apos;.join    ([&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;pytho    n.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;    python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.o    rg&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;pyt    hon.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;    ,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python    .org&apos;])print (time() -t)method1()method2()</code></pre><p>结果：</p><pre><code>1.381000041960.137000083923</code></pre><p>实验二：</p><pre><code>from time import timedef method3():    t = time()    for i in xrange(100000):        s = &apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;+&apos;python.org&apos;    print (time() - t)def method4():    t = time()    for i in xrange(100000):        s = &apos;&apos;.join([&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;,&apos;python.org&apos;])    print (time() -t)method3()method4()</code></pre><p>结果：</p><pre><code>0.02500009536740.0599999427795</code></pre><p>上面两个实验出现了完全不同的结果，分析这两个实验唯一不同的是：字符串连接个数。</p><p><strong>结论：加号连接效率低是在连续进行多个字符串连接的时候出现的，如果连接的个数较少，加号连接效率反而比join连接效率高，但是使用‘+’会申请新的内存，当连接次数较少时，推荐使用格式化方法。</strong></p><h1 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h1><h2 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h2><p>非常重要的一个字符串方法，它是split方法的逆方法，用来连接序列中的元素，返回字符串。</p><pre><code>&gt;&gt;&gt; strs=[&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;]&gt;&gt;&gt; &apos;+&apos;.join(strs)1+2+3+4&gt;&gt;&gt; strs=&apos;liwei&apos;,&apos;lijie&apos;&gt;&gt;&gt; &apos;--love--&gt;&apos;.join(strs)liwei--love--&gt;lijie&gt;&gt;&gt; strs=[1,2,3,4,5]&gt;&gt;&gt; &apos;+&apos;.join(strs)#出错，因为join需要连接的序列元素必须都是字符串Traceback (most recent call last):File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: sequence item 0: expected str instance, int found</code></pre><h2 id="lower方法"><a href="#lower方法" class="headerlink" title="lower方法"></a>lower方法</h2><p>返回字符串的小写字母版</p><pre><code>&gt;&gt;&gt; strs=&apos;Dany is A Good Boy&apos;&gt;&gt;&gt; strs.lower()dany is a good boy</code></pre><h2 id="upper方法"><a href="#upper方法" class="headerlink" title="upper方法"></a>upper方法</h2><p>返回字符串的大写字母版</p><pre><code>&gt;&gt;&gt; strs=&apos;dany is A Good Boy&apos;&gt;&gt;&gt; strs.upper()DANY IS A GOOd BOY</code></pre><h2 id="replace方法"><a href="#replace方法" class="headerlink" title="replace方法"></a>replace方法</h2><p>方法返回某字符串的所有匹配项均被替换后得到的字符串</p><pre><code>&gt;&gt;&gt; strs=&apos;Dany Is is nice boy&apos;&gt;&gt;&gt; strs.replace(&apos;is&apos;,&apos;very&apos;)Dany Is very nice boy</code></pre><h2 id="split方法"><a href="#split方法" class="headerlink" title="split方法"></a>split方法</h2><p>将字符串分割成序列，返回的数据类型是列表</p><pre><code>&gt;&gt;&gt; strs=&apos;1+2+3+4&apos;&gt;&gt;&gt; strs.split(&apos;+&apos;)[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;]&gt;&gt;&gt; strs=&apos;1,2,3.4/5&apos;&gt;&gt;&gt; strs.split(&apos;,&apos;)[&apos;1&apos;,&apos;2&apos;,&apos;3.4/5&apos;]&gt;&gt;&gt; strs=&apos;1 2   3,4&apos;&gt;&gt;&gt; print(strs.split())#不指定分隔符会默认把所有的空格作为分隔符（空格，制表，换行）[&apos;1&apos;,&apos;2&apos;,&apos;3,4&apos;]</code></pre><h2 id="strip方法"><a href="#strip方法" class="headerlink" title="strip方法"></a>strip方法</h2><p>去除两侧的空格，不包含内部的</p><pre><code>&gt;&gt;&gt; strs=&apos;    123 3323  34      &apos;&gt;&gt;&gt; strs.strip()123 3323  34&gt;&gt;&gt; strs=&apos;!*12321!*221!*1231!*&apos;&gt;&gt;&gt; print(strs.strip(&apos;!*&apos;))#去除指定的字符，但只是去除两侧的12321!*221!*1231</code></pre><h2 id="startswith方法"><a href="#startswith方法" class="headerlink" title="startswith方法"></a>startswith方法</h2><p>判断是否以某一个字符串开头，返回布尔值</p><pre><code>&gt;&gt;&gt; strs=&apos;Dany is a good boy&apos;&gt;&gt;&gt; strs.startswith(&apos;Da&apos;) #注意这里区分大小写True</code></pre><h2 id="find方法"><a href="#find方法" class="headerlink" title="find方法"></a>find方法</h2><p>查找某一段字符串在一段字符串中出现的第一个位置并返回索引值</p><pre><code>&gt;&gt;&gt; strs=&apos;Dany is a good boy，Dany&apos;&gt;&gt;&gt; strs.find(&apos;Dany&apos;)0</code></pre><h2 id="count方法"><a href="#count方法" class="headerlink" title="count方法"></a>count方法</h2><p>返回某一段字符串出现的次数</p><pre><code>&gt;&gt;&gt; strs=&apos;Dany is a good boy，Dany&apos;&gt;&gt;&gt; strs.count(&apos;Dany&apos;)2</code></pre><h2 id="center方法"><a href="#center方法" class="headerlink" title="center方法"></a>center方法</h2><p>使字符串居中</p><pre><code>&gt;&gt;&gt; strs=&apos;DanyInfo&apos;&gt;&gt;&gt; strs.center(30,&apos;*&apos;)#参数1：字符串总长度，参数2：填充的字符***********DanyInfo***********</code></pre><h2 id="format方法"><a href="#format方法" class="headerlink" title="format方法"></a>format方法</h2><p>字符串格式化</p><pre><code>&gt;&gt;&gt; s_info=&quot;{0}&apos;s age is {1}&quot;.format(&apos;Dany&apos;,23)&gt;&gt;&gt; s_infoDany&apos;s age is 23&gt;&gt;&gt; s_info=&quot;{name}&apos;s age is {age}&quot;.format(name=&apos;Dany&apos;,age=23)&gt;&gt;&gt; s_infoDany&apos;s age is 23</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>字符串就介绍这么多，基本上覆盖到我们平常用到的所有字符串相关大知识点，另外在强调一点，字符串是不可变的，不可变类型和可变类型的详细介绍可参考我的下一篇博文。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;字符串介绍&quot;&gt;&lt;a href=&quot;#字符串介绍&quot; class=&quot;headerlink&quot; title=&quot;字符串介绍&quot;&gt;&lt;/a&gt;字符串介绍&lt;/h1&gt;&lt;p&gt;基本字符串操作，索引、分片、乘法、判断成员资格、求长度、取最大最小值等，但请记住字符串是不可变的，so 通过分片赋值都是不合法的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; x=&amp;apos;Dany&amp;apos;
&amp;gt;&amp;gt;&amp;gt; x[0]
D
&amp;gt;&amp;gt;&amp;gt; x[1,3]
an
&amp;gt;&amp;gt;&amp;gt; len(x)
4
&amp;gt;&amp;gt;&amp;gt; x*3
DanyDanyDany
&amp;gt;&amp;gt;&amp;gt; x[1:3]=&amp;apos;co&amp;apos;#非法操作，会出错的
Traceback (most recent call last):
File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
TypeError: &amp;apos;str&amp;apos; object does not support item assignment
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Python" scheme="http://waisunny.com/categories/Python/"/>
    
    
      <category term="python基础" scheme="http://waisunny.com/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>python中的变量</title>
    <link href="http://waisunny.com/2017/11/18/python%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F/"/>
    <id>http://waisunny.com/2017/11/18/python中的变量/</id>
    <published>2017-11-17T17:06:42.000Z</published>
    <updated>2017-12-24T01:43:20.130Z</updated>
    
    <content type="html"><![CDATA[<p>定义变量的目的：简单来说，变量是为了存储程序运算过程中的一些中间结果，为了方便日后调用。</p><p><strong>记住:python中一切皆为对象，一切皆为对象的引用，变量=对象。</strong></p><h1 id="变量命名规则"><a href="#变量命名规则" class="headerlink" title="变量命名规则"></a>变量命名规则</h1><ol><li>要具有描述性</li><li>变量名只能_,数字，字母组成，不可以是空格或特殊字符(#?&lt;.，￥$*!~)</li><li>不能以中文为变量名</li><li>不能以数字开头</li><li>保留字符是不能被使用</li></ol><a id="more"></a><h1 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h1><p>1.定义一个整数变量:</p><pre><code>a = 1</code></pre><p>2.定义一个字符串变量:</p><pre><code>t_007 = &apos;T007&apos;</code></pre><p>3.定义一个布尔值：</p><pre><code>Answer = True</code></pre><p>在Python中，等号=是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，例如：</p><pre><code>a = 123 # a是整数print(a)a = &apos;ABC&apos; # a变为字符串print(a)</code></pre><p>这种变量本身类型不固定的语言称之为<strong>动态语言</strong>，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下：</p><pre><code>int a = 123; //a是整数类型变量a = &quot;ABC&quot;; //错误：不能把字符串赋给整型变量</code></pre><p>和静态语言相比，动态语言更灵活。</p><p>可以看出，Python 中不但变量名无需事先声明，而且也无需类型声明。Python 语言中，<br>对象的类型和内存占用都是运行时确定的。尽管代码被编译成字节码，Python 仍然是一种<strong>解释型语言</strong>。在创建——也就是赋值时，解释器会根据语法和右侧的操作数来决定新对象的类型。在对象创建后，一个该对象的应用会被赋值给左侧的变量。 </p><h1 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h1><pre><code>&gt;&gt;&gt; x=1 #直接=赋值&gt;&gt;&gt; x=y=1# 链式复制&gt;&gt;&gt; x+=1 #增量赋值(x=x+1)&gt;&gt;&gt; x,y,z=(1,2,&apos;a&apos;)# 多元赋值 ,=号后面是一个元祖，即用小括号括起来，其实可以不加小括号，但为了提高代码可读性建议加上</code></pre><p>说明：赋值并不是直接将一个值赋给一个变量， 尽管你可能根据其它语言编程经验认为应该如此。在 Python 语言中，对象是通过引用传递的。在赋值时，不管这个对象是新创建的，还是一个已经存在的，都是将该对象的引用（并不是值）赋值给变量。</p><h1 id="变量存储机制"><a href="#变量存储机制" class="headerlink" title="变量存储机制"></a>变量存储机制</h1><p>声明：<strong>a = ‘ABC’</strong>时，Python解释器干了两件事情：</p><ol><li>在内存中创建了一个’ABC’的字符串；</li><li>在内存中创建了一个名为a的变量，并把它指向’ABC’。</li></ol><p>也可以把一个变量a赋值给另一个变量b，这个操作实际上<strong>是把变量b指向变量a所指向的数据</strong>，例如下面的代码：</p><pre><code>a = &apos;ABC&apos;b = aa = &apos;XYZ&apos;print(b)</code></pre><p>最后一行打印出变量b的内容到底是’ABC’呢还是’XYZ’？如果从数学意义上理解，就会错误地得出b和a相同，也应该是’XYZ’，但实际上b的值是’ABC’，让我们一行一行地执行代码，就可以看到到底发生了什么事：</p><p>1.执行a = ‘ABC’，解释器创建了字符串’ABC’和变量a，并把a指向’ABC’：</p><p><img src="https://i.imgur.com/ldl7FxP.png" alt=""></p><p>2.执行b = a，解释器创建了变量b，并把b指向a指向的字符串’ABC’：</p><p><img src="https://i.imgur.com/JZ6sixs.png" alt=""></p><p>3.执行a = ‘XYZ’，解释器创建了字符串’XYZ’，并把a的指向改为’XYZ’，但b并没有更改：</p><p><img src="https://i.imgur.com/VEUY64z.png" alt=""></p><p>所以，最后打印变量b的结果自然是’ABC’了。</p><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><p>所谓常量就是不能变的变量，比如常用的数学常数π就是一个常量。在Python中，通常用<strong>全部大写的变量名表示常量</strong>：</p><pre><code>PI = 3.14159265359</code></pre><p>但事实上PI仍然是一个变量，Python根本没有任何机制保证PI不会被改变，所以，用全部大写的变量名表示常量只是一个习惯上的用法，如果你一定要改变变量PI的值，也没人能拦住你。</p><h1 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h1><p>最后解释一下整数的除法为什么也是精确的。在Python中，有两种除法，一种除法是/：</p><pre><code>&gt;&gt;&gt; 10 / 33.3333333333333335 #这是python3中的结果python2中值为3</code></pre><p><strong>/</strong> python3中除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数：</p><pre><code>&gt;&gt;&gt; 9 / 33.0</code></pre><p>还有一种除法是 <strong>//</strong> ，称为地板除，两个整数的除法仍然是整数：</p><pre><code>&gt;&gt;&gt; 10 // 33</code></pre><p>你没有看错，整数的地板除 <strong>//</strong> 永远是整数，即使除不尽。要做精确的除法，使用 <strong>/</strong> 就可以。</p><p>因为 <strong>//</strong> 除法只取结果的整数部分，所以Python还提供一个余数运算，可以得到两个整数相除的余数：</p><pre><code>&gt;&gt;&gt; 10 % 31</code></pre><p>无论整数做 <strong>//</strong> 除法还是取余数 <strong>%</strong> ，结果永远是整数，所以，整数运算结果永远是精确的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;定义变量的目的：简单来说，变量是为了存储程序运算过程中的一些中间结果，为了方便日后调用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;记住:python中一切皆为对象，一切皆为对象的引用，变量=对象。&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;变量命名规则&quot;&gt;&lt;a href=&quot;#变量命名规则&quot; class=&quot;headerlink&quot; title=&quot;变量命名规则&quot;&gt;&lt;/a&gt;变量命名规则&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;要具有描述性&lt;/li&gt;
&lt;li&gt;变量名只能_,数字，字母组成，不可以是空格或特殊字符(#?&amp;lt;.，￥$*!~)&lt;/li&gt;
&lt;li&gt;不能以中文为变量名&lt;/li&gt;
&lt;li&gt;不能以数字开头&lt;/li&gt;
&lt;li&gt;保留字符是不能被使用&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Python" scheme="http://waisunny.com/categories/Python/"/>
    
    
      <category term="python基础" scheme="http://waisunny.com/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>setuptools和pip安装教程</title>
    <link href="http://waisunny.com/2017/11/17/setuptools%E5%92%8Cpip%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    <id>http://waisunny.com/2017/11/17/setuptools和pip安装教程/</id>
    <published>2017-11-16T16:03:08.000Z</published>
    <updated>2017-12-23T14:59:30.771Z</updated>
    
    <content type="html"><![CDATA[<p>setuptools 是 python 的基础包工具，可以帮助我们轻松的下载，构建，安装，升级，卸载 python的软件包。</p><p>pip 是python软件包的安装和管理工具， 有了这个工具， 我们只需要一个命令就可以轻松的安装python 的任意类库。</p><a id="more"></a><h1 id="安装setuptools"><a href="#安装setuptools" class="headerlink" title="安装setuptools"></a>安装setuptools</h1><p>①下载setuptools源码<strong>setuptools-25.2.0.tar.gz</strong>，地址：<a href="https://pypi.python.org/pypi/setuptools" title="setuptools下载" target="_blank" rel="external">https://pypi.python.org/pypi/setuptools</a><br><img src="https://i.imgur.com/a29kEga.png" alt=""><br>②这是一个压缩文件，将其解压到桌面，并进入该文件夹；按住shift键后，在文件夹空白处点击鼠标右键，选择：在此处打开命令窗口，输入：</p><pre><code>python setup.py install</code></pre><p>回车，看到如下图内容即表示安装成功：<br><img src="https://i.imgur.com/epT3f5n.png" alt=""></p><p>③安装完后在当前窗口中输入 <strong>easy_install</strong> 回车，进行检测，如果提示：<br><strong>error: No urls, filenames, or requirements specified (see –help</strong>) 说明安装成功，它在提示你命令后面需要跟参数。 如果提示： <strong>‘easy_install’</strong> 不是内部或外部命令，也不是可运行的程序或批处理文件。 请检查系统环境变量path是否配置了<strong>‘C:\Python27\Scripts’</strong></p><h1 id="安装pip"><a href="#安装pip" class="headerlink" title="安装pip"></a>安装pip</h1><h2 id="使用easy-install安装pip"><a href="#使用easy-install安装pip" class="headerlink" title="使用easy_install安装pip"></a>使用easy_install安装pip</h2><p>如果setuptools安装好后，可以直接用easy_install来安装pip，如下图：<br><img src="https://i.imgur.com/I0axT0o.png" alt=""></p><h2 id="手动安装pip"><a href="#手动安装pip" class="headerlink" title="手动安装pip"></a>手动安装pip</h2><p>如果还想手动安装的话，和安装setuptools步骤完全一样</p><p>①下载pip压缩包<strong>pip-9.0.1.tar.gz</strong>，地址：<a href="https://pypi.python.org/pypi/pip" title="pip下载" target="_blank" rel="external">https://pypi.python.org/pypi/pip</a>，如下图：<img src="https://i.imgur.com/gGKpfRK.png" alt=""></p><p>②这是一个压缩文件，将其解压到桌面，并进入该文件夹，按住shift键后，在文件夹空白处点击鼠标右键，选择：在此处打开命令窗口，输入：</p><pre><code>python setup.py install </code></pre><p>回车，看到如下图内容即表示安装成功：<br><img src="https://i.imgur.com/vZev7uY.png" alt=""></p><p>③安装成功后输入 <strong>pip</strong> 回车，进行检测如果提示： <strong>Did not provide a command</strong> 说明安装成功，因为pip后面也需要跟参数；如果提示： <strong>‘pip’ </strong>不是内部或外部命令，也不是可运行的程序或批处理文件，请检查环境变量path是否配置了<strong>‘C:\Python27\Scripts’</strong></p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>卸载pip:</p><pre><code>python -m pip uninstall pip setuptools</code></pre><p>升级pip:</p><pre><code>python -m pip install --upgrade pip</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;setuptools 是 python 的基础包工具，可以帮助我们轻松的下载，构建，安装，升级，卸载 python的软件包。&lt;/p&gt;
&lt;p&gt;pip 是python软件包的安装和管理工具， 有了这个工具， 我们只需要一个命令就可以轻松的安装python 的任意类库。&lt;/p&gt;
    
    </summary>
    
      <category term="软件安装" scheme="http://waisunny.com/categories/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    
    
      <category term="python环境部署" scheme="http://waisunny.com/tags/python%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>python 环境部署-Windows</title>
    <link href="http://waisunny.com/2017/11/16/python-%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2-Windows/"/>
    <id>http://waisunny.com/2017/11/16/python-环境部署-Windows/</id>
    <published>2017-11-15T16:53:48.000Z</published>
    <updated>2017-12-23T15:08:52.471Z</updated>
    
    <content type="html"><![CDATA[<p>学习python,首先就要部署python的开发环境，第一步下载python解释器，解释器就是用来执行python代码的，类似于Java虚拟机、CLR；然后就是配置环境变量，前期学习python基础直接通过docs窗口编写代码即可;如果想下载IDE的话推荐<a href="https://www.jetbrains.com/pycharm/" title="pycharm" target="_blank" rel="external">pycharm</a>。<br><a id="more"></a></p><h1 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h1><p>①下载python解释器：    </p><p>进入python官网：<a href="http://www.python.org" target="_blank" rel="external">http://www.python.org</a> 点击Downlods，选择Windows，然后看到如下界面：</p><p><img src="https://i.imgur.com/L62Jf03.jpg" alt=""></p><p>圈出来的一个是python3版本一个是python2版本，建议都安装，日后可根据需求使用，<strong>建议使用python3</strong>，虽然说现在市场上大部分是使用python2,但是python2最终会被python3替换掉，一些新项目都是使用python3开发的。另外没必要过于纠结两个版本，他们在一些语法上使用是有些许不同，但整体相似。详情参考:<a href="https://www.zhihu.com/question/19698598" title="python2和python3的区别" target="_blank" rel="external">https://www.zhihu.com/question/19698598</a></p><p>下载好后直接安装即可，<strong>记录住安装目录</strong>。    </p><h1 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h1><p>②配置环境变量：    </p><p>步骤(Win10)：右键单击电脑属性—&gt;高级系统设置—&gt;环境变量—&gt;编辑系统变量Path—&gt;将刚才的安装路径添加进去，如下图：</p><p><img src="https://i.imgur.com/Akxo4lX.jpg" alt=""><br>我配置了python3和python2的环境变量，并把python3的放在了第一位，系统会采用环境变量靠前的python版本；环境变量设置的路径就是你python的安装路径，以python2为例，如下图：</p><p><img src="https://i.imgur.com/9DFsk0G.jpg" alt=""></p><h1 id="检验是否安装成功"><a href="#检验是否安装成功" class="headerlink" title="检验是否安装成功"></a>检验是否安装成功</h1><p>打开cmd命令框，快捷键是windows+r ,输入cmd–&gt;回车—&gt;在弹出的命令框中输入 <strong>python</strong>,看到如下图内容即表示配置成功：</p><p><img src="https://i.imgur.com/jbijBPp.jpg" alt=""></p><h1 id="完善"><a href="#完善" class="headerlink" title="完善"></a>完善</h1><p>为了方便后续的python版本切换，建议将python安装路径下的python.exe程序重命名为对应版本的名称，即python2.7版本的命名为：python2.exe，python3.6版本的命名为python3.exe；这样我们就可以在命令框中直接输入对应的名称就可以使用各版本的python，不用切换环境变量的先后顺序了。如下图：</p><p><img src="https://i.imgur.com/Jvns0hw.jpg" alt=""></p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>这是最基本的python环境部署，后续在实际开发过程中我们还要安装很多类库、插件等；推荐安装pip,使用pip安装类库等十分方便。</p><p>如何安装pip,详见：<a href="http://waisunny.com/2017/11/17/setuptools%E5%92%8Cpip%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/#more">setuptools和pip安装教程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习python,首先就要部署python的开发环境，第一步下载python解释器，解释器就是用来执行python代码的，类似于Java虚拟机、CLR；然后就是配置环境变量，前期学习python基础直接通过docs窗口编写代码即可;如果想下载IDE的话推荐&lt;a href=&quot;https://www.jetbrains.com/pycharm/&quot; title=&quot;pycharm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;pycharm&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="软件安装" scheme="http://waisunny.com/categories/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    
    
      <category term="python环境部署" scheme="http://waisunny.com/tags/python%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
</feed>
