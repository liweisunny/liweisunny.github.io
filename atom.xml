<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WaiBlog|码农的技术小窝</title>
  
  <subtitle>所有的努力都值得期许，每一份梦想都应该灌溉！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://waisunny.com/"/>
  <updated>2018-03-26T01:02:09.801Z</updated>
  <id>http://waisunny.com/</id>
  
  <author>
    <name>_learner</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Django之cookie和session</title>
    <link href="http://waisunny.com/2018/02/23/Django%E4%B9%8Bcookie%E5%92%8Csession/"/>
    <id>http://waisunny.com/2018/02/23/Django之cookie和session/</id>
    <published>2018-02-22T18:01:33.000Z</published>
    <updated>2018-03-26T01:02:09.801Z</updated>
    
    <content type="html"><![CDATA[<p>再说Django中的cookie和session是如何使用之前，我们先来介绍一下cookie和session是什么，明确一点，cookie和session是通用的，不仅仅局限于Django等python web框架，在其他语言，框架中均有应用。</p><p>本文先介绍cookie和session的原理，然后介绍它们在Django中是如何使用以及如何配置的。</p><p>cookie与session的详细介绍：</p><a id="more"></a><h1 id="登录应用"><a href="#登录应用" class="headerlink" title="登录应用"></a>登录应用</h1><p>每当我们使用一款浏览器访问一个登陆页面的时候，一旦我们通过了认证。服务器端就会发送一组随机唯一的字符串（假设是123abc）到浏览器端，这个被存储在浏览端的东西就叫cookie。而服务器端也会自己存储一下用户当前的状态，比如login=true，username=hahaha之类的用户信息。但是这种存储是以字典形式存储的，字典的唯一key就是刚才发给用户的唯一的cookie值。那么如果在服务器端查看session信息的话，理论上就会看到如下样子的字典</p><pre><code>{&apos;123abc&apos;:{&apos;login&apos;:true,&apos;username:hahaha&apos;}}</code></pre><p>因为每个cookie都是唯一的，所以我们在电脑上换个浏览器再登陆同一个网站也需要再次验证。那么为什么说我们只是理论上看到这样子的字典呢？因为处于安全性的考虑，其实对于上面那个大字典不光key值123abc是被加密的，value值{‘login’:true,’username:hahaha’}在服务器端也是一样被加密的。所以我们服务器上就算打开session信息看到的也是类似与以下样子的东西</p><pre><code>{&apos;123abc&apos;:dasdasdasd1231231da1231231}</code></pre><h1 id="Django实现的COOKIE"><a href="#Django实现的COOKIE" class="headerlink" title="Django实现的COOKIE"></a>Django实现的COOKIE</h1><h2 id="获取cookie"><a href="#获取cookie" class="headerlink" title="获取cookie"></a>获取cookie</h2><pre><code>request.COOKIES[&apos;key&apos;]request.get_signed_cookie(key, default=RAISE_ERROR, salt=&apos;&apos;, max_age=None)    #参数：        default: 默认值           salt: 加密盐        max_age: 后台控制过期时间</code></pre><h2 id="设置cookie"><a href="#设置cookie" class="headerlink" title="设置cookie"></a>设置cookie</h2><pre><code>rep = HttpResponse(...) 或 rep ＝ render(request, ...) 或 rep ＝ redirect()rep.set_cookie(key,value,...)rep.set_signed_cookie(key,value,salt=&apos;加密盐&apos;,...)　</code></pre><h3 id="参数说明："><a href="#参数说明：" class="headerlink" title="参数说明："></a>参数说明：</h3><pre><code>def set_cookie(self,  key,                 键　　　　　　　　　　　　 value=&apos;&apos;,            值　　　　　　　　　　　　 max_age=None,        超长时间　　　　　　　　　　　　 expires=None,        超长时间　　　　　　　　　　　　 path=&apos;/&apos;,           Cookie生效的路径，浏览器只会把cookie回传给带有该路径的页面，这样可以避免将                                         cookie传给站点中的其他的应用。 / 表示根路径，根路径的cookie可以被任何url的页面访问　　　　　　　　　　　　                       domain=None,         Cookie生效的域名， 你可用这个参数来构造一个跨站cookie。                                          如， domain=&quot;.example.com&quot;， 所构造的cookie对下面这些站点都是可读的：                                          www.example.com 、 www2.example.com 和an.other.sub.domain.example.com 。                                          如果该参数设置为 None ，cookie只能由设置它的站点读取。　　　　　　　　　　　　 secure=False,        如果设置为 True ，浏览器将通过HTTPS来回传cookie。　　　　　　　　　　　　 httponly=False       只能http协议传输，无法被JavaScript获取（不是绝对，底层抓包可以获取到也可以被覆盖）　　　　　　　　　　): pass</code></pre><h2 id="删除cookie"><a href="#删除cookie" class="headerlink" title="删除cookie"></a>删除cookie</h2><pre><code>response.delete_cookie(&quot;cookie_key&quot;,path=&quot;/&quot;,domain=name)</code></pre><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>由于cookie存储在客户端，所以我们也可以通过js和jquery操作cookie</p><pre><code>&lt;script src=&apos;/static/js/jquery.cookie.js&apos;&gt;&lt;/script&gt; $.cookie(&quot;key&quot;, value,{ path: &apos;/&apos; });</code></pre><h1 id="Django实现的SESSION"><a href="#Django实现的SESSION" class="headerlink" title="Django实现的SESSION"></a>Django实现的SESSION</h1><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><pre><code>1 设置Sessions值          request.session[&apos;session_name&apos;] =&quot;admin&quot;2 获取Sessions值          session_name = request.session[&quot;session_name&quot;]3 删除Sessions值          del request.session[&quot;session_name&quot;]4 检测是否存在session值          if &quot;session_name&quot; is request.session :5 get(key, default=None)    fav_color = request.session.get(&apos;fav_color&apos;, &apos;red&apos;)6 pop(key)    fav_color = request.session.pop(&apos;fav_color&apos;)7 keys()8 items()9 setdefault()10 flush() 删除当前的会话数据并删除会话的Cookie。这用于确保前面的会话数据不可以再次被用户的浏览器访问           例如，django.contrib.auth.logout() 函数中就会调用它。11 用户session的随机字符串   request.session.session_key   将所有Session失效日期小于当前日期的数据删除   request.session.clear_expired()   检查 用户session的随机字符串 在数据库中是否   request.session.exists(&quot;session_key&quot;)   删除当前用户的所有Session数据   request.session.delete(&quot;session_key&quot;)   request.session.set_expiry(value)       * 如果value是个整数，session会在些秒数后失效。       * 如果value是个datatime或timedelta，session就会在这个时间后失效。       * 如果value是0,用户关闭浏览器session就会失效。       * 如果value是None,session会依赖全局session失效策略。</code></pre><h2 id="流程解析图"><a href="#流程解析图" class="headerlink" title="流程解析图"></a>流程解析图</h2><p><img src="https://i.imgur.com/POtapVA.png" alt=""></p><h2 id="登录应用案例"><a href="#登录应用案例" class="headerlink" title="登录应用案例"></a>登录应用案例</h2><p>项目地址：</p><h2 id="session存储的相关配置"><a href="#session存储的相关配置" class="headerlink" title="session存储的相关配置"></a>session存储的相关配置</h2><h3 id="数据库配置（默认）"><a href="#数据库配置（默认）" class="headerlink" title="数据库配置（默认）"></a>数据库配置（默认）</h3><pre><code>Django默认支持Session，并且默认是将Session数据存储在数据库中，即：django_session 表中。配置 settings.py    SESSION_ENGINE = &apos;django.contrib.sessions.backends.db&apos;   # 引擎（默认）    SESSION_COOKIE_NAME ＝ &quot;sessionid&quot;                       # Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串（默认）    SESSION_COOKIE_PATH ＝ &quot;/&quot;                               # Session的cookie保存的路径（默认）    SESSION_COOKIE_DOMAIN = None                             # Session的cookie保存的域名（默认）    SESSION_COOKIE_SECURE = False                            # 是否Https传输cookie（默认）    SESSION_COOKIE_HTTPONLY = True                           # 是否Session的cookie只支持http传输（默认）    SESSION_COOKIE_AGE = 1209600                             # Session的cookie失效日期（2周）（默认）    SESSION_EXPIRE_AT_BROWSER_CLOSE = False                  # 是否关闭浏览器使得Session过期（默认）    SESSION_SAVE_EVERY_REQUEST = False                       # 是否每次请求都保存Session，默认修改之后才保存（默认）</code></pre><h3 id="缓存配置"><a href="#缓存配置" class="headerlink" title="缓存配置"></a>缓存配置</h3><pre><code>配置 settings.py    SESSION_ENGINE = &apos;django.contrib.sessions.backends.cache&apos;  # 引擎    SESSION_CACHE_ALIAS = &apos;default&apos;                            # 使用的缓存别名（默认内存缓存，也可以是memcache），此处别名依赖缓存的设置    SESSION_COOKIE_NAME ＝ &quot;sessionid&quot;                        # Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串    SESSION_COOKIE_PATH ＝ &quot;/&quot;                                # Session的cookie保存的路径    SESSION_COOKIE_DOMAIN = None                              # Session的cookie保存的域名    SESSION_COOKIE_SECURE = False                             # 是否Https传输cookie    SESSION_COOKIE_HTTPONLY = True                            # 是否Session的cookie只支持http传输    SESSION_COOKIE_AGE = 1209600                              # Session的cookie失效日期（2周）    SESSION_EXPIRE_AT_BROWSER_CLOSE = False                   # 是否关闭浏览器使得Session过期    SESSION_SAVE_EVERY_REQUEST = False                        # 是否每次请求都保存Session，默认修改之后才保存</code></pre><h3 id="文件配置"><a href="#文件配置" class="headerlink" title="文件配置"></a>文件配置</h3><pre><code>配置 settings.py    SESSION_ENGINE = &apos;django.contrib.sessions.backends.file&apos;    # 引擎    SESSION_FILE_PATH = None                                    # 缓存文件路径，如果为None，则使用tempfile模块获取一个临时地址tempfile.gettempdir()            SESSION_COOKIE_NAME ＝ &quot;sessionid&quot;                          # Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串    SESSION_COOKIE_PATH ＝ &quot;/&quot;                                  # Session的cookie保存的路径    SESSION_COOKIE_DOMAIN = None                                # Session的cookie保存的域名    SESSION_COOKIE_SECURE = False                               # 是否Https传输cookie    SESSION_COOKIE_HTTPONLY = True                              # 是否Session的cookie只支持http传输    SESSION_COOKIE_AGE = 1209600                                # Session的cookie失效日期（2周）    SESSION_EXPIRE_AT_BROWSER_CLOSE = False                     # 是否关闭浏览器使得Session过期    SESSION_SAVE_EVERY_REQUEST = False                          # 是否每次请求都保存Session，默认修改之后才保存</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;再说Django中的cookie和session是如何使用之前，我们先来介绍一下cookie和session是什么，明确一点，cookie和session是通用的，不仅仅局限于Django等python web框架，在其他语言，框架中均有应用。&lt;/p&gt;
&lt;p&gt;本文先介绍cookie和session的原理，然后介绍它们在Django中是如何使用以及如何配置的。&lt;/p&gt;
&lt;p&gt;cookie与session的详细介绍：&lt;/p&gt;
    
    </summary>
    
      <category term="Django" scheme="http://waisunny.com/categories/Django/"/>
    
    
      <category term="Django基础" scheme="http://waisunny.com/tags/Django%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>ccookie与session剖析</title>
    <link href="http://waisunny.com/2018/02/21/cookie%E4%B8%8Esession%E5%89%96%E6%9E%90/"/>
    <id>http://waisunny.com/2018/02/21/cookie与session剖析/</id>
    <published>2018-02-20T18:01:33.000Z</published>
    <updated>2018-03-26T01:02:07.316Z</updated>
    
    <content type="html"><![CDATA[<p>cookie不属于http协议范围，由于http协议无法保持状态，但实际情况，我们却又需要“保持状态”，因此cookie就是在这样一个场景下诞生。</p><p>cookie的工作原理是：由服务器产生内容，浏览器收到请求后保存在本地；当浏览器再次访问时，浏览器会自动带上cookie，这样服务器就能通过cookie的内容来判断这个是“谁”了。</p><p>cookie虽然在一定程度上解决了“保持状态”的需求，但是由于cookie本身最大支持4096字节，以及cookie本身保存在客户端，可能被拦截或窃取，因此就需要有一种新的东西，它能支持更多的字节，并且他保存在服务器，有较高的安全性。这就是session。</p><p>问题来了，基于http协议的无状态特征，服务器根本就不知道访问者是“谁”。那么上述的cookie就起到桥接的作用。</p><p>我们可以给每个客户端的cookie分配一个唯一的id，这样用户在访问时，通过cookie，服务器就知道来的人是“谁”。然后我们再根据不同的cookie的id，在服务器上保存一段时间的私密资料，如“账号密码”等等。</p><a id="more"></a><p>总结而言：cookie弥补了http无状态的不足，让服务器知道来的人是“谁”；但是cookie以文本的形式保存在本地，自身安全性较差；所以我们就通过cookie识别不同的用户，对应的在session里保存私密的信息以及超过4096字节的文本。</p><h1 id="cookie和session区别"><a href="#cookie和session区别" class="headerlink" title="cookie和session区别"></a>cookie和session区别</h1><p>1.存取方式的不同</p><p>Cookie中只能保管ASCII字符串，假如需求存取Unicode字符或者二进制数据，需求先进行编码。Cookie中也不能直接存取Java对象。若要存储略微复杂的信息，运用Cookie是比拟艰难的。而Session中能够存取任何类型的数据，包括而不限于String、Integer、List、Map等。Session中也能够直接保管Java Bean乃至任何Java类，对象等，运用起来十分便当。能够把Session看做是一个Java容器类。</p><p>2.隐私策略的不同</p><p>Cookie存储在客户端阅读器中，对客户端是可见的，客户端的一些程序可能会窥探、复制以至修正Cookie中的内容。而Session存储在服务器上，对客户端是透明的，不存在敏感信息泄露的风险。假如选用Cookie，比较好的方法是，敏感的信息如账号密码等尽量不要写到Cookie中。最好是像Google、Baidu那样将Cookie信息加密，提交到服务器后再进行解密，保证Cookie中的信息只要本人能读得懂。而假如选择Session就省事多了，反正是放在服务器上，Session里任何隐私都能够有效的保护。</p><p>3.有效期上的不同</p><p>使用过Google的人都晓得，假如登录过Google，则Google的登录信息长期有效。用户不用每次访问都重新登录，Google会持久地记载该用户的登录信息。要到达这种效果，运用Cookie会是比较好的选择。只需要设置Cookie的过期时间属性为一个很大很大的数字。<br>由于Session依赖于名为JSESSIONID的Cookie，而Cookie JSESSIONID的过期时间默许为–1，只需关闭了阅读器该Session就会失效，因而Session不能完成信息永世有效的效果。运用URL地址重写也不能完成。而且假如设置Session的超时时间过长，服务器累计的Session就会越多，越容易招致内存溢出。</p><p>4.服务器压力的不同</p><p>Session是保管在服务器端的，每个用户都会产生一个Session。假如并发访问的用户十分多，会产生十分多的Session，耗费大量的内存。因而像Google、Baidu、Sina这样并发访问量极高的网站，是不太可能运用Session来追踪客户会话的。而Cookie保管在客户端，不占用服务器资源。假如并发阅读的用户十分多，Cookie是很好的选择。关于Google、Baidu、Sina来说，Cookie或许是唯一的选择。</p><p>5.浏览器支持的不同</p><p>Cookie是需要客户端浏览器支持的。假如客户端禁用了Cookie，或者不支持Cookie，则会话跟踪会失效。关于WAP上的应用，常规的Cookie就派不上用场了。假如客户端浏览器不支持Cookie，需要运用Session以及URL地址重写。需要注意的是一切的用到Session程序的URL都要进行URL地址重写，否则Session会话跟踪还会失效。关于WAP应用来说，Session+URL地址重写或许是它唯一的选择。<br>假如客户端支持Cookie，则Cookie既能够设为本浏览器窗口以及子窗口内有效(把过期时间设为–1)，也能够设为一切阅读器窗口内有效(把过期时间设为某个大于0的整数)。但Session只能在本阅读器窗口以及其子窗口内有效。假如两个浏览器窗口互不相干，它们将运用两个不同的Session。(IE8下不同窗口Session相干)</p><p>6.跨域支持上的不同</p><p>Cookie支持跨域名访问，例如将domain属性设置为“.biaodianfu.com”，则以“.biaodianfu.com”为后缀的一切域名均能够访问该Cookie。跨域名Cookie如今被普遍用在网络中，例如Google、Baidu、Sina等。而Session则不会支持跨域名访问。Session仅在他所在的域名内有效。仅运用Cookie或者仅运用Session可能完成不了理想的效果。这时应该尝试一下同时运用Cookie与Session。Cookie与Session的搭配运用在实践项目中会完成很多意想不到的效果。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;cookie不属于http协议范围，由于http协议无法保持状态，但实际情况，我们却又需要“保持状态”，因此cookie就是在这样一个场景下诞生。&lt;/p&gt;
&lt;p&gt;cookie的工作原理是：由服务器产生内容，浏览器收到请求后保存在本地；当浏览器再次访问时，浏览器会自动带上cookie，这样服务器就能通过cookie的内容来判断这个是“谁”了。&lt;/p&gt;
&lt;p&gt;cookie虽然在一定程度上解决了“保持状态”的需求，但是由于cookie本身最大支持4096字节，以及cookie本身保存在客户端，可能被拦截或窃取，因此就需要有一种新的东西，它能支持更多的字节，并且他保存在服务器，有较高的安全性。这就是session。&lt;/p&gt;
&lt;p&gt;问题来了，基于http协议的无状态特征，服务器根本就不知道访问者是“谁”。那么上述的cookie就起到桥接的作用。&lt;/p&gt;
&lt;p&gt;我们可以给每个客户端的cookie分配一个唯一的id，这样用户在访问时，通过cookie，服务器就知道来的人是“谁”。然后我们再根据不同的cookie的id，在服务器上保存一段时间的私密资料，如“账号密码”等等。&lt;/p&gt;
    
    </summary>
    
      <category term="Web技术" scheme="http://waisunny.com/categories/Web%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Web基础" scheme="http://waisunny.com/tags/Web%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Django url管理之include</title>
    <link href="http://waisunny.com/2018/02/12/Django-url%E7%AE%A1%E7%90%86%E4%B9%8Binclude/"/>
    <id>http://waisunny.com/2018/02/12/Django-url管理之include/</id>
    <published>2018-02-12T09:57:11.000Z</published>
    <updated>2018-02-23T02:36:28.790Z</updated>
    
    <content type="html"><![CDATA[<p>在Django框架中，提供了非常清晰简洁的url管理方法，在新建一个project之后(此处为myproject),然后在项目中建立一个app(此处为myapp)，会生成如下目录结构：</p><p><img src="https://i.imgur.com/dafhrXJ.png" alt=""><br><a id="more"></a></p><p>一般所熟知的就是在myproject/myproject/urls.py中的urlpatterns列表中来配置 url，每一个列表项就是一个由url函数的调用。例如假定我们想在myapp中定义一个主页，然后通过”<a href="http://localhost:8000/myapp/homepage&quot;来访问，首先我们在myproject/myapp/view.py中定义一个叫homePage的函数（名字随意，不一定叫这名字）：" target="_blank" rel="external">http://localhost:8000/myapp/homepage&quot;来访问，首先我们在myproject/myapp/view.py中定义一个叫homePage的函数（名字随意，不一定叫这名字）：</a></p><pre><code>from django.shortcuts import render  from django.http.response import HttpResponse  # Create your views here.  def homePage(request):      return HttpResponse(&quot;&lt;h1&gt;This is home page&lt;/h1&gt;&quot;)  </code></pre><p>然后在myproject/myproject/urls.py的urlpatterns列表中添加一个url配置:</p><pre><code>from django.conf.urls import url  from django.contrib import admin  from myapp.views import homePage#记得导入  urlpatterns = [      url(r&apos;^admin/&apos;, admin.site.urls),      url(r&apos;^myapp/homepage&apos;, homePage)  ]  </code></pre><p>然后运行项目，就可以用浏览器通过<a href="http://localhost:8000/myapp/homepage来访问。" target="_blank" rel="external">http://localhost:8000/myapp/homepage来访问。</a></p><p>但是假如一个project中有<strong>多个app</strong>，用以上的方式来管理url可能会造成比较混乱的局面，为了解决这个问题，我们可以用include的方法来配置url，<strong>首先我们在自己的app中建立一个urls.py，即myproject/myapp/目录下建立urls.py</strong>，然后在其中输入如下内容:</p><pre><code>from django.conf.urls import url  from myapp.views import homePage  urlpatterns = [      url(r&apos;homepage&apos;, homePage),  ]  </code></pre><p>然后在项目的urls中包含刚刚app中添加的url配置，我们要做的是在myproject/myproject/urls.py输入如下内容:</p><pre><code>from django.conf.urls import url, include#导入了include函数  from django.contrib import admin  urlpatterns = [      url(r&apos;^admin/&apos;, admin.site.urls),      url(r&apos;^myapp/&apos;, include(&quot;myapp.urls&quot;))#包含myapp中的urls  ]  </code></pre><p>然后通过刚刚相同的url(<a href="http://localhost:8000/myapp/homepage)访问发现也可以访问了。" target="_blank" rel="external">http://localhost:8000/myapp/homepage)访问发现也可以访问了。</a></p><p><strong>综上所述：include函数工作原理是：在接收http请求时，请求的url首先与项目本身的urls.py中配置的字段进行匹配，匹配到合适的在从当前条目中的include的url进行深度匹配，通过这样的url管理会更加整洁，可扩展性更强。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Django框架中，提供了非常清晰简洁的url管理方法，在新建一个project之后(此处为myproject),然后在项目中建立一个app(此处为myapp)，会生成如下目录结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/dafhrXJ.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Django" scheme="http://waisunny.com/categories/Django/"/>
    
    
      <category term="Django基础" scheme="http://waisunny.com/tags/Django%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Django url参数详解</title>
    <link href="http://waisunny.com/2018/02/11/Django-url%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3/"/>
    <id>http://waisunny.com/2018/02/11/Django-url参数详解/</id>
    <published>2018-02-10T18:01:33.000Z</published>
    <updated>2018-03-26T01:14:44.620Z</updated>
    
    <content type="html"><![CDATA[<p>Django项目中的url.py文件中用于配置请求路由的url()函数可以接受4个参数：</p><pre><code>urlpatterns = [    url(regex, view, kwargs=None, name=None),]</code></pre><p>两个是必须的：regex和view参数；</p><p>两个是可选的：kwargs和name参数；</p><p>下面来看一下这些参数是干啥的。</p><a id="more"></a><h1 id="regex参数"><a href="#regex参数" class="headerlink" title="regex参数"></a>regex参数</h1><p>“regex”参数url模式的匹配。</p><p>Django会把请求的url从第一条正则表达式开始匹配，直到找到一个可以匹配上的正则表达式为止。</p><p>需要注意的是，正则表达式并不查询get参数、post参数、域名，例如，当请求指向<a href="https://www.example.com/myapp/?page=3，" target="_blank" rel="external">https://www.example.com/myapp/?page=3，</a> URLconf还是会查找<strong>myapp/</strong>。</p><p>另外，如果您需要正则表达式的帮助，请参阅re模块的文档，然而，实际上，您不需要是正则表达式的专家，因为您只需要知道如何捕获简单的模式。</p><p>实际上，复杂的正则表达式的查找性能会很差，所以你可能不应该依靠正则表达式的全部功能。</p><p>最后，一个性能说明：这些正则表达式是第一次加载URLconf模块时被编译。它们超级快（只要查找不是太复杂，如上所述）。</p><h1 id="view参数"><a href="#view参数" class="headerlink" title="view参数"></a>view参数</h1><p>当正则表达式被匹配，view函数就会被调用。而且HttpRequest对象会作为第一个参数，其它被正则表达式捕获的值会作为其它参数传入到函数中。</p><h1 id="kwargs参数"><a href="#kwargs参数" class="headerlink" title="kwargs参数"></a>kwargs参数</h1><p>其它的参数(即要传入到view函数中的参数)以字典的形式传入。</p><h1 id="name参数"><a href="#name参数" class="headerlink" title="name参数"></a>name参数</h1><p>给你的url起个别名能让你在其它地方明确引用它。这个强大的功能可以让你在修改URL模式的时候只需修改单个文件。</p><p>创建一个django项目后，添加一个模板页：</p><p><img src="https://i.imgur.com/iq5xDcA.png" alt=""></p><p>url配置如下：</p><p><img src="https://i.imgur.com/SCmF2Cw.png" alt=""></p><p>我们计算加法的时候用的是 <strong>‘add/4/5/‘</strong>这个url ，后来需求发生变化，url改成 <strong>‘/4_add_5/‘</strong>，但在html页中，视图函数代码中有很多地方都写死了<strong>‘add/4/5/‘</strong>。如果这样写死url，会使得在改了url（正则）后，模板（template)，视图(views.py，用于跳转)，模型(models.py，可以用用于获取对象对应的地址）用了此url的，都得进行相应的更改，修改的代价很大，一不小心，有的地方没改过来，就不能用了。那么有没有更优雅的方式来解决这个问题呢？当然答案是肯定的:</p><pre><code>&lt;a href=&quot;{% url 'add2' 4 5 %}&quot;&gt;link&lt;/a&gt;</code></pre><p>上面的代码渲染成最终的url是：</p><pre><code>&lt;a href=&quot;/add/4/5/&quot;&gt;link&lt;/a&gt;</code></pre><p>使用 <strong>{\% url ‘add2’ 4 5 \%}</strong> 替换写死的url。 其中 ‘add2’ 就是url配置中name参数的值，后面 跟的两个参数是固定死的参数值。</p><p>当 urls.py 进行更改，前提是不改 name（这个参数设定好后不要轻易改），获取的url也会动态地跟着变，比如改成：</p><pre><code>url(r&apos;^new_add/(\d+)/(\d+)/$&apos;, calc_views.add2, name=&apos;add2&apos;)</code></pre><p>注意看重点add变成了new_add，但是后面的name=’add2’没改，这时 <strong>{\% url ‘add2’ 4 5 \%}</strong> 就会渲染对应的网址成 <strong>‘/new_add/4/5/‘</strong>用在 views.py 或 models.py 等地方的 <strong>reverse</strong>函数，同样会根据 name 对应的url获取到新的网址。</p><h1 id="生成url的函数reverse"><a href="#生成url的函数reverse" class="headerlink" title="生成url的函数reverse"></a>生成url的函数reverse</h1><pre><code>from django.core.urlresolvers import reverse  # django 1.4.x - django 1.10.x  from django.urls import reverse  # django 1.10.x 新的，更加规范了  reverse(&apos;add2&apos;, args=(4,5))  # u&apos;/add/4/5/&apos;  reverse(&apos;add2&apos;, args=(444,555))  # u&apos;/add/444/555/&apos;</code></pre><p>reverse 接收 url函数中的 name参数的值作为第一个参数，我们在代码中就可以通过 reverse() 来获取对应的网址（这个网址可以用来跳转，也可以用来计算相关页面的地址），只要对应的url的name不改，就不用改代码中的网址。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Django项目中的url.py文件中用于配置请求路由的url()函数可以接受4个参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;urlpatterns = [
    url(regex, view, kwargs=None, name=None),
]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;两个是必须的：regex和view参数；&lt;/p&gt;
&lt;p&gt;两个是可选的：kwargs和name参数；&lt;/p&gt;
&lt;p&gt;下面来看一下这些参数是干啥的。&lt;/p&gt;
    
    </summary>
    
      <category term="Django" scheme="http://waisunny.com/categories/Django/"/>
    
    
      <category term="Django基础" scheme="http://waisunny.com/tags/Django%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Django安装及基本操作指南</title>
    <link href="http://waisunny.com/2018/02/09/Django%E5%AE%89%E8%A3%85%E5%8F%8A%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/"/>
    <id>http://waisunny.com/2018/02/09/Django安装及基本操作指南/</id>
    <published>2018-02-08T18:01:33.000Z</published>
    <updated>2018-02-08T10:36:15.770Z</updated>
    
    <content type="html"><![CDATA[<p><strong>以下操作均在Windows下</strong></p><h1 id="配置python环境"><a href="#配置python环境" class="headerlink" title="配置python环境"></a>配置python环境</h1><p>参考：<a href="http://waisunny.com/2017/11/16/python-%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2-Windows/">python 环境部署-Windows</a></p><h1 id="安装PiP"><a href="#安装PiP" class="headerlink" title="安装PiP"></a>安装PiP</h1><p>参考：<a href="http://waisunny.com/2017/11/17/setuptools%E5%92%8Cpip%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/">setuptools和pip安装教程</a></p><a id="more"></a><h1 id="安装Django"><a href="#安装Django" class="headerlink" title="安装Django"></a>安装Django</h1><p>使用PiP安装django：</p><p>安装最新的版本的 Django 命令如下：  </p><pre><code>pip install django  </code></pre><p>安装指定版本的 Django 命令如下：</p><pre><code>pip install django==1.10.3  </code></pre><p>在这里推荐使用指定版本的django来安装</p><p>安装成功以后的截图：</p><p><img src="https://i.imgur.com/wZFz8AH.png" alt=""></p><p>使用 <strong>pip show</strong> 命令来查看当前安装的Django版本：</p><pre><code>pip show django</code></pre><p>使用 <strong>pip uninstall</strong> 命令来 卸载 Django：</p><pre><code>pip uninstall django </code></pre><h1 id="使用Django"><a href="#使用Django" class="headerlink" title="使用Django"></a>使用Django</h1><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目:"></a>创建项目:</h2><p>使用管理工具 django-admin.py创建项目，命令：</p><pre><code>django-admin.py startproject HelloWorld  </code></pre><p>说明：”HelloWord”为项目名称，项目路径为当前dos窗口打开的路径</p><p>创建完成后我们可以查看下项目的目录结构：</p><pre><code>|-- HelloWorld  |   |-- __init__.py  |   |-- settings.py  |   |-- urls.py  |   `-- wsgi.py  `-- manage.py </code></pre><p>目录说明：</p><ol><li>HelloWorld: 项目的容器。</li><li>manage.py: 一个实用的命令行工具，可让你以各种方式与该 Django 项目进行交互。</li><li>HelloWorld/<strong>init</strong>.py: 一个空文件，告诉 Python 该目录是一个 Python 包。</li><li>HelloWorld/settings.py: 该 Django 项目的设置/配置。</li><li>HelloWorld/urls.py: 该 Django 项目的 URL 声明; 一份由 Django 驱动的网站”目录”。</li><li>HelloWorld/wsgi.py: 一个 WSGI 兼容的 Web 服务器的入口，以便运行你的项目。<h2 id="启动服务器"><a href="#启动服务器" class="headerlink" title="启动服务器"></a>启动服务器</h2></li></ol><p>接下来我们进入 HelloWorld 项目目录输入以下命令：</p><pre><code>python manage.py runserver  </code></pre><p>说明：以上命令执行后会在你本地启动服务，默认端口8000，浏览器输入127.0.0.1:8000或者你的ip+8000就可以看到如下界面：<br><img src="https://i.imgur.com/aVIilKb.jpg" alt=""></p><h2 id="视图和Url配置"><a href="#视图和Url配置" class="headerlink" title="视图和Url配置"></a>视图和Url配置</h2><p>参考：<a href="http://www.runoob.com/django/django-first-app.html" target="_blank" rel="external">视图和URL配置</a> </p><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>Django规定，如果要使用模型，必须要创建一个app。我们使用以下命令创建一个名为 myapp的 app:</p><pre><code>django-admin.py startapp myapp  </code></pre><p>目录结构：</p><pre><code>HelloWorld  |-- myapp  |   |-- __init__.py  |   |-- admin.py  |   |-- models.py  |   |-- tests.py  |   `-- views.py  </code></pre><p>我们修改myapp/models.py文件代码：</p><pre><code>HelloWorld/TestModel/models.py: 文件代码：  from django.db import models  class Test(models.Model):      name = models.CharField(max_length=20)  </code></pre><p>以上的类名代表了数据库表名，且继承了models.Model，类里面的字段代表数据表中的字段(name)，数据类型则由CharField（相当于varchar）、DateField（相当于datetime）， max_length 参数限定长度。</p><h3 id="激活模型"><a href="#激活模型" class="headerlink" title="激活模型"></a>激活模型</h3><p>接下来在settings.py中找到INSTALLED_APPS这一项，如下：</p><pre><code>INSTALLED_APPS = (      &apos;django.contrib.admin&apos;,      &apos;django.contrib.auth&apos;,      &apos;django.contrib.contenttypes&apos;,      &apos;django.contrib.sessions&apos;,      &apos;django.contrib.messages&apos;,      &apos;django.contrib.staticfiles&apos;,      &apos;myapp&apos;,               # 注册app  ) </code></pre><p> 然后，执行一下命令：</p><pre><code>$ python manage.py makemigrations myapp #让 Django 知道我们在我们的模型有一些变更  $ python manage.py migrate myapp #创建表结构 </code></pre><h3 id="模型变更步骤"><a href="#模型变更步骤" class="headerlink" title="模型变更步骤"></a>模型变更步骤</h3><p>记住实现模型变更的三个步骤（每一步都是必须的）：</p><ol><li>修改你的模型（在models.py文件中）。</li><li>运行python manage.py makemigrations ，为这些修改创建迁移文件,如图所示就是生成的迁移文件</li><li>运行python manage.py migrate ，将这些改变更新到数据库中。</li></ol><p>说明：可以在执行：</p><pre><code>python manage.py migrate</code></pre><p>之前执行：</p><pre><code>python manage.py sqlmigrate myapp1 000 #这个会输出给我们迁移行为将会执行哪些SQL语句；</code></pre><p>执行：</p><pre><code>python manage.py check #会检查项目中模型是否存在问题。</code></pre><font color="red"><strong>执行命令时可以指定app名称，这样就是作用于某一个 app,推荐这样做。</strong></font><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这些都是最基本的操作，入门必备 ，希望对向我一样的初学者有帮助！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;以下操作均在Windows下&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;配置python环境&quot;&gt;&lt;a href=&quot;#配置python环境&quot; class=&quot;headerlink&quot; title=&quot;配置python环境&quot;&gt;&lt;/a&gt;配置python环境&lt;/h1&gt;&lt;p&gt;参考：&lt;a href=&quot;http://waisunny.com/2017/11/16/python-%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2-Windows/&quot;&gt;python 环境部署-Windows&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;安装PiP&quot;&gt;&lt;a href=&quot;#安装PiP&quot; class=&quot;headerlink&quot; title=&quot;安装PiP&quot;&gt;&lt;/a&gt;安装PiP&lt;/h1&gt;&lt;p&gt;参考：&lt;a href=&quot;http://waisunny.com/2017/11/17/setuptools%E5%92%8Cpip%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/&quot;&gt;setuptools和pip安装教程&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Django" scheme="http://waisunny.com/categories/Django/"/>
    
    
      <category term="Django环境部署" scheme="http://waisunny.com/tags/Django%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>python序列化模块json和pickle</title>
    <link href="http://waisunny.com/2018/01/30/python%E5%BA%8F%E5%88%97%E5%8C%96%E6%A8%A1%E5%9D%97json%E5%92%8Cpickle/"/>
    <id>http://waisunny.com/2018/01/30/python序列化模块json和pickle/</id>
    <published>2018-01-29T16:06:58.000Z</published>
    <updated>2018-01-29T09:09:03.667Z</updated>
    
    <content type="html"><![CDATA[<p>什么是序列化？</p><p>我们把对象(变量)从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling，在其他语言中也被称之为serialization，marshalling，flattening等等，都是一个意思。</p><p>序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。</p><p>反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。<br><a id="more"></a></p><h1 id="json"><a href="#json" class="headerlink" title="json"></a>json</h1><p>如果我们要在不同的编程语言之间传递对象，就必须把对象序列化为标准格式，比如XML，但更好的方法是序列化为JSON，因为JSON表示出来就是一个字符串，可以被所有语言读取，也可以方便地存储到磁盘或者通过网络传输。JSON不仅是标准格式，并且比XML更快，而且可以直接在Web页面中读取，非常方便。<br>JSON表示的对象就是标准的JavaScript语言的对象，JSON和Python内置的数据类型对应如下：<br><img src="https://i.imgur.com/4a221yG.png" alt=""></p><p>Json模块提供了四个功能：dumps、dump、loads、load 。</p><pre><code>import jsondic = {&apos;name&apos;: &apos;_learner&apos;, &apos;age&apos;: 23, &apos;sex&apos;: &apos;male&apos;}print(type(dic))  # &lt;class &apos;dict&apos;&gt;# -----------------------------序列化j = json.dumps(dic)print(type(j))  # &lt;class &apos;str&apos;&gt;f = open(&apos;file.txt&apos;, &apos;w&apos;)f.write(j)  # 等价于json.dump(dic,f)f.close()# -----------------------------反序列化f = open(&apos;file.txt&apos;)data = json.loads(f.read())  # 等价于data=json.load(f)print(data) # {&apos;name&apos;: &apos;_learner&apos;, &apos;age&apos;: 23, &apos;sex&apos;: &apos;male&apos;}</code></pre><h2 id="使用json注意事项"><a href="#使用json注意事项" class="headerlink" title="使用json注意事项"></a>使用json注意事项</h2><pre><code>import json#dic={&apos;1&apos;:111} #json.loads方法只接受字符串参数#print(json.loads(dic)) # TypeError: the JSON object must be str, bytes or bytearray, not &apos;dict&apos;#dic=&quot;{&apos;1&apos;:111}&quot;   # json 不认单引号#print(json.loads(dic)) # json.decoder.JSONDecodeError: Expecting property name enclosed in double quotes#dic=str({&quot;1&quot;:111})# 报错,因为生成的数据还是单引号:{&apos;one&apos;: 1}#print(json.loads(dic)) # json.decoder.JSONDecodeError: Expecting property name enclosed in double quotesdic=&apos;{&quot;1&quot;:111}&apos;print(json.loads(dic))# {&apos;1&apos;: 111}</code></pre><p>json不认单引号；另外，无论数据是怎样创建的，只要满足json格式，就可以json.loads出来,不一定非要dumps的数据才能loads。</p><h1 id="pickle"><a href="#pickle" class="headerlink" title="pickle"></a>pickle</h1><p>pickle是python特有的序列化方式，只能在python间使用。</p><p>pickle模块也提供了四个功能：dumps、dump、loads、load。</p><pre><code>import pickledic = {&apos;name&apos;: &apos;_learner&apos;, &apos;age&apos;: 23, &apos;sex&apos;: &apos;male&apos;}print(type(dic))  # &lt;class &apos;dict&apos;&gt;##-------------------------序列化j = pickle.dumps(dic)print(type(j))  # &lt;class &apos;bytes&apos;&gt;f = open(&apos;file_pickle&apos;, &apos;wb&apos;)  # 注意w是写入str,wb是写入bytes,j是&apos;bytes&apos;类型的f.write(j)  # -------------------等价于pickle.dump(dic,f)f.close()# -------------------------反序列化f = open(&apos;file_pickle&apos;, &apos;rb&apos;)data = pickle.loads(f.read())  # 等价于data=pickle.load(f)print(data[&apos;age&apos;]) # 23</code></pre><h1 id="pickle和json区别"><a href="#pickle和json区别" class="headerlink" title="pickle和json区别"></a>pickle和json区别</h1><p>json是可以在不同语言之间交换数据的，而pickle只在python之间使用。</p><p>json只能序列化最基本的数据类型，而pickle可以序列化所有的数据类型，包括类，函数都可以序列化。</p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>在这里介绍一下shelve模块，它也是一种序列化数据的方式。</p><p>shelve模块比pickle模块简单，只有一个open函数，返回类似字典的对象，可读可写;key必须为字符串，而值可以是python所支持的数据类型。</p><pre><code>import shelvef = shelve.open(r&apos;shelve.txt&apos;)f[&apos;stu_info&apos;]={&apos;name&apos;:&apos;_learner&apos;,&apos;age&apos;:&apos;23&apos;}f.close()f = shelve.open(r&apos;shelve.txt&apos;,&apos;r&apos;)print(f.get(&apos;stu_info&apos;)[&apos;age&apos;])f.close()</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是序列化？&lt;/p&gt;
&lt;p&gt;我们把对象(变量)从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling，在其他语言中也被称之为serialization，marshalling，flattening等等，都是一个意思。&lt;/p&gt;
&lt;p&gt;序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。&lt;/p&gt;
&lt;p&gt;反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://waisunny.com/categories/Python/"/>
    
    
      <category term="python模块" scheme="http://waisunny.com/tags/python%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>python-类(继承、派生、组合、包装(授权))</title>
    <link href="http://waisunny.com/2018/01/28/python-%E7%B1%BB(%E7%BB%A7%E6%89%BF%E3%80%81%E6%B4%BE%E7%94%9F%E3%80%81%E7%BB%84%E5%90%88%E3%80%81%E5%8C%85%E8%A3%85(%E6%8E%88%E6%9D%83))/"/>
    <id>http://waisunny.com/2018/01/28/python-类(继承、派生、组合、包装(授权))/</id>
    <published>2018-01-28T10:40:19.000Z</published>
    <updated>2018-02-05T08:46:58.407Z</updated>
    
    <content type="html"><![CDATA[<p>在学习python面向对象编程这一章节时，我们会接触到类（class）,与之俱来的就是很多名词：继承、派生、组合、包装授权等等，看介绍感觉看起来它们的意思差不多，都是用来提高代码重用的；整的我们一头雾水，下面我按照个人的理解把它们一一讲解一番。希望对各位迷茫的python学习者有所帮助。<br><a id="more"></a></p><h1 id="先说继承与派生"><a href="#先说继承与派生" class="headerlink" title="先说继承与派生"></a>先说继承与派生</h1><p>我们之所以吧继承和派生放在一起，其实是因为它俩其实是就是一回事，只是定义的角度不同，导致叫法不一样，先不告诉你为什么，看下面。</p><h2 id="什么是继承？"><a href="#什么是继承？" class="headerlink" title="什么是继承？"></a>什么是继承？</h2><p>继承是一种创建类的方法，在python中，一个类可以继承来自一个或多个父类。原始类称为基类或超类。</p><pre><code>class ParentClass1: #定义父类    passclass ParentClass2: #定义父类    passclass SubClass1(ParentClass1): #单继承，基类是ParentClass1，派生类是SubClass1    passclass SubClass2(ParentClass1,ParentClass2): #多继承用逗号分隔开，基类是ParentClass1,ParentClass2，派生类是SubClass2    pass</code></pre><p>查看继承： 使用类的<strong>__bases__</strong> 属性，它返回一个元组。</p><pre><code>&gt;&gt;&gt; SubClass2.__bases__ (&lt;class &apos;__main__.ParentClass1&apos;&gt;, &lt;class &apos;__main__.ParentClass2&apos;&gt;)</code></pre><h3 id="什么时候用继承"><a href="#什么时候用继承" class="headerlink" title="什么时候用继承"></a>什么时候用继承</h3><p>假如已经有几个类，而类与类之间有共同的变量属性和函数属性，那就可以把这几个变量属性和函数属性提取出来作为基类的属性。而特殊的变量属性和函数属性，则在本类中定义，这样只需要继承这个基类，就可以访问基类的变量属性和函数属性。可以提高代码的可扩展性。</p><h3 id="继承的好处"><a href="#继承的好处" class="headerlink" title="继承的好处"></a>继承的好处</h3><p>提高代码的复用。</p><h3 id="继承的弊端"><a href="#继承的弊端" class="headerlink" title="继承的弊端"></a>继承的弊端</h3><p>可能特殊的本类又有其他特殊的地方，又会定义一个类，其下也可能再定义类，这样就会造成继承的那条线越来越长，使用继承的话,任何一点小的变化也需要重新定义一个类,很容易引起类的爆炸式增长,产生一大堆有着细微不同的子类. 所以有个<strong>“多用组合少用继承”</strong>的原则。</p><h2 id="什么是派生？"><a href="#什么是派生？" class="headerlink" title="什么是派生？"></a>什么是派生？</h2><p>那么说了半天什么是派生呢？</p><p><strong>派生就是子类在继承父类的基础上衍生出新的属性。子类中独有的，父类中没有的；或子类定义与父类重名的东西。子类也叫派生类。</strong></p><p><strong>继承是从子类的角度来讲的，派生是从父类的角度来讲的</strong>；</p><p><strong>子类继承了父类，父类派生了子类 。</strong></p><p>所以派生和继承就是一回事，只是定义的角度不同而已。</p><h1 id="再说组合"><a href="#再说组合" class="headerlink" title="再说组合"></a>再说组合</h1><p>代码复用的重要的方式除了继承，还有组合。</p><p><strong>组合：在一个类中以另外一个类的对象作为数据属性，称为类的组合。</strong></p><pre><code>class Teacher:    def __init__(self, name, gender, course):        self.name = name        self.gender = gender        self.course = course #使用course对象作为数据属性class Course:    def __init__(self, name, price, period):        self.name = name        self.price = price        self.period = periodcourse_obj = Course(&apos;Python&apos;, 15800, &apos;5months&apos;)  #新建课程对象t_c = Teacher(&apos;egon&apos;, &apos;male&apos;, course_obj)  #新建老师实例，组合课程对象print(t_c.course.name)</code></pre><p>运行结果：</p><pre><code>Python</code></pre><p>组合与继承都是有效地利用已有类的资源的重要方式，但是二者的概念和使用场景皆不同。</p><h2 id="继承的方式"><a href="#继承的方式" class="headerlink" title="继承的方式"></a>继承的方式</h2><p>通过继承建立了派生类与基类之间的关系，它是一种’是’的关系，比如白马是马，人是动物。</p><p>当类之间有很多相同的功能，提取这些共同的功能做成基类，用继承比较好，比如教授是老师:</p><pre><code>class Teacher:    def __init__(self,name,gender):        self.name=name        self.gender=gender    def teach(self):        print(&apos;teaching&apos;)class Professor(Teacher):    passp1=Professor(&apos;egon&apos;,&apos;male&apos;)p1.teach()</code></pre><p>运行结果：</p><pre><code>teaching</code></pre><h2 id="组合的方式"><a href="#组合的方式" class="headerlink" title="组合的方式"></a>组合的方式</h2><p>用组合的方式建立了类与组合的类之间的关系，它是一种‘有’的关系,比如教授有生日，教授教python课程。</p><pre><code>class BirthDate:    def __init__(self,year,month,day):        self.year=year        self.month=month        self.day=day    def __str__(self):        return &apos;生日：{Y}-{M}-{D}&apos;.format(Y=self.year, M=self.month, D=self.day)    __repr__=__str__class Couse:    def __init__(self,name,price,period):        self.name=name        self.price=price        self.period=period    def __str__(self):        return &apos;课程名：{name}，价格：{price}，时长：{period}&apos;.format(name=self.name, price=self.price, period=self.period)    __repr__ = __str__class Teacher:    def __init__(self,name,gender):        self.name=name        self.gender=gender    def teach(self):        print(&apos;teaching&apos;)class Professor(Teacher):    def __init__(self,name,gender,birth,course):        Teacher.__init__(self,name,gender)        self.birth=birth        self.course=coursep1=Professor(&apos;_learner&apos;,&apos;male&apos;,             BirthDate(&apos;1994&apos;,&apos;09&apos;,&apos;09&apos;),             Couse(&apos;python&apos;,&apos;28000&apos;,&apos;4 months&apos;))print(p1.birth)print(p1.course)</code></pre><p>运行结果：</p><pre><code>生日：1994-09-09课程名：python，价格：28000，时长：4 months</code></pre><h1 id="最后谈包装-授权"><a href="#最后谈包装-授权" class="headerlink" title="最后谈包装(授权)"></a>最后谈包装(授权)</h1><p>包装：意思是对一个<strong>已存在</strong>的对象进行包装，不管它是数据类型，还是一段代码，可以是对一个已存在的对象，增加新的，删除不要的，或者修改其它已存在的功能。</p><p>包装包括定义一个类，它的实例拥有标准类型的核心行为。换句话说，它现在不仅能唱能跳，还能够像原类型一样步行，说话。</p><p>下图举例说明了在类中包装的类型看起像个什么样子。在图的中心为标准类型的核心行为，但它也通过新的或最新的功能，甚至可能通过访问实际数据的不同方法得到提高。</p><p><img src="https://i.imgur.com/nN64ARe.png" alt=""></p><p>你还可以包装类，但这不会有太多的用途，因为已经有用于操作对象的机制，并且在上面已描述过，对标准类型有对其进行包装的方式。你如何操作一个已存的类，模拟你需要的行为，删除你不喜欢的，并且可能让类表现出与原类不同的行为呢？我们前面已讨论过，就是采用派生。</p><p>所以说包装和派生之间没有明确的界限，包装主要用于对已存在的类型进行操作。</p><p><strong>授权是包装的一个特性，可用于简化处理有关 dictating 功能，采用已存在的功能以达到最大限度的代码重用。</strong></p><p><strong>实现授权的关键点就是覆盖__getattr__()方法，在代码中包含一个对 getattr()内建函数的调用。</strong></p><p><strong>特别地，调用 getattr()以得到默认对象属性（数据属性或者方法）并返回它以便访问或调用。</strong></p><p><strong>特殊方法__getattr__()的工作方式是，当搜索一个属性时，任何局部对象首先被找到（定制的对象）。如果搜索失败了，则__getattr__()会被调用，然后调用 getattr()得到一个对象的默认行为。</strong></p><p>换言之，当引用一个属性时，Python 解释器将试着在局部名称空间中查找那个名字，比如一个自定义的方法或局部实例属性。如果没有在局部字典中找到，则搜索类名称空间。最后，如果两类搜索都失败了，搜索则对原对象开始授权请求，此时，__getattr__()会被调用。意思就是当访问的属性找不到的时候回调用__getattr__()。</p><p>包装标准类型：</p><pre><code>class WrapMe:    def __init__(self,obj):        self.__data=obj    def __repr__(self):        return repr(self.__data)    def __getattr__(self, item):        return getattr(self.__data,item)cpl=WrapMe(3.5+4.2j)print(cpl)print(cpl.real )print(cpl.imag )print(cpl.conjugate())print(&apos;=&apos;*20)lst=WrapMe([1,2,5,2])lst.append(&apos;bar&apos;)print(lst)print(lst.index(2)) #1print(lst.count(2)) #2lst.pop()print(lst)</code></pre><p>运行结果：</p><pre><code>(3.5+4.2j)3.54.2(3.5-4.2j)====================[1, 2, 5, 2, &apos;bar&apos;]12[1, 2, 5, 2]</code></pre><p>包装特殊对象：</p><pre><code>class CapOpen:    def __init__(self,fn,m=&apos;r&apos;,buf=-1):        self.file=open(fn,m,buf)    def __iter__(self):        return self.file    def write(self,line):        self.file.write(line.upper())    def __getattr__(self, item):        return getattr(self.file,item)f=CapOpen(&apos;test.txt&apos;,&apos;r+&apos;)f.write(&apos;_learner&apos;)for lin in f:    print(lin)f.close()</code></pre><p>运行结果：</p><pre><code>_LEARNER</code></pre><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>相信你看完这篇文章，应该能搞明白什么是继承、派生、组合、包装授权了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在学习python面向对象编程这一章节时，我们会接触到类（class）,与之俱来的就是很多名词：继承、派生、组合、包装授权等等，看介绍感觉看起来它们的意思差不多，都是用来提高代码重用的；整的我们一头雾水，下面我按照个人的理解把它们一一讲解一番。希望对各位迷茫的python学习者有所帮助。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://waisunny.com/categories/Python/"/>
    
    
      <category term="python面向对象" scheme="http://waisunny.com/tags/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>解密 Python 的描述符（descriptor）</title>
    <link href="http://waisunny.com/2018/01/27/%E8%A7%A3%E5%AF%86%20Python%20%E7%9A%84%E6%8F%8F%E8%BF%B0%E7%AC%A6%EF%BC%88descriptor%EF%BC%89/"/>
    <id>http://waisunny.com/2018/01/27/解密 Python 的描述符（descriptor）/</id>
    <published>2018-01-27T09:40:19.000Z</published>
    <updated>2018-03-09T00:59:04.774Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是描述符？"><a href="#什么是描述符？" class="headerlink" title="什么是描述符？"></a>什么是描述符？</h1><p>严格来讲：描述符实际上可以是任何一个（新式）类，这种类至少实现了三个特殊方法__get__()、__set__()、__delete__()中的一个，这三个特殊方法冲当描述符协议。（摘自核心编程）</p><p>__get__()、__set__()及__delete__()的原型如下所示：</p><p>　　① __get__(self, instance, owner) ==&gt; Value</p><p>　　② __set__(self, instance, value) ==&gt;None</p><p>　　③ __delete__(self, instance)  ==&gt; None</p><a id="more"></a><h1 id="描述的有啥用？"><a href="#描述的有啥用？" class="headerlink" title="描述的有啥用？"></a>描述的有啥用？</h1><p>一句话：描述符是用作属性代理的。<strong>前提这个属性必须是类属性</strong>(后面会讲解为啥不能是实例属性)；通过描述符我们可以将属性复杂的逻辑判断封装到一个单独的类中，以便于重用。</p><p>案例：</p><p>想象一下你正在编写管理电影信息的代码。你最后写好的Movie类可能看上去是这样的：</p><pre><code>class Movie(object):    def __init__(self, title, rating, runtime, budget, gross):        self.title = title        self.rating = rating        self.runtime = runtime        self.budget = budget        self.gross = gross    def profit(self):        return self.gross - self.budget</code></pre><p>你开始在项目的其他地方使用这个类，但是之后你意识到：如果不小心给电影打了负分怎么办？你觉得这是错误的行为，希望Movie类可以阻止这个错误。 你首先想到的办法是将Movie类修改为这样：</p><pre><code>class Movie(object):    def __init__(self, title, rating, runtime, budget, gross):        self.title = title        self.rating = rating        self.runtime = runtime        self.gross = gross        if budget &lt; 0:            raise ValueError(&quot;Negative value not allowed: %s&quot; % budget)        self.budget = budget    def profit(self):        return self.gross - self.budget</code></pre><p>但这行不通。因为其他部分的代码都是直接通过Movie.budget来赋值的——这个新修改的类只会在__init__方法中捕获错误的数据，但对于已经存在的类实例就无能为力了。</p><h2 id="property"><a href="#property" class="headerlink" title="property"></a>property</h2><p>幸运的是，Python的property解决了这个问题：</p><pre><code>class Movie(object):    def __init__(self, title, rating, runtime, budget, gross):        self._budget = None        self.title = title        self.rating = rating        self.runtime = runtime        self.gross = gross        self.budget = budget    @property    def budget(self):        return self._budget    @budget.setter    def budget(self, value):        if value &lt; 0:            raise ValueError(&quot;Negative value not allowed: %s&quot; % value)        self._budget = value    def profit(self):        return self.gross - self.budgetm = Movie(&apos;Casablanca&apos;, 97, 102, 964000, 1300000)print(m.budget)try:    m.budget = -100 except ValueError:    print(&quot;Woops. Not allowed&quot;)</code></pre><p>运行结果：</p><pre><code>964000Woops. Not allowed</code></pre><p>我们用@property装饰器指定了一个getter方法，用@budget.setter装饰器指定了一个setter方法。当我们这么做时，每当有人试着访问budget属性，Python就会自动调用相应的getter/setter方法。比方说，当遇到m.budget = value这样的代码时就会自动调用budget.setter。</p><p>花点时间来欣赏一下Python这么做是多么的优雅：如果没有property，我们将不得不把所有的实例属性隐藏起来，提供大量显式的类似get_budget和set_budget方法。像这样编写类的话，使用起来就会不断的去调用这些getter/setter方法，这看起来就像臃肿的Java代码一样。更糟的是，如果我们不采用这种编码风格，直接对实例属性进行访问。那么稍后就没法以清晰的方式增加对非负数的条件检查——我们不得不重新创建set_budget方法，然后搜索整个工程中的源代码，将m.budget = value这样的代码替换为m.set_budget(value)。太蛋疼了！！</p><p>因此，property让我们将自定义的代码同变量的访问/设定联系在了一起，同时为你的类保持一个简单的访问属性的接口。干得漂亮！</p><p>但property也有不足的地方，对property来说，最大的缺点就是它们不能重复使用，假设你想为rating，runtime和gross这些字段也添加非负检查，那么你就需要向像给budget增加方法一样，分别为每一个属性定义它们的赋值和取值方法。</p><h2 id="描述符登场（最终的大杀器）"><a href="#描述符登场（最终的大杀器）" class="headerlink" title="描述符登场（最终的大杀器）"></a>描述符登场（最终的大杀器）</h2><p>这就是描述符所解决的问题。描述符是property的升级版，允许你为重复的property逻辑编写单独的类来处理。下面的示例展示了描述符是如何工作的：</p><pre><code>from weakref import WeakKeyDictionaryclass NonNegative(object):    &quot;&quot;&quot;A descriptor that forbids negative values&quot;&quot;&quot;    def __init__(self, default):        self.default = default        self.data = WeakKeyDictionary()    def __get__(self, instance, owner):        # we get here when someone calls x.d, and d is a NonNegative instance        # instance = x        # owner = type(x)        return self.data.get(instance, self.default)    def __set__(self, instance, value):        # we get here when someone calls x.d = val, and d is a NonNegative instance        # instance = x        # value = val        if value &lt; 0:            raise ValueError(&quot;Negative value not allowed: %s&quot; % value)        self.data[instance] = valueclass Movie(object):    # always put descriptors at the class-level    rating = NonNegative(0)    runtime = NonNegative(0)    budget = NonNegative(0)    gross = NonNegative(0)    def __init__(self, title, rating, runtime, budget, gross):        self.title = title        self.rating = rating        self.runtime = runtime        self.budget = budget        self.gross = gross    def profit(self):        return self.gross - self.budgetm = Movie(&apos;Casablanca&apos;, 97, 102, 964000, 1300000)print(m.budget)m.rating = 100print(m.rating) try:    m.rating = -1except ValueError:    print(&quot;Woops, negative value&quot;)</code></pre><p>运行结果:</p><pre><code>964000100Woops, negative value</code></pre><p>NonNegative是一个描述符对象，因为它定义了__get__，__set__或__delete__方法。</p><p>Movie类现在看起来非常清晰。我们在类的层面上创建了4个描述符，把它们当做普通的类属性。显然，描述符在这里为我们做非负检查。</p><h3 id="访问描述符"><a href="#访问描述符" class="headerlink" title="访问描述符"></a>访问描述符</h3><p>当解释器遇到print(m.buget)时，它就会把budget当作一个带有__get__ 方法的描述符，调用Movie.budget.__get__方法并将方法的返回值打印出来，而不是直接传递m.budget来打印。这和你访问一个property相似，Python自动调用一个方法，同时返回结果。</p><p>__get__接收2个参数：一个是点号左边的实例对象（在这里，就是m.budget中的m），另一个是这个实例的类型（Movie）。在一些Python文档中，Movie被称作描述符的所有者（owner）。如果我们需要访问Movie.budget，Python将会调用Movie.budget.__get__(None, Movie)。可以看到，第一个参数要么是所有者的实例，要么是None。这些输入参数可能看起来很怪，但是这里它们告诉了你描述符属于哪个对象的一部分。当我们看到NonNegative类的实现时这一切就合情合理了。</p><h3 id="对描述符赋值"><a href="#对描述符赋值" class="headerlink" title="对描述符赋值"></a>对描述符赋值</h3><p>当解释器看到m.rating = 100时，Python识别出rating是一个带有__set__方法的描述符，于是就调用Movie.rating.__set__(m, 100)。和__get_<em>一样，\</em>_set__的第一个参数是点号左边的类实例（m.rating = 100中的m）。第二个参数是所赋的值（100）。</p><h3 id="删除描述符"><a href="#删除描述符" class="headerlink" title="删除描述符"></a>删除描述符</h3><p>为了说明的完整，这里提一下删除。如果你调用del m.budget，Python就会调用Movie.budget.__delete__(m)。</p><h3 id="NonNegative类是如何工作的？"><a href="#NonNegative类是如何工作的？" class="headerlink" title="NonNegative类是如何工作的？"></a>NonNegative类是如何工作的？</h3><p>带着前面的困惑，我们终于要揭示NonNegative类是如何工作的了。每个NonNegative的实例都维护着一个字典，其中保存着所有者实例和对应数据的映射关系。当我们调用m.budget时，__get__方法会查找与m相关联的数据，并返回这个结果（如果这个值不存在，则会返回一个默认值）。__set__采用的方式相同，但是这里会包含额外的非负检查。我们使用WeakKeyDictionary来取代普通的字典以防止内存泄露——我们可不想仅仅因为它在描述符的字典中就让一个无用的实例一直存活着。</p><p>使用描述符会有一点别扭。因为它们作用于类的层次上，每一个类实例都共享同一个描述符。这就意味着对不同的实例对象而言，描述符不得不手动地管理不同的状态，同时需要显式的将类实例作为第一个参数准确传递给__get__、__set__以及__delete__方法。</p><p>我希望这个例子解释清楚了描述符可以用来做什么——它们提供了一种方法将property的逻辑隔离到单独的类中来处理。如果你发现自己正在不同的property之间重复着相同的逻辑，那么本文也许会成为一个线索供你思考为何用描述符重构代码是值得一试的。</p><h3 id="秘诀和陷阱"><a href="#秘诀和陷阱" class="headerlink" title="秘诀和陷阱"></a>秘诀和陷阱</h3><h4 id="把描述符放在类的层次上（class-level）"><a href="#把描述符放在类的层次上（class-level）" class="headerlink" title="把描述符放在类的层次上（class level）"></a>把描述符放在类的层次上（class level）</h4><p>为了让描述符能够正常工作，它们必须定义在类的层次上。如果你不这么做，那么Python无法自动为你调用__get__和__set__方法。</p><pre><code>class Broken(object):    y = NonNegative(5)    def __init__(self):        self.x = NonNegative(0)  # NOT a good descriptorb = Broken()print(&quot;X is %s , Y is %s&quot; % (b.x, b.y))</code></pre><p>运行结果：</p><pre><code>X is &lt;__main__.NonNegative object at 0x0000025D941AF358&gt; , Y is 5</code></pre><p>可以看到，访问类层次上的描述符y可以自动调用__get__。但是访问实例层次上的描述符x只会返回描述符本身，真是魔法一般的存在啊。</p><h4 id="确保实例的数据只属于实例本身"><a href="#确保实例的数据只属于实例本身" class="headerlink" title="确保实例的数据只属于实例本身"></a>确保实例的数据只属于实例本身</h4><p>你可能会像这样编写NonNegative描述符：</p><pre><code>class BrokenNonNegative(object):    def __init__(self, default):        self.value = default    def __get__(self, instance, owner):        return self.value    def __set__(self, instance, value):        if value &lt; 0:            raise ValueError(&quot;Negative value not allowed: %s&quot; % value)        self.value = valueclass Foo(object):    bar = BrokenNonNegative(5) f = Foo()try:    f.bar = -1except ValueError:    print &quot;Caught the invalid assignment&quot;</code></pre><p>运行结果：</p><pre><code>Caught the invalid assignment</code></pre><p>这么做看起来似乎能正常工作。但这里的问题就在于所有Foo的实例都共享相同的bar，这会产生一些令人痛苦的结果：</p><pre><code>class Foo(object):    bar = BrokenNonNegative(5) f = Foo()g = Foo()print (&quot;f.bar is %s\ng.bar is %s&quot; % (f.bar, g.bar))print &quot;Setting f.bar to 10&quot;f.bar = 10print (&quot;f.bar is %s\ng.bar is %s&quot; % (f.bar, g.bar))</code></pre><p>运行结果：</p><pre><code>f.bar is 5g.bar is 5Setting f.bar to 10f.bar is 10g.bar is 10</code></pre><p>这就是为什么我们要在NonNegative中使用数据字典的原因。__get__和__set__的第一个参数告诉我们需要关心哪一个实例。NonNegative使用这个参数作为字典的key，为每一个Foo实例单独保存一份数据。这就是描述符最令人感到别扭的地方（坦白的说，我不理解为什么Python不让你在实例的层次上定义描述符，并且总是需要将实际的处理分发给__get__和__set__。这么做行不通一定是有原因的）。</p><h4 id="注意不可哈希的描述符所有者"><a href="#注意不可哈希的描述符所有者" class="headerlink" title="注意不可哈希的描述符所有者"></a>注意不可哈希的描述符所有者</h4><p>NonNegative类使用了一个字典来单独保存专属于实例的数据。这个一般来说是没问题的，除非你用到了不可哈希（unhashable）的对象：</p><pre><code>class MoProblems(list):  #you can&apos;t use lists as dictionary keys    x = NonNegative(5)m = MoProblems()print (m.x)  # TypeError: unhashable type: &apos;MoProblems&apos;</code></pre><p>因为MoProblems的实例（list的子类）是不可哈希的，因此它们不能为MoProblems.x用做数据字典的key。有一些方法可以规避这个问题，但是都不完美。最好的方法可能就是给你的描述符加标签:</p><pre><code>class Descriptor(object):    def __init__(self, label):        self.label = label    def __get__(self, instance, owner):        print(&apos;__get__&apos;, instance, owner)        return instance.__dict__.get(self.label)    def __set__(self, instance, value):        print(&apos;__set__&apos;)        instance.__dict__[self.label] = valueclass Foo(list):    x = Descriptor(&apos;x&apos;)    y = Descriptor(&apos;y&apos;)f = Foo()f.x = 5print(f.x)</code></pre><p>运行结果：</p><pre><code>__set____get__ [] &lt;class &apos;__main__.Foo&apos;&gt;5</code></pre><p>这种方法依赖于Python的方法解析顺序（即，MRO）。我们给Foo中的每个描述符加上一个标签名，名称和我们赋值给描述符的变量名相同，比如x = Descriptor(‘x’)。之后，描述符将特定于实例的数据保存在f.__dict__[‘x’]中。这个字典条目通常是当我们请求f.x时Python给出的返回值。然而，由于Foo.x 是一个描述符，Python不能正常的使用f.__dict__[‘x’]，但是描述符可以安全的在这里存储数据。只是要记住，不要在别的地方也给这个描述符添加标签:</p><pre><code>class Foo(object):    x = Descriptor(&apos;y&apos;)f = Foo()f.x = 5print(f.x)print(f.__dict__)f.y = 4  # oh no!print(f.__dict__)print(f.x)</code></pre><p>运行结果：</p><pre><code>__set____get__ &lt;__main__.Foo object at 0x000001F2C89C0CF8&gt; &lt;class &apos;__main__.Foo&apos;&gt;5{&apos;y&apos;: 5}__get__ &lt;__main__.Foo object at 0x000001F2C89C0CF8&gt; &lt;class &apos;__main__.Foo&apos;&gt;4{&apos;y&apos;: 4}</code></pre><p>因为 f.x 描述符实际上就是 f.__dict__[‘y’]；f.y=4 相当于给实例f声明一个y属性，相当于f.__dict__[‘y’]=4，这样就改变了f.x的值。</p><h3 id="给描述符动态添加回调函数"><a href="#给描述符动态添加回调函数" class="headerlink" title="给描述符动态添加回调函数"></a>给描述符动态添加回调函数</h3><pre><code>from weakref import WeakKeyDictionaryclass CallbackProperty(object):    &quot;&quot;&quot;A property that will alert observers when upon updates&quot;&quot;&quot;    def __init__(self, default=None):        self.data = WeakKeyDictionary()        self.default = default        self.callbacks = WeakKeyDictionary()    def __get__(self, instance, owner):        if instance is None:            return self        return self.data.get(instance, self.default)    def __set__(self, instance, value):        for callback in self.callbacks.get(instance, []):            # alert callback function of new value            callback(value)        self.data[instance] = value    def add_callback(self, instance, callback):        &quot;&quot;&quot;Add a new function to call everytime the descriptor within instance updates&quot;&quot;&quot;        if instance not in self.callbacks:            self.callbacks[instance] = []        self.callbacks[instance].append(callback)class BankAccount(object):    balance = CallbackProperty(0)def low_balance_warning(value):    if value &lt; 100:        print(&quot;the value: %d  must be lgt 100&quot;%value)ba1 = BankAccount()ba2 = BankAccount()BankAccount.balance.add_callback(ba1, low_balance_warning)ba1.balance = 5000ba2.balance = 6000print(&quot;ba1 is %s and ba2 is %s&quot; % (ba1.balance,ba2.balance))ba1.balance = 99ba2.balance = 88print(&quot;ba1 is %s and ba2 is %s&quot; % (ba1.balance,ba2.balance))</code></pre><p>运行结果：</p><pre><code>ba1 is 5000 and ba2 is 6000the value: 99  must be lgt 100ba1 is 99 and ba2 is 88</code></pre><p>这是一个很有吸引力的模式——我们可以动态为某一个或多个实例添加自定义回调函数，执行一些特殊的处理逻辑，而且完全无需修改这个类的代码。</p><p>但是我们是如何做到的呢？当我们试图访问它们时，描述符总是会调用__get__。就好像add<em>callback方法是无法触及的一样！其实关键在于利用了一种特殊的情况，即，当从类的层次访问时，\</em>_get__方法的第一个参数是None。</p><h1 id="补充—属性查询优先级"><a href="#补充—属性查询优先级" class="headerlink" title="补充—属性查询优先级"></a>补充—属性查询优先级</h1><ol><li>__getattribute__()方法无条件调用</li><li>数据描述符</li><li>实例属性</li><li>非数据描述符</li><li>__getattr__()方法</li></ol><p>一个类，如果只定义了 __get__() 方法，而没有定义 __set__()或 __delete__() 方法则这个类是非数据描述符，反之则为数据描述符。</p><pre><code>class Desc(object):    def __init__(self, name):        self.name = name        print(&quot;__init__(): name = &quot;, self.name)    def __get__(self, instance, owner):        print(&quot;__get__() ...&quot;)        return self.name    def __set__(self, instance, value):        self.value = valueclass DescTest(object):    _x = Desc(&apos;x&apos;)    def __init__(self, x):        self._x = xt=DescTest(10)print(t._x)print(t.__dict__)</code></pre><p>运行结果：</p><pre><code>__init__(): name =  x__get__() ...x{}</code></pre><p>因为Desc类是一个数据描述符，优先级高于实例属性。当我们去掉 __set__()方法时结果就不一样了：<br>    class Desc(object):<br>        def <strong>init</strong>(self, name):<br>            self.name = name<br>            print(“<strong>init</strong>(): name = “, self.name)</p><pre><code>    def __get__(self, instance, owner):        print(&quot;__get__() ...&quot;)        return self.nameclass DescTest(object):    _x = Desc(&apos;x&apos;)    def __init__(self, x):        self._x = xt=DescTest(10)print(t._x)print(t.__dict__)</code></pre><p>运行结果：</p><pre><code>__init__(): name =  x10{&apos;_x&apos;: 10}</code></pre><p>实例属性的优先级高于非数据描述符。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>希望你现在对描述符是什么和它们的适用场景有了一个认识，前进吧骚年。</p><p>参考文章：<a href="http://python.jobbole.com/81899/" target="_blank" rel="external">解密 Python 的描述符（descriptor）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是描述符？&quot;&gt;&lt;a href=&quot;#什么是描述符？&quot; class=&quot;headerlink&quot; title=&quot;什么是描述符？&quot;&gt;&lt;/a&gt;什么是描述符？&lt;/h1&gt;&lt;p&gt;严格来讲：描述符实际上可以是任何一个（新式）类，这种类至少实现了三个特殊方法__get__()、__set__()、__delete__()中的一个，这三个特殊方法冲当描述符协议。（摘自核心编程）&lt;/p&gt;
&lt;p&gt;__get__()、__set__()及__delete__()的原型如下所示：&lt;/p&gt;
&lt;p&gt;　　① __get__(self, instance, owner) ==&amp;gt; Value&lt;/p&gt;
&lt;p&gt;　　② __set__(self, instance, value) ==&amp;gt;None&lt;/p&gt;
&lt;p&gt;　　③ __delete__(self, instance)  ==&amp;gt; None&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://waisunny.com/categories/Python/"/>
    
    
      <category term="python面向对象" scheme="http://waisunny.com/tags/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>【转】你真的理解python中的MRO算法吗？</title>
    <link href="http://waisunny.com/2018/01/25/%E4%BD%A0%E7%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3python%E4%B8%AD%E7%9A%84MRO%E7%AE%97%E6%B3%95%E5%90%97%EF%BC%9F/"/>
    <id>http://waisunny.com/2018/01/25/你真的理解python中的MRO算法吗？/</id>
    <published>2018-01-25T09:40:19.000Z</published>
    <updated>2018-02-02T02:18:40.775Z</updated>
    
    <content type="html"><![CDATA[<p>MRO（Method Resolution Order）：方法解析顺序。Python语言包含了很多优秀的特性，其中多重继承就是其中之一，但是多重继承会引发很多问题，比如二义性，Python中一切皆引用，这使得他不会像C++一样使用虚基类处理基类对象重复的问题，但是如果父类存在同名函数的时候还是会产生二义性，Python中处理这种问题的方法就是MRO。<br><a id="more"></a></p><p><strong>【历史中的MRO】</strong></p><p>如果不想了解历史，只想知道现在的MRO可以直接看最后的C3算法，不过C3所解决的问题都是历史遗留问题，了解问题，才能解决问题，建议先看历史中MRO的演化。</p><p><strong>Python2.2以前的版本：经典类（classic class）时代</strong></p><p>经典类是一种没有继承的类，实例类型都是type类型，如果经典类被作为父类，子类调用父类的构造函数时会出错。</p><p><strong>这时MRO的方法为DFS（深度优先搜索（子节点顺序：从左到右））。</strong></p><p>例子：</p><pre><code>Class A:   # 是没有继承任何父类的    def __init__(self):        print &quot;这是经典类&quot;</code></pre><p>inspect.getmro（A）可以查看经典类的MRO顺序：</p><pre><code>import inspectclass D:    passclass C(D):    passclass B(D):    passclass A(B, C):    passif __name__ == &apos;__main__&apos;:    print inspect.getmro(A)</code></pre><p>运行结果： A-&gt;B-&gt;D-&gt;C</p><pre><code>(&lt;class __main__.A at 0x000000000296DBE8&gt;, &lt;class __main__.B at 0x000000000296D948&gt;, &lt;class __main__.D at 0x000000000296D4C8&gt;, &lt;class __main__.C at 0x000000000296DC48&gt;)</code></pre><p>MRO的DFS顺序如下图：<br><img src="https://i.imgur.com/oJH2OT0.jpg" alt=""></p><p>两种继承模式在DFS下的优缺点。</p><p>第一种，我称为正常继承模式，两个互不相关的类的多继承，这种情况DFS顺序正常，不会引起任何问题；</p><p>第二种，菱形继承模式，存在公共父类（D）的多继承，这种情况下DFS必定经过公共父类（D），这时候想想，如果这个公共父类（D）有一些初始化属性或者方法，但是子类（C）又重写了这些属性或者方法，那么按照DFS顺序必定是会先找到D的属性或方法，那么C的属性或者方法将永远访问不到，导致C<strong>只能继承无法重写（override</strong>）。这也就是为什么新式类不使用DFS的原因，因为他们都有一个公共的祖先object。</p><p><strong>Python2.2版本：新式类（new-style class）诞生</strong></p><p>为了使类和内置类型更加统一，引入了新式类。新式类的每个类都继承于一个基类，可以是自定义类或者其它类，默认承于object。子类可以调用父类的构造函数。</p><p>这时有两种MRO的方法：</p><p><strong>1.如果是经典类MRO为DFS（深度优先搜索（子节点顺序：从左到右））。</strong></p><p><strong>2.如果是新式类MRO为BFS（广度优先搜索（子节点顺序：从左到右））。</strong></p><pre><code>Class A(object):   # 继承于object    def __init__(self):        print &quot;这是新式类&quot;A.__mro__ 可以查看新式类的顺序</code></pre><p>MRO的BFS顺序如下图：<br><img src="https://i.imgur.com/8TGGnON.jpg" alt=""></p><p>两种继承模式在BFS下的优缺点。</p><p>第一种，正常继承模式，看起来正常，不过实际上感觉很别扭，比如B明明继承了D的某个属性（假设为foo），C中也实现了这个属性foo，那么BFS明明先访问B然后再去访问C，但是为什么foo这个属性会是C？这种应该先从B和B的父类开始找的顺序，我们称之为<strong>单调性</strong>。</p><p>第二种，棱形继承模式，这种模式下面，BFS的查找顺序虽然解了DFS顺序下面的菱形问题，但是它也是违背了查找的<strong>单调性</strong>。</p><p>因为违背了单调性，所以BFS方法只在Python2.2中出现了，在其后版本中用C3算法取代了BFS。</p><p><strong>Python2.3到Python2.7：经典类、新式类和平发展</strong></p><p>因为之前的BFS存在较大的问题，所以从Python2.3开始新式类的MRO取而代之的是C3算法，我们可以知道C3算法肯定解决了单调性问题，和只能继承无法重写的问题。C3算法具体实现稍后讲解。</p><p>MRO的C3算法顺序如下图：看起简直是DFS和BFS的合体有木有。但是仅仅是看起来像而已。<br><img src="https://i.imgur.com/P2mkGUe.jpg" alt=""></p><p><strong>Python3到至今：新式类一统江湖</strong><br><strong>Python3开始就只存在新式类了，采用的MRO也依旧是C3算法。</strong></p><p><strong>【神奇的算法C3】</strong></p><p>C3算法解决了单调性问题和只能继承无法重写问题，在很多技术文章包括官网中的C3算法，都只有那个merge list的公式法，想看的话网上很多，自己可以查。但是从公式很难理解到解决这个问题的本质。我经过一番思考后，我讲讲我所理解的C3算法的本质。如果错了，希望有人指出来。</p><p>假设继承关系如下(<a href="https://www.python.org/download/releases/2.3/mro/#bad-method-resolution-orders" target="_blank" rel="external">官网</a>的例子)：</p><pre><code>class D(object):    passclass E(object):    passclass F(object):    passclass C(D, F):    passclass B(E, D):    passclass A(B, C):    passif __name__ == &apos;__main__&apos;:    print A.__mro__</code></pre><p>运行结果：<br>    (<class '__main__.a'="">, <class '__main__.b'="">, <class '__main__.e'="">, <class '__main__.c'="">, <class '__main__.d'="">, <class '__main__.f'="">, <type 'object'="">)</type></class></class></class></class></class></class></p><p>首先假设继承关系是一张图（事实上也是），我们按类继承是的顺序（class A(B, C)括号里面的顺序B，C），子类指向父类，构一张图：<br><img src="https://i.imgur.com/l0TT9rk.jpg" alt=""></p><p>我们要解决两个问题：<strong>单调性问题和不能重写的问题</strong>。</p><p>很容易发现要解决单调性，只要保证从根(A)到叶(object)，从左到右的访问顺序即可。</p><p>那么对于只能继承，不能重写的问题呢？先分析这个问题的本质原因，主要是因为先访问了子类的父类导致的。那么怎么解决这个问题呢？如果熟悉图论的人应该能马上想到拓扑排序，这里引用一下百科的的定义:</p><p>对一个有向无环图(Directed Acyclic Graph简称DAG)G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边(u,v)∈E(G)，则u在线性序列中出现在v之前。通常，这样的线性序列称为满足拓扑次序(Topological Order)的序列，简称拓扑序列。简单的说，由某个集合上的一个偏序得到该集合上的一个全序，这个操作称之为拓扑排序。</p><p>因为拓扑排序肯定是根到叶（也不能说是叶了，因为已经不是树了），所以只要满足从左到右，得到的拓扑排序就是结果，关于拓扑排序算法，大学的数据结构有教，这里不做讲解，不懂的可以自行谷歌或者翻一下书，建议了解完算法再往下看。</p><p>那么模拟一下例子的拓扑排序：首先找入度为0的点，只有一个A，把A拿出来，把A相关的边剪掉，再找下一个入度为0的点，有两个点（B,C）,取最左原则，拿B，这是排序是AB，然后剪B相关的边，这时候入度为0的点有E和C，取最左。这时候排序为ABE，接着剪E相关的边，这时只有一个点入度为0，那就是C，取C，顺序为ABEC。剪C的边得到两个入度为0的点（DF），取最左D，顺序为ABECD，然后剪D相关的边，那么下一个入度为0的就是F，然后是object。那么最后的排序就为:<strong>A-&gt;B-&gt;E-&gt;C-&gt;D-&gt;F-&gt;object</strong>。</p><p>本篇博文转自：<a href="http://python.jobbole.com/85685/" target="_blank" rel="external">你真的理解Python中MRO算法吗？</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MRO（Method Resolution Order）：方法解析顺序。Python语言包含了很多优秀的特性，其中多重继承就是其中之一，但是多重继承会引发很多问题，比如二义性，Python中一切皆引用，这使得他不会像C++一样使用虚基类处理基类对象重复的问题，但是如果父类存在同名函数的时候还是会产生二义性，Python中处理这种问题的方法就是MRO。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://waisunny.com/categories/Python/"/>
    
    
      <category term="python面向对象" scheme="http://waisunny.com/tags/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>python中的super()函数</title>
    <link href="http://waisunny.com/2018/01/23/python%E4%B8%AD%E7%9A%84super-%E5%87%BD%E6%95%B0/"/>
    <id>http://waisunny.com/2018/01/23/python中的super-函数/</id>
    <published>2018-01-23T14:50:41.000Z</published>
    <updated>2018-01-29T09:08:54.593Z</updated>
    
    <content type="html"><![CDATA[<p>super() 函数用于调用下一个父类(超类)并返回该父类的实例，主要用途是来查找父类的属性，比如 ，<br>super(MyClass,self).__init__()。它只能用在新式类中。</p><p>语法如下：</p><pre><code>super(type[, obj])</code></pre><p>super()“返回此 type 的父类”。如果你希望父类被绑定,你可以传入 obj 参数(obj必须是 type 类型的)。否则父类不会被绑定。obj 参数也可以是一个类型，但它应当是 type 的一个子类。通常，当给出 obj 时：</p><ol><li>如果 obj 是一个实例，<strong>isinstance(obj,type)</strong>就必须返回 True</li><li>如果 obj 是一个类或类型，<strong>issubclass(obj,type)</strong>就必须返回 True<a id="more"></a></li></ol><h1 id="super函数的作用"><a href="#super函数的作用" class="headerlink" title="super函数的作用"></a>super函数的作用</h1><p>使用 super()的漂亮之处在于，你不需要明确给出任何基类名字… “跑腿事儿”，它帮你干了！</p><p>使用 super()的重点，是你不需要明确提供父类。这意味着如果你改变了类继承关系，你只需要改一<br>行代码（class 语句本身）而不必在大量代码中去查找所有被修改的那个类的名字。</p><p>在多重继承的情况下会涉及到查找顺序（<strong>MRO</strong>）、重复调用等种种问题。使用super()来避免这些问题。</p><p><strong>MRO</strong> 就是类的方法解析顺序表, 其实也就是继承父类方法时的顺序表,下面会介绍到。</p><p>下面我们通过对比使用 super函数和基类类名调用父类方法来介绍super函数的作用：</p><!--more--><h2 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h2><p>先看一个单继承的例子：</p><pre><code>class BaseCls(object):    def __init__(self,name):        print(&apos;Create BaseCls,name is %s&apos;%name)        self.name=nameclass ChildA(BaseCls):    def __init__(self,name):        print(&apos;Create ChildA&apos;)        BaseCls.__init__(self,name)class ChildB(BaseCls):    def __init__(self,name):        print(&apos;Create ChildB&apos;)        super(ChildB,self).__init__(name)a=ChildA(&apos;_learner1&apos;)b=ChildB(&apos;_learner2&apos;)</code></pre><p>运行结果：</p><pre><code>Create ChildACreate BaseCls,name is _learner1Create ChildBCreate BaseCls,name is _learner2</code></pre><p><strong>区别是使用super()继承时不用显式引用基类。避免类名发生变化时我们需要调整继承的代码。</strong></p><h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><h3 id="继承顺序问题"><a href="#继承顺序问题" class="headerlink" title="继承顺序问题"></a>继承顺序问题</h3><p>在多重继承时会涉及继承顺序，<font size="4" color="red"><strong>super()相当于返回继承顺序的下一个类，而不是父类</strong></font>，类似于这样的功能：</p><pre><code>def super(class_name, self):      mro = self.__class__.mro()      return mro[mro.index(class_name) + 1]  </code></pre><p>mro()用来获得类的继承顺序。 例如：</p><pre><code>class Base(object):    def __init__(self):        print(&apos;Base Create&apos;)class ChildA(Base):    def __init__(self):        print(&apos;enter A &apos;)        super(ChildA, self).__init__()        print (&apos;leave A&apos;)class ChildB(Base):    def __init__(self):        print(&apos;enter B &apos; )        super(ChildB, self).__init__()        print (&apos;leave B&apos;)class ChildC(ChildA, ChildB):    passc = ChildC()print (c.__class__.__mro__ )</code></pre><p>运行结果：</p><pre><code>enter A enter B Base createleave Bleave A(&lt;class &apos;__main__.childC&apos;&gt;, &lt;class &apos;__main__.ChildA&apos;&gt;, &lt;class &apos;__main__.ChildB&apos;&gt;, &lt;class &apos;__main__.Base&apos;&gt;, &lt;class &apos;object&apos;&gt;)</code></pre><p>supder和父类没有关联，因此执行顺序是 A —&gt; B—&gt;—&gt;Base</p><p>执行过程相当于：</p><ol><li>初始化childC()时，先会去调用childA的构造方法__init__,输出 enter A;</li><li>然后执行super(childA, self).<strong>init</strong>()， super(ChildA, self)返回当前类的继承顺序中ChildA后的一个类childB;</li><li>因此会进入到childB类执行器构造方法输出 enter B;</li><li>然后执行 super(ChildB, self).<strong>init</strong>()，返回继承顺序的下一个类，即Base;</li><li>执行Base类的__init__构造方法，输出 Base Create；</li><li>然后继续执行，输出 leave B,最后就是 leave A。</li></ol><p>在上面的例子中，如果把继承方式由super换成Base.<em>init</em>(self)，会看到什么样的输出结果呢？</p><pre><code>class Base(object):    def __init__(self):        print(&apos;Base create&apos;)class ChildA(Base):    def __init__(self):        print(&apos;enter A &apos;)        Base.__init__(self)        print (&apos;leave A&apos;)class ChildB(Base):    def __init__(self):        print(&apos;enter B &apos; )        Base.__init__(self)        print (&apos;leave B&apos;)class childC(ChildA, ChildB):    passc = childC()print (c.__class__.__mro__ )</code></pre><p>运行结果：</p><pre><code>enter A Base createleave A(&lt;class &apos;__main__.childC&apos;&gt;, &lt;class &apos;__main__.ChildA&apos;&gt;, &lt;class &apos;__main__.ChildB&apos;&gt;, &lt;class &apos;__main__.Base&apos;&gt;, &lt;class &apos;object&apos;&gt;)</code></pre><p>能看出，继承ChildA后就会直接跳到Base类里，而略过了ChildB。</p><h3 id="重复调用问题"><a href="#重复调用问题" class="headerlink" title="重复调用问题"></a>重复调用问题</h3><p>如果ChildA基础Base, ChildB继承childA和Base，如果ChildB需要调用Base的<strong>init</strong>()方法时，就会导致__init__()被执行两次：</p><pre><code>class Base(object):    def __init__(self):        print(&apos;Base create&apos;)class ChildA(Base):    def __init__(self):        print(&apos;enter A &apos;)        Base.__init__(self)        print(&apos;leave A&apos;)class ChildB(ChildA, Base):    def __init__(self):        print(&apos;enter B&apos;)        ChildA.__init__(self)        Base.__init__(self)b = ChildB()print (b.__class__.mro())</code></pre><p>运行结果：</p><pre><code>enter Benter A Base createleave ABase create[&lt;class &apos;__main__.ChildB&apos;&gt;, &lt;class &apos;__main__.ChildA&apos;&gt;, &lt;class &apos;__main__.Base&apos;&gt;, &lt;class &apos;object&apos;&gt;]</code></pre><p>使用super()函数可避免重复调用：</p><pre><code>class Base(object):    def __init__(self):        print(&apos;Base create&apos;)class ChildA(Base):    def __init__(self):        print(&apos;enter A &apos;)        super(ChildA, self).__init__()        print(&apos;leave A&apos;)class ChildB(ChildA, Base):    def __init__(self):        print(&apos;enter B&apos;)        super(ChildB,self).__init__()b = ChildB()print (b.__class__.mro())  </code></pre><p>运行结果：</p><pre><code>enter Benter A Base createleave A[&lt;class &apos;__main__.ChildB&apos;&gt;, &lt;class &apos;__main__.ChildA&apos;&gt;, &lt;class &apos;__main__.Base&apos;&gt;, &lt;class &apos;object&apos;&gt;]</code></pre><h1 id="super-函数使用注意点"><a href="#super-函数使用注意点" class="headerlink" title="super()函数使用注意点"></a>super()函数使用注意点</h1><p>从super()方法可以看出，super()的第一个参数可以是继承链中任意一个类的名字。</p><p>如果是本身就会依次继承下一个类；</p><p>如果是继承链里之前的类便会无限递归下去；</p><p>如果是继承链里之后的类便会忽略继承链汇总本身和传入类之间的类；</p><p>看例子:</p><p>将ChildA()中的super改为：super(ChildC, self).<strong>init</strong>()，程序就会无限递归下去:</p><pre><code>class Base(object):    def __init__(self):        print(&apos;Base Create&apos;)class ChildA(Base):    def __init__(self):        print(&apos;enter A &apos;)        super(ChildC, self).__init__()        print (&apos;leave A&apos;)class ChildB(Base):    def __init__(self):        print(&apos;enter B &apos; )        super(ChildB, self).__init__()        print (&apos;leave B&apos;)class ChildC(ChildA, ChildB):    passc = ChildC()</code></pre><p>运行结果：</p><pre><code>enter A enter A enter A enter A enter A Traceback (most recent call last):RecursionError: maximum recursion depth exceeded while calling a Python object</code></pre><p>将ChildA()中的super改为：super(ChildB, self).<strong>init</strong>()，程序就会跳过ChildB:</p><pre><code>class Base(object):    def __init__(self):        print(&apos;Base Create&apos;)class ChildA(Base):    def __init__(self):        print(&apos;enter A &apos;)        super(ChildB, self).__init__()        print (&apos;leave A&apos;)class ChildB(Base):    def __init__(self):        print(&apos;enter B &apos; )        super(ChildB, self).__init__()        print (&apos;leave B&apos;)class ChildC(ChildA, ChildB):    passc = ChildC()</code></pre><p>运行结果：</p><pre><code>enter A Base Createleave A</code></pre><p>另外，super函数只能应用在新式类中，用在经典类中会报错的：</p><pre><code>class A:    def __init__(self):        print(&apos;Create A&apos;)class B(A):    def __init__(self):        print(&apos;Create B&apos;)        super(B,self).__init__()b=B()</code></pre><p>运行结果:</p><pre><code>Create BTraceback (most recent call last):     super(B,self).__init__()TypeError: must be type, not classobj</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>使用super()函数能规避掉多继承中U存在的各种问题，但要注意super函数的一个参数，一般都是当前类，一旦写错，会造成很严重的后果，另外super函数只能应用在新式类中，在涉及到调用父类方法时，推荐使用该函数。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;super() 函数用于调用下一个父类(超类)并返回该父类的实例，主要用途是来查找父类的属性，比如 ，&lt;br&gt;super(MyClass,self).__init__()。它只能用在新式类中。&lt;/p&gt;
&lt;p&gt;语法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;super(type[, obj])
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;super()“返回此 type 的父类”。如果你希望父类被绑定,你可以传入 obj 参数(obj必须是 type 类型的)。否则父类不会被绑定。obj 参数也可以是一个类型，但它应当是 type 的一个子类。通常，当给出 obj 时：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果 obj 是一个实例，&lt;strong&gt;isinstance(obj,type)&lt;/strong&gt;就必须返回 True&lt;/li&gt;
&lt;li&gt;如果 obj 是一个类或类型，&lt;strong&gt;issubclass(obj,type)&lt;/strong&gt;就必须返回 True
    
    </summary>
    
      <category term="Python" scheme="http://waisunny.com/categories/Python/"/>
    
    
      <category term="python面向对象" scheme="http://waisunny.com/tags/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>python 类属性和实例属性</title>
    <link href="http://waisunny.com/2018/01/20/python-%E7%B1%BB%E5%B1%9E%E6%80%A7-VS-%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7/"/>
    <id>http://waisunny.com/2018/01/20/python-类属性-VS-实例属性/</id>
    <published>2018-01-20T11:46:54.000Z</published>
    <updated>2018-01-28T06:05:16.981Z</updated>
    
    <content type="html"><![CDATA[<p>在介绍类属性和实例属性区别之前我们先来了解一下属性是什么？什么是类属性？什么是实例属性？类属性和实例属性的是如何查找访问的？</p><p><strong>（本篇博文实例代码均是在python3下的执行结果，python2下略有不同。）</strong><br><a id="more"></a></p><h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><p>什么是属性呢？属性就是属于另一个对象的数据或者函数元素,可以通过我们熟悉的句点属性标识法来访问。一些 Python 类型比如复数有数据属性（实部和虚部），而另外一些，像列表和字典，拥有方法（函数属性）。</p><p>上面的定义听起来太抽象了，下面还是整点实在的吧！</p><h2 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a>类属性</h2><pre><code>class A:    attr=1</code></pre><p>上面就定义的 attr就是一个类属性，类属性是和类直接绑定的，可以通过类直接访问，也可以通过类的实例访问。</p><pre><code>&gt;&gt;&gt; A.attr1</code></pre><h2 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h2><pre><code>&gt;&gt;&gt; a=A()&gt;&gt;&gt; a.x=1010</code></pre><p>上述代码定义了一个实例a然后动态的给实例a添加了一个属性x。</p><h2 id="实例属性和类属性的访问方式"><a href="#实例属性和类属性的访问方式" class="headerlink" title="实例属性和类属性的访问方式"></a>实例属性和类属性的访问方式</h2><p>在介绍如何访问属性之前我们先介绍一个特殊的属性__dict__，每一个类及其每一个实例均有自己的__dict__属性，这个属性就是用来存储类及其实列的属性，方法等的。还有一个内建函数dir()也是用来查看对象包含的属性，方法等的，下面让我们来看一下：</p><pre><code>&gt;&gt;&gt; class A:...     attr=1...     def showInfo():...         print(&apos;my name is showInfo&apos;)...&gt;&gt;&gt; A.__dict__mappingproxy({&apos;__module__&apos;: &apos;__main__&apos;, &apos;attr&apos;: 1, &apos;showInfo&apos;: &lt;function A.showInfo at 0x0000020F36E5A510&gt;, &apos;__dict__&apos;: &lt;attribute &apos;__dict__&apos; of &apos;A&apos; objects&gt;, &apos;__weakref__&apos;: &lt;attribute &apos;__weakref__&apos; of &apos;A&apos; objects&gt;, &apos;__doc__&apos;: None})&gt;&gt;&gt; dir(A)[&apos;__class__&apos;, &apos;__delattr__&apos;, &apos;__dict__&apos;, &apos;__dir__&apos;, &apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, &apos;__getattribute__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__init_subclass__&apos;, &apos;__le__&apos;, &apos;__lt__&apos;, &apos;__module__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;__weakref__&apos;, &apos;attr&apos;, &apos;showInfo&apos;]&gt;&gt;&gt; a=A()&gt;&gt;&gt; a.__dict__{}&gt;&gt;&gt; a.x=10&gt;&gt;&gt; a.__dict__{&apos;x&apos;: 10}&gt;&gt;&gt; dir(a)[&apos;__class__&apos;, &apos;__delattr__&apos;, &apos;__dict__&apos;, &apos;__dir__&apos;, &apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, &apos;__getattribute__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__init_subclass__&apos;, &apos;__le__&apos;, &apos;__lt__&apos;, &apos;__module__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;__weakref__&apos;, &apos;attr&apos;, &apos;showInfo&apos;, &apos;x&apos;]&gt;&gt;&gt; a2=A()&gt;&gt;&gt; a2.__dict__{}&gt;&gt;&gt; a2.y=20&gt;&gt;&gt; a2.__dict__{&apos;y&apos;: 20}&gt;&gt;&gt; dir(a2)[&apos;__class__&apos;, &apos;__delattr__&apos;, &apos;__dict__&apos;, &apos;__dir__&apos;, &apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, &apos;__getattribute__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__init_subclass__&apos;, &apos;__le__&apos;, &apos;__lt__&apos;, &apos;__module__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;__weakref__&apos;, &apos;attr&apos;, &apos;showInfo&apos;, &apos;y&apos;]&gt;&gt;&gt;</code></pre><p>dir()返回的是对象的属性的一个名字列表，它包含了一些内置的属性和方法名，而__dict__返回的是一个字典(可以把 <strong>mappingproxy</strong>理解成是字典)，它的键(keys)是属性名，键值(values)是相应的属性对象的数据值。另外，类的实例的__dict__只包含实例自己的属性和方法，默认是一个空字典。</p><p>当访问一个类属性的时候，Python 解释器将会搜索字典以得到需要的属性。如果在__dict__中没有找到，将会在基类的字典中进行搜索，采用“深度优先搜索”顺序。基类集的搜索是按顺序的，从左到右，按其在类定义时，定义父类参数时的顺序。对类的修改会仅影响到此类的字典；基类的__dict__属性不会被改动的。</p><p>当访问实例属性的时候，和访问类属性差不多，先在实例的字典中查找，如果__dict__中找不到再去类的字典找那个查找，然后就是类的基类里面去找。</p><p>如果要访问的属性最终没有找到就会抛出 <strong>AttributeError</strong> 异常。</p><h2 id="通过实例访问类属性的注意点"><a href="#通过实例访问类属性的注意点" class="headerlink" title="通过实例访问类属性的注意点"></a>通过实例访问类属性的注意点</h2><pre><code>class Student:    name=&apos;_learner&apos;s1=Student()s2=Student()print(&apos;Student:{n}，s1:{n1}，s2:{n2}&apos;.format(n=Student.name,n1=s1.name,n2=s2.name))print(s1.__dict__)s1.name=&apos;Wai&apos;print(s1.__dict__)print(&apos;Student:{n}，s1:{n1}，s2:{n2}&apos;.format(n=Student.name,n1=s1.name,n2=s2.name))Student.name=&apos;Sunny&apos;print(&apos;Student:{n}，s1:{n1}，s2:{n2}&apos;.format(n=Student.name,n1=s1.name,n2=s2.name))del s1.nameprint(&apos;Student:{n}，s1:{n1}，s2:{n2}&apos;.format(n=Student.name,n1=s1.name,n2=s2.name))print(s1.__dict__)</code></pre><p>运行结果：</p><pre><code>Student:_learner，s1:_learner，s2:_learner{}{&apos;name&apos;: &apos;Wai&apos;}Student:_learner，s1:Wai，s2:_learnerStudent:Sunny，s1:Wai，s2:SunnyStudent:Sunny，s1:Sunny，s2:Sunny{}</code></pre><p>从上面的例子可以看出，在编写程序的时候，千万不要对实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。</p><p>核心提示：使用类属性来修改自身（不是实例属性）正如上面所看到的那样，使用实例属性来试着修改类属性是很危险的。原因在于实例拥有它们自已的属性集__dict__。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>python中类及实例的属性访问是通过字典__dict__实现的，另外，切记不要定义同名的类属性和实例属性，这样使用实例访问是会覆盖掉类属性，当修改类属性值时使用类修改而不是用实例修改。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在介绍类属性和实例属性区别之前我们先来了解一下属性是什么？什么是类属性？什么是实例属性？类属性和实例属性的是如何查找访问的？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（本篇博文实例代码均是在python3下的执行结果，python2下略有不同。）&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://waisunny.com/categories/Python/"/>
    
    
      <category term="python面向对象" scheme="http://waisunny.com/tags/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>python中 __new__和__init__的区别</title>
    <link href="http://waisunny.com/2018/01/18/python%E4%B8%AD%20__new__%E5%92%8C__init__%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://waisunny.com/2018/01/18/python中 __new__和__init__的区别/</id>
    <published>2018-01-18T09:14:27.000Z</published>
    <updated>2018-01-26T01:59:06.579Z</updated>
    
    <content type="html"><![CDATA[<p>新式类内置有__new__方法而经典类没有__new__方法，只有__init__方法。</p><p>在python中创建类的一个实例时，如果该类具有__new__方法，会先调用__new__方法，__new__方法接受当前正在实例化的类作为第一个参数（这个参数的类型是type，这个类型在c和python的交互编程中具有重要的角色，感兴趣的可以搜下相关的资料），其返回值是本次创建产生的实例，也就是我们熟知的__init__方法中的第一个参数self。那么就会有一个问题，这个实例怎么得到？<br><a id="more"></a></p><p>有__new__方法的都是object类(新式类)的后代，因此如果我们自己想要改写__new__方法（注意不改写时在创建实例的时候使用的是父类的__new__方法，如果父类没有则继续上溯）可以通过调用object的__new__方法类得到这个实例（这实际上也和python中的默认机制基本一致），如：</p><pre><code>class display(object):    def __init__(self, *args, **kwargs):        print(&quot;init&quot;)    def __new__(cls, *args, **kwargs):        print(&quot;new&quot;)        print(type(cls))        return object.__new__(cls, *args, **kwargs)  a=display()</code></pre><p>结果：</p><pre><code>new&lt;class &apos;type&apos;&gt;init</code></pre><p>因此我们可以得到如下结论：</p><p><strong>在实例创建过程中__new__方法先于__init__方法被调用，它的第一个参数类型为type,返回值是当前实例对象。</strong></p><p><strong>如果不需要其它特殊的处理，可以使用object的__new__方法来得到创建的实例（也即self)。</strong></p><p><strong>于是我们可以发现，实际上可以使用其它类的__new__方法类得到这个实例，只要那个类或其父类或祖先有__new__方法。</strong></p><pre><code>class another(object):    def __new__(cls,*args,**kwargs):        print(&quot;newano&quot;)        return object.__new__(cls, *args, **kwargs)  class display(object):    def __init__(self, *args, **kwargs):        print(&quot;init&quot;)    def __new__(cls, *args, **kwargs):        print(&quot;newdis&quot;)        print(type(cls))        return another.__new__(cls, *args, **kwargs)  a=display()</code></pre><p>结果：</p><pre><code>newdis&lt;class &apos;type&apos;&gt;newanoinit</code></pre><font size="4"><strong>总结</strong></font><p>我们发现__new__和__init__就像这么一个关系，__new__提供生产的原料self(但并不保证这个原料来源正宗，像上面那样它用的是另一个不相关的类的<strong>new</strong>方法类得到这个实例)，而__init__就用__new__给的原料来完善这个对象（尽管它不知道这些原料是不是正宗的）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;新式类内置有__new__方法而经典类没有__new__方法，只有__init__方法。&lt;/p&gt;
&lt;p&gt;在python中创建类的一个实例时，如果该类具有__new__方法，会先调用__new__方法，__new__方法接受当前正在实例化的类作为第一个参数（这个参数的类型是type，这个类型在c和python的交互编程中具有重要的角色，感兴趣的可以搜下相关的资料），其返回值是本次创建产生的实例，也就是我们熟知的__init__方法中的第一个参数self。那么就会有一个问题，这个实例怎么得到？&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://waisunny.com/categories/Python/"/>
    
    
      <category term="python面向对象" scheme="http://waisunny.com/tags/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>python中 __slots__属性详解</title>
    <link href="http://waisunny.com/2018/01/15/python%E4%B8%AD-slots-%E8%AF%A6%E8%A7%A3/"/>
    <id>http://waisunny.com/2018/01/15/python中-slots-详解/</id>
    <published>2018-01-15T08:26:28.000Z</published>
    <updated>2018-01-28T02:59:14.200Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>新式类增加了__slots__内置属性, 它的作用是把实例属性锁定到__slots__规定的范围内。</p><p>__slots__是一个元组，包括了当前能访问到的属性。当定义了slots后，slots中定义的变量变成了类的描述符，相当于java，c++中的成员变量声明，类的实例只能拥有slots中定义的变量。</p><p>看下面的例子：<br><a id="more"></a></p><p>例一：</p><pre><code>class A(object):    attr=1a=A()print(a.__dict__)a.x=10print(a.x)print(a.__dict__)</code></pre><p>结果：</p><pre><code>{}10{&apos;x&apos;: 10}</code></pre><p>例二：</p><pre><code>class A(object):    attr=1    __slots__=(&apos;x&apos;,&apos;y&apos;)print(a.x)  # AttributeError: xa=A()#a.__dict__ # AttributeError: &apos;A&apos; object has no attribute &apos;__dict__&apos;a.x=10#a.z=20     # AttributeError: &apos;A&apos; object has no attribute &apos;z&apos;print(a.x)</code></pre><p>结果：</p><pre><code>10</code></pre><p>通过上面的例子我们能看出，没有定义__slots__的类的实例包含__dict__属性，它是一个字典，默认为空，可以通过该属性动态添加属性，方法等。</p><p>但当定义了__slots__属性后，__dict__属性就没了，因此不能动态添加属性了，只能使用__slots__元组中规定的属性，前提是要先赋值。</p><p>Python是一门动态语言，可以在运行过程中，修改实例的属性和增删方法，使用__slots__属性后失去了这个特性；那么__slots__属性有什么用呢？继续往下面看：</p><h1 id="Slots的实现"><a href="#Slots的实现" class="headerlink" title="Slots的实现"></a>Slots的实现</h1><p>我们首先来看看用纯Python是如何实现__slots\__（为了将以下实现的slots与原slots区分开来，代码中用单下划线的_slots_来代替)</p><pre><code>class Member(object):    # 定义描述器实现slots属性的查找    def __init__(self, i):        self.i = i    def __get__(self, obj, type=None):        return obj._slotvalues[self.i]    def __set__(self, obj, value):        obj._slotvalues[self.i] = valueclass Type(type):    # 使用元类实现slots    def __new__(self, name, bases,  namespace):        slots = namespace.get(&apos;_slots_&apos;)        if slots:            for i, slot in enumerate(slots):                namespace[slot] = Member(i)            original_init = namespace.get(&apos;__init__&apos;)            def __init__(self, *args, **kwargs):                # 创建_slotvalues列表和调用原来的__init__                self._slotvalues = [None] * len(slots)                if original_init(self, *args, **kwargs):                    original_init(self, *args, **kwargs)            namespace[&apos;__init__&apos;] = __init__        return type.__new__(self, name, bases, namespace)# Python2与Python3使用元类的区别    try:    class Object(object): __metaclass__ = Typeexcept:    class Object(metaclass=Type): passclass A(Object):    _slots_ = &apos;x&apos;, &apos;y&apos;a = A()a.x = 10print(a.x)</code></pre><p>在<strong>CPython</strong>中，当一个A类定义了__slots__ = (‘x’, ‘y’)，A.x就是一个有__get__和__set__方法的member<em>descriptor，并且在每个实例中可以通过直接访问内存（direct memory access）获得。（具体实现是用偏移地址来记录描述器，通过公式可以直接计算出其在内存中的实际地址 ，访问\</em>_dict__也是用相同的方法，也就是说访问A.__dict__和A.x描述器的速度是相近的）。</p><p>在上面的例子中，我们用纯Python实现了一个等价的slots。当一个元类看到_slots_定义了x和y，它会创建两个的类变量，x = Member(0)和y = Member(1)。然后，装饰__init__方法让新的实例创建一个_slotvalues列表。</p><p><strong>例子中的实现和CPython不同的是</strong>：</p><p>例子中_slotvalues是一个存储在类对象外部的列表，而在<strong>CPython</strong>中它与实例对象存储在一起，可以通过直接访问内存获得。相应地，member decriptor也不是存在外部列表中，而同样可以通过直接访问内存获得。</p><p>默认情况下，__new__方法会为每个实例创建一个字典__dict__来存储实例的属性。但如果定义了__slots__，__new__方法就不会再创建这个字典。</p><p>由于不存在__dict__来存储新的属性，所以使用一个不在__slots__中的属性时，程序会报错。</p><h2 id="更快的属性访问速度"><a href="#更快的属性访问速度" class="headerlink" title="更快的属性访问速度"></a>更快的属性访问速度</h2><p>默认情况下，访问一个实例的属性是通过访问该实例的__dict__来实现的。如访问a.x就相当于访问a.__dict__[‘x’]。为了便于理解，我粗略地将它拆分为四步：</p><ol><li>a.x </li><li>a.__dict__ </li><li>a.__dict__[‘x’] </li><li>结果</li></ol><p>从__slots__的实现可以得知，定义了__slots__的类会为每个属性创建一个描述器。访问属性时就直接调用这个描述器。在这里我将它拆分为三步：</p><ol><li>b.x </li><li>member decriptor </li><li>结果</li></ol><p>我在上文提到，访问__dict__和描述器的速度是相近的，而通过__dict__访问属性多了a.__dict__[‘x’]字典访值一步（一个哈希函数的消耗）。由此可以推断出，使用了__slots__的类的属性访问速度比没有使用的要快。下面用一个例子验证：</p><pre><code>from timeit import repeatclass A(object): passclass B(object): __slots__ = (&apos;x&apos;)def get_set_del_fn(obj):    def get_set_del():        obj.x = 1        obj.x        del obj.x    return get_set_dela = A()b = B()ta = min(repeat(get_set_del_fn(a)))tb = min(repeat(get_set_del_fn(b)))print(&quot;%.2f%%&quot; % ((ta/tb - 1)*100))</code></pre><p>在本人电脑上测试速度有10%-20%的提升。</p><h2 id="减少内存消耗"><a href="#减少内存消耗" class="headerlink" title="减少内存消耗"></a>减少内存消耗</h2><p><strong>Python内置的字典本质是一个哈希表，它是一种用空间换时间的数据结构。为了解决冲突的问题，当字典使用量超过2/3时，Python会根据情况进行2-4倍的扩容。由此可预见，取消__dict__的使用可以大幅减少实例的空间消耗。</strong></p><p>下面使用memory_profiler模块，memory_profiler模块是在逐行的基础上，测量代码的内存使用率。尽管如此，它可能使得你的代码运行的更慢。使用装饰器@profile来标记哪个函数被跟踪。</p><pre><code>from  memory_profiler import profileclass A(object):  # 没有定义__slots__属性    def __init__(self, x):        self.x = x@profiledef main():    f = [A(523825) for i in range(100000)]if __name__ == &apos;__main__&apos;:    main()</code></pre><p>运行结果：</p><pre><code>Line #    Mem usage    Increment   Line Contents================================================ 7        17.2 MiB     17.2 MiB    @profile 8                                 def main(): 9        35.3 MiB     17.0 MiB       f = [A(523825) for i in range(100000)]</code></pre><p>第2列表示该行执行后Python解释器的内存使用情况，第3列表示该行代码执行前后的内存变化。</p><p>在没有定义__slots__属性的情况下，该代码共使用了(17.2+17.0)MiB内存。</p><p>从结果可以看出，内存使用是以MiB为单位衡量的,表示的mebibyte(1MiB = 1.05MB)。</p><pre><code>from memory_profiler import profileclass A(object):  # 定义了__slots__属性    __slots__ = (&apos;x&apos;)    def __init__(self, x):        self.x = x@profiledef main():    f = [A(523825) for i in range(100000)]if __name__ == &apos;__main__&apos;:    main()</code></pre><p>运行结果：</p><pre><code>Line #    Mem usage    Increment   Line Contents================================================   7      16.9 MiB     16.9 MiB   @profile   8                              def main():   9      22.9 MiB     6.0 MiB       f = [A(523825) for i in range(100000)]</code></pre><p>定义__slots__属性的情况下，该代码共使用了(16.9+6.0)MiB内存。</p><p>从上述结果可看到使用__slots__能极大地减少内存空间的消耗，这也是最常见到的用法。</p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>1.只有非字符串的迭代器可以赋值给__slots__</p><pre><code>&gt;&gt;&gt; class A(object): __slots__ = (&apos;a&apos;, &apos;b&apos;, &apos;c&apos;)&gt;&gt;&gt; class B(object): __slots__ = &apos;abcd&apos;&gt;&gt;&gt; B.__slots__&apos;abc&apos;</code></pre><p>若直接将字符串赋值给它，就只有一个属性。</p><p>2.关于__slots__的继承问题</p><p>在一般情况下，使用__slots__的类需要直接继承object，如class Foo(object): __slots__ = ()</p><p>在继承自己创建的类时，我根据子类父类是否定义了__slots__，将它细分为六种情况:</p><p>① 父类有，子类没有：</p><p>子类的实例还是会自动创建__dict__来存储属性，不过父类__slots__已有的属性不受影响。</p><pre><code>&gt;&gt;&gt; class Father(object): __slots__ = (&apos;x&apos;)&gt;&gt;&gt; class Son(Base): pass&gt;&gt;&gt; son = Son()&gt;&gt;&gt; son.x, son.y = 1, 1&gt;&gt;&gt; son.__dict__&gt;&gt;&gt; {&apos;y&apos;: 1}</code></pre><p>② 父类没有，子类有：</p><p>虽然子类取消了__dict__，但继承父类后它会继续生成。同上面一样，__slots__已有的属性不受影响。</p><pre><code>&gt;&gt;&gt; class Father(object): pass&gt;&gt;&gt; class Son(Father): __slots__ = (&apos;x&apos;)&gt;&gt;&gt; son = Son()&gt;&gt;&gt; son.x, son.y = 1, 1&gt;&gt;&gt; son.__dict__&gt;&gt;&gt; {&apos;y&apos;: 1}</code></pre><p>③ 父类有，子类有：</p><p>只有子类的__slots__有效，访问父类有子类没有的属性依然会报错。</p><pre><code>&gt;&gt;&gt; class Father(object): __slots__ = (&apos;x&apos;, &apos;y&apos;)&gt;&gt;&gt; class Son(Father): __slots__ = (&apos;x&apos;, &apos;z&apos;)&gt;&gt;&gt; son = Son()&gt;&gt;&gt; son.x, son.y, son.z = 1, 1, 1Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;AttributeError: &apos;Son&apos; object has no attribute &apos;y&apos;</code></pre><p>④ 多个拥有非空__slots__的父类：</p><p>由于__slots__的实现不是简单的列表或字典，多个父类的非空__slots__不能直接合并，所以使用时会报错（即使多个父类的非空__slots__是相同的）。</p><pre><code>&gt;&gt;&gt; class Father(object): __slots__ = (&apos;x&apos;)&gt;&gt;&gt; class Mother(object): __slots__ = (&apos;x&apos;)&gt;&gt;&gt; class Son(Father, Mother): passTraceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: Error when calling the metaclass basesmultiple bases have instance lay-out conflict</code></pre><p>⑤ 多个空__slots__的父类：</p><p>这是关于__slots__使用多继承唯一办法。</p><p>⑥ 某些父类有，某些父类没有：</p><p>跟第一种情况类似。</p><p>为了正确使用__slots__，最好直接继承object。如有需要用到其他父类，则父类和子类都要定义__slots__，还要记得子类的__slots__会覆盖父类的__slots__;除非所有父类的__slots__都为空，否则不要使用多继承。</p><p>3.添加__dict__获取动态特性</p><p>在特殊情况下，可以在__slots__里添加__dict__来获取与普通实例同样的动态特性。</p><pre><code>&gt;&gt;&gt; class A(object): __slots__ = ()&gt;&gt;&gt; class B(A): __slots__ = (&apos;__dict__&apos;, &apos;x&apos;)&gt;&gt;&gt; b = B()&gt;&gt;&gt; b.x, b.y = 1, 1&gt;&gt;&gt; b.__dict__{&apos;y&apos;: 1}</code></pre><p>4.添加__weakref__获取弱引用功能</p><p>__slots__的实现不仅取消了__dict__的生成，也取消了__weakref__的生成。同样的，在__slots__将其添加可以重新获取弱引用这一功能。</p><p>5.如果类变量与__slots__的变量同名，则该变量被设置为readonly！！！</p><pre><code>class base(object):      __slots__=(&apos;y&apos;)      y=22 # y是类变量,y与__slots__中的变量同名      var=11      def __init__(self):          pass  b=base()  print (b.y)  print (base.y)  #b.y=66 #AttributeError: &apos;base&apos; object attribute &apos;y&apos; is read-only  </code></pre><p>运行结果：</p><pre><code>2222</code></pre><p>6.namedtuple</p><p>利用内置的namedtuple不可变的特性，结合__slots__，能创建出一个轻量不可变的实例。(约等于一个元组的大小)</p><pre><code>&gt;&gt;&gt; from collections import namedtuple&gt;&gt;&gt; class MyNt(namedtupele(&apos;MyNt&apos;, &apos;bar baz&apos;)): __slots__ = ()&gt;&gt;&gt; nt = MyNt(&apos;r&apos;, &apos;z&apos;)&gt;&gt;&gt; nt.bar&apos;r&apos;&gt;&gt;&gt; nt.baz&apos;z&apos;</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>当一个类需要创建大量实例时，可以使用__slots__来减少内存消耗。如果对访问属性的速度有要求，也可以酌情使用。另外可以利用__slots__的特性来限制实例的属性。而用在普通类身上时，使用__slots__后会丧失动态添加属性和弱引用的功能，进而引起其他错误，所以在一般情况下不要使用它。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;新式类增加了__slots__内置属性, 它的作用是把实例属性锁定到__slots__规定的范围内。&lt;/p&gt;
&lt;p&gt;__slots__是一个元组，包括了当前能访问到的属性。当定义了slots后，slots中定义的变量变成了类的描述符，相当于java，c++中的成员变量声明，类的实例只能拥有slots中定义的变量。&lt;/p&gt;
&lt;p&gt;看下面的例子：&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://waisunny.com/categories/Python/"/>
    
    
      <category term="python面向对象" scheme="http://waisunny.com/tags/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>python中__get__、__getattr__、__getattribute__详解</title>
    <link href="http://waisunny.com/2018/01/12/python%E4%B8%AD-get-getattr-getattribute-%E8%AF%A6%E8%A7%A3/"/>
    <id>http://waisunny.com/2018/01/12/python中-get-getattr-getattribute-详解/</id>
    <published>2018-01-12T08:25:32.000Z</published>
    <updated>2018-01-26T01:38:40.136Z</updated>
    
    <content type="html"><![CDATA[<p>__get__,__getattr__和__getattribute__（只存在于新式类）都是访问属性的方法，但有一定的区别。 </p><pre><code>object.__getattr__(self, name) </code></pre><p>通过实例访问属性时，若属性不存在则会调用__getattr__方法，默认触发AttributeError异常；若属性存在，但手动引发AttributeError异常，也会调用__getattr__方法，好比一个异常处理函数。</p><pre><code>object.__getattribute__(self, name) </code></pre><p>通过实例访问属性时，__getattribute__方法是无条件调用的，无论被访问的属性是否存在，它都会被触发，并返回属性本身；</p><pre><code>object.__get__(self, instance, owner) </code></pre><p>如果class定义了它，则这个class就可以称为descriptor。owner是所有者的类，instance是访问descriptor的实例，如果不是通过实例访问，而是通过类访问的话，instance则为None。需要注意的是：descriptor的实例自己访问自己时不会触发__get__，而会触发__call__，只有descriptor作为其它类的属性才有意义。</p><p>前两个都是通过实例访问才会触发，最后一个通过类或实例访问都可以触发，下面我们看一个例子，加深一下理解：</p><a id="more"></a><pre><code>class C(object):                                                          a = &apos;abc&apos;                                                             def __getattribute__(self, *args, **kwargs):                              print(&quot;__getattribute__() is called&quot;)                                 return object.__getattribute__(self, *args, **kwargs)             def __getattr__(self, name):                                              print(&quot;__getattr__() is called &quot;)                                     return name + &quot; from getattr&quot;                                     def __get__(self, instance, owner):                                       print(&quot;__get__() is called&quot;, instance, owner)                 class C2(object):                                                         d = C()                                                           if __name__ == &apos;__main__&apos;:                                                c = C()    c2 = C2()                                                           print(c.a)                                                          print(c.zzzzzzzz)                                                   c2.d                                                                print(c2.d.a)    </code></pre><p>运行结果：</p><pre><code>__getattribute__() is calledabc__getattribute__() is called__getattr__() is called zzzzzzzz from getattr(&apos;__get__() is called&apos;, &lt;__main__.C2 object at 0x0000000002A76400&gt;, &lt;class &apos;__main__.C2&apos;&gt;)(&apos;__get__() is called&apos;, &lt;__main__.C2 object at 0x0000000002A76400&gt;, &lt;class &apos;__main__.C2&apos;&gt;)__getattribute__() is calledabc   </code></pre><p>简单说明一下：</p><p>if里面前两行是获取类实例，不会有任何输出；</p><p>第三行通过实例c访问存在的属性a会调用 __getattribute__ 方法，看到前两行输出结果；</p><p>第四行通过实例访问不存在的属性zzzzzzzz会先调用__getattribute__ 方法然后调用__getattr__方法，看到了3~5行的输出结果；</p><p>第五行通过C2的实例访问其属性d，d又是C类的一个实例，所以会触发__get__方法，看到第六行输出结果。</p><p>第六行通过C2的属性d（C的实例）调用C存在的属性a会先触发方法__get__然后调用__getattribute__ 方法，看到7~9行输出。</p><font size="5"><strong>补充</strong></font><p>大多时候我们并不太需要关注__getattribute__ 和__getattr__的一些细节，一般情况下使用我们自定义的类的时候，我们对类的结构都了解，不会刻意偏离，造成一些属性访问的错误等。</p><p>值得一提的是，适当的重写会使我们的程序变的优雅，但也有一些需要注意的地方，看下面的例子：</p><p>链式生成url:</p><pre><code>class UrlGenerator(object):                                            def __init__(self, root_url):                                          self.url = root_url                                            def __getattr__(self, item):                                           if item == &apos;get&apos; or item == &apos;post&apos;:                                    print (self.url)                                               return UrlGenerator(&apos;{}/{}&apos;.format(self.url, item))        url_gen = UrlGenerator(&apos;http://www.aa.com&apos;)                        url_gen.users.show.get</code></pre><p>结果：</p><pre><code>http://www.aa.com/users/show     </code></pre><p>充分利用getattr会在没有查找到相应实例属性时被调用的特点，方便的通过链式调用生成对应的url，源代码中在碰到http method的时候返回一个<br>可调用的对象更加的优雅，链式的操作不仅优雅而且还能很好的说明调用的接口的意义（restful的接口啦）。</p><font size="4"><strong>注意点：</strong></font><p><strong>1.自定义getattribute的时候防止无限递归</strong></p><p>因为getattribute在访问属性的时候一直会被调用，自定义的getattribute方法里面同时需要返回相应的属性，通过self.<strong>dict</strong>取值会继续向下调用getattribute，造成循环调用：</p><pre><code>class A(object):                                                                                                         def __getattribute__(self, item):                                                                                        print(item)                                                                                                          return self.__dict__[item]    #RuntimeError: maximum recursion depth exceeded while calling a Python object  a=A()                                                                                                                a.aaa                                                                                                                </code></pre><p>上面的代码运行会输出 aaa ，但是会报超出最大递归深度的异常，这是需要重点注意的。                                                                                                                     </p><pre><code>class A(object):                                                                                                         def __getattribute__(self, item):                                                                                        try:                                                                                                                     print(item)                                                                                                          super(A,self).__getattribute__(item)# AttributeError: &apos;A&apos; object has no attribute &apos;aaa&apos;                          except KeyError as e:                                                                                                    return &apos;default&apos;                                                                                         a=A()                                                                                                                a.aaa                                                                                                                </code></pre><p>上面的代码运行也会输出 aaa ,aaa这个属性找不到，然后抛出AttributeError，调用 __getattr__方法。这也是我们想要的结果。</p><p><strong>2.同时覆盖掉__getattribute__和__getattr__的时候，在__getattribute__中需要模仿原本的行为抛出AttributeError或者手动调用__getattr__</strong></p><pre><code>class A(object):                                               def  __init__(self,name):                                      self.name=name                                         def __getattribute__(self, item):                              try:                                                           return super(A,self).__getattribute__(item)            except KeyError:                                               return &apos;default&apos;                                       except AttributeError as e:                                    print(e)                                           def __getattr__(self, item):                                   return &apos;default&apos;                                   a=A(&apos;_learner&apos;)                                            print(a.name)                                              print(a.age)                                               </code></pre><p>运行结果：</p><pre><code>_learner&apos;A&apos; object has no attribute &apos;age&apos;None</code></pre><p>上面例子里面的getattr方法根本不会被调用，因为原本的AttributeError被我们自行处理并未抛出，也没有手动调用getattr，所以访问age的结果是None而不是default.</p><font size="5"><strong>总结</strong></font><p>每次通过实例访问属性，都会经过__getattribute__函数。而当属性不存在时，仍然需要访问__getattribute__，不过接着要访问__getattr__，_getattr__好像是一个异常处理函数。 </p><p>每次访问descriptor（即实现了__get__的类），都会先经过__get__函数。 </p><p>当使用类访问不存在的变量时，不会经过__getattr__函数。而descriptor不存在此问题，只是把instance标识为none而已。</p><p>在重写 __getattribute__、_getattr__方法时，要注意堆栈溢出以及吃掉AttributeError异常的问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;__get__,__getattr__和__getattribute__（只存在于新式类）都是访问属性的方法，但有一定的区别。 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;object.__getattr__(self, name) 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过实例访问属性时，若属性不存在则会调用__getattr__方法，默认触发AttributeError异常；若属性存在，但手动引发AttributeError异常，也会调用__getattr__方法，好比一个异常处理函数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;object.__getattribute__(self, name) 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过实例访问属性时，__getattribute__方法是无条件调用的，无论被访问的属性是否存在，它都会被触发，并返回属性本身；&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;object.__get__(self, instance, owner) 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果class定义了它，则这个class就可以称为descriptor。owner是所有者的类，instance是访问descriptor的实例，如果不是通过实例访问，而是通过类访问的话，instance则为None。需要注意的是：descriptor的实例自己访问自己时不会触发__get__，而会触发__call__，只有descriptor作为其它类的属性才有意义。&lt;/p&gt;
&lt;p&gt;前两个都是通过实例访问才会触发，最后一个通过类或实例访问都可以触发，下面我们看一个例子，加深一下理解：&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://waisunny.com/categories/Python/"/>
    
    
      <category term="python面向对象" scheme="http://waisunny.com/tags/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>python面向对象初识-新式类VS经典类</title>
    <link href="http://waisunny.com/2018/01/11/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%9D%E8%AF%86-%E6%96%B0%E5%BC%8F%E7%B1%BBVS%E7%BB%8F%E5%85%B8%E7%B1%BB/"/>
    <id>http://waisunny.com/2018/01/11/python面向对象初识-新式类VS经典类/</id>
    <published>2018-01-10T18:15:58.000Z</published>
    <updated>2018-02-02T02:22:28.879Z</updated>
    
    <content type="html"><![CDATA[<p>在python2.x中，从object继承得来的类称为新式类（如class A(object)）不从object继承得来的类称为经典类（如class A()）；python3中所有的类都为新式类。</p><p>那么新式类和经典类有啥区别呢？ 主要区别体现在五个方面，接下来我们详细介绍一下。<br><a id="more"></a></p><font size="4"><strong>__class__属性</strong></font><p>新式类对象有__class__属性， 可以直接通过__class__属性获取自身类型:type;经典类没有这个属性。</p><p>经典类：</p><pre><code>&gt;&gt;&gt; class A:...     pass...&gt;&gt;&gt; A.__class__Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;AttributeError: class A has no attribute &apos;__class__&apos;&gt;&gt;&gt; type(A)&lt;type &apos;classobj&apos;&gt;&gt;&gt;&gt; a=A()&gt;&gt;&gt; a.__class__&lt;class __main__.A at 0x00000000006277C8&gt;&gt;&gt;&gt; type(a)&lt;type &apos;instance&apos;&gt;&gt;&gt;&gt; a.__class__ is type(a)False</code></pre><p>新式类：</p><pre><code>&gt;&gt;&gt; class B(object):...     pass...&gt;&gt;&gt; B.__class__&lt;type &apos;type&apos;&gt;&gt;&gt;&gt; type(B)&lt;type &apos;type&apos;&gt;&gt;&gt;&gt; B.__class__ is type(B)True&gt;&gt;&gt; b=B()&gt;&gt;&gt; b.__class__&lt;class &apos;__main__.B&apos;&gt;&gt;&gt;&gt; type(b)&lt;class &apos;__main__.B&apos;&gt;&gt;&gt;&gt; b.__class__ is type(b)True</code></pre><p>能看出，新式类及其实例均有__class__属性，并且通过内建函数type()获取到的值与__class__属性获取到的值一致；经典类没有__class__属性，但其实例有，但是通过内建函数type()获取到的值与__class__属性获取到的值不一致。</p><font size="4"><strong>多继承属性搜索顺序</strong></font><p>经典类多继承时属性搜索顺序: 先深入继承树左侧，再返回，开始找右侧（即深度优先搜索）;</p><p>新式类多继承属性搜索顺序: 先水平搜索，然后再向上移动（即宽度优先）。</p><p>这涉及到一个MRO(方法解释顺序)的 问题 ，经典类的MRO算法和新式类不同，不适用于新式类，经典类，使用深度优先算法，但因为新式类继承自 object，新的菱形类继承结构出现，问题也就接着而来了，所以必须新建一个 MRO算法，具体请参考：<a href="http://waisunny.com/2018/01/25/%E4%BD%A0%E7%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3python%E4%B8%AD%E7%9A%84MRO%E7%AE%97%E6%B3%95%E5%90%97%EF%BC%9F/">你真的理解python中的MRO吗？</a></p><p>例子：</p><p>经典类(深度优先) attr查找顺序：D、B、A、C</p><pre><code>class A:    attr=1class B(A):    passclass C(A):    attr = 2class D(B,C):    passd=D()print(d.attr)</code></pre><p>结果：</p><pre><code>1</code></pre><p>新式类(宽度优先) attr查找顺序：D、B、C、A</p><pre><code>class A(object):    attr=1class B(A):    passclass C(A):    attr = 2class D(B,C):    passd=D()print(d.attr)</code></pre><p>结果：</p><pre><code>2</code></pre><font size="4"><strong>__slots__属性</strong></font><p>新式类增加了__slots__属性，具体请参考：<a href="http://waisunny.com/2018/01/15/python%E4%B8%AD-slots-%E8%AF%A6%E8%A7%A3/" title="python中 __slots__属性详解">http://waisunny.com/2018/01/15/python%E4%B8%AD-slots-%E8%AF%A6%E8%A7%A3/</a></p><font size="4"><strong>__getattribute__方法</strong></font><p>新式类增加了__getattribute__方法，具体请参考：<a href="http://waisunny.com/2018/01/12/python%E4%B8%AD-get-getattr-getattribute-%E8%AF%A6%E8%A7%A3/" title="python中__get__、__getattr__、__getattribute__详解">http://waisunny.com/2018/01/12/python%E4%B8%AD-get-getattr-getattribute-%E8%AF%A6%E8%A7%A3/</a></p><font size="4"><strong>__new__方法</strong></font><p>新式类增加了__new__方法，具体请参考：<a href="http://waisunny.com/2018/01/18/python%E4%B8%AD-new-VS-init/" title="python中 __new__和__init__的区别">http://waisunny.com/2018/01/18/python%E4%B8%AD-new-VS-init/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在python2.x中，从object继承得来的类称为新式类（如class A(object)）不从object继承得来的类称为经典类（如class A()）；python3中所有的类都为新式类。&lt;/p&gt;
&lt;p&gt;那么新式类和经典类有啥区别呢？ 主要区别体现在五个方面，接下来我们详细介绍一下。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://waisunny.com/categories/Python/"/>
    
    
      <category term="python面向对象" scheme="http://waisunny.com/tags/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>python—包剖析</title>
    <link href="http://waisunny.com/2017/12/30/python%E2%80%94%E5%8C%85%E5%89%96%E6%9E%90/"/>
    <id>http://waisunny.com/2017/12/30/python—包剖析/</id>
    <published>2017-12-29T17:11:03.000Z</published>
    <updated>2018-01-28T06:06:32.264Z</updated>
    
    <content type="html"><![CDATA[<p>包是一个有层次的文件目录结构, 它定义了一个由模块和子包组成的 Python 应用程序执行<br>环境。Python 1.5 加入了包, 用来帮助解决如下问题:</p><ol><li>为平坦的名称空间加入有层次的组织结构</li><li>允许程序员把有联系的模块组合到一起</li><li>允许分发者使用目录结构而不是一大堆混乱的文件</li><li>帮助解决有冲突的模块名称</li></ol><p>与类和模块相同, 包也使用句点属性标识来访问他们的元素。 使用标准的 import 和<br>from-import 语句导入包中的模块。<br><a id="more"></a></p><h1 id="包的目录结构"><a href="#包的目录结构" class="headerlink" title="包的目录结构"></a>包的目录结构</h1><pre><code>Phone/    __init__.py    common_util.py    Voicedta/        __init__.py        Pots.py    Fax/        __init__.py        G3.py    Mobile/        __init__.py        Analog.py        Digital.py    Pager/        __init__.py        Numeric.py</code></pre><p>Phone 是最顶层的包, Voicedta 等是它的子包。 </p><p>从上面的目录结构我们发现每一个包中都包含一个__init__.py文件。</p><p>这个文件有什么作用呢？</p><ol><li>__init__.py的第一个作用就是包的标识，如果没有该文件，该目录就不会认为是包。</li><li>__init__.py的另外一个作用就是定义包中的__all__变量，该变量包含执行 from module import * 这样的语句时应该导入的模块的名字. 它由一个模块名字符串列表组成。</li></ol><h1 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h1><h2 id="import语句"><a href="#import语句" class="headerlink" title="import语句"></a>import语句</h2><pre><code>import Phone.Mobile.Analog #导入子包中的模块Phone.Mobile.Analog.dial() #调用子包模块中的函数dial()</code></pre><h2 id="from-import语句"><a href="#from-import语句" class="headerlink" title="from-import语句"></a>from-import语句</h2><pre><code>from Phone import MobileMobile.Analog.dial(&apos;555-1212&apos;)from Phone.Mobile import AnalogAnalog.dial(&apos;555-1212&apos;)from package.module import *</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;包是一个有层次的文件目录结构, 它定义了一个由模块和子包组成的 Python 应用程序执行&lt;br&gt;环境。Python 1.5 加入了包, 用来帮助解决如下问题:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为平坦的名称空间加入有层次的组织结构&lt;/li&gt;
&lt;li&gt;允许程序员把有联系的模块组合到一起&lt;/li&gt;
&lt;li&gt;允许分发者使用目录结构而不是一大堆混乱的文件&lt;/li&gt;
&lt;li&gt;帮助解决有冲突的模块名称&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;与类和模块相同, 包也使用句点属性标识来访问他们的元素。 使用标准的 import 和&lt;br&gt;from-import 语句导入包中的模块。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://waisunny.com/categories/Python/"/>
    
    
      <category term="python基础" scheme="http://waisunny.com/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>python—模块剖析</title>
    <link href="http://waisunny.com/2017/12/28/python%E2%80%94%E6%A8%A1%E5%9D%97%E5%89%96%E6%9E%90/"/>
    <id>http://waisunny.com/2017/12/28/python—模块剖析/</id>
    <published>2017-12-28T11:12:17.000Z</published>
    <updated>2018-01-28T06:06:39.334Z</updated>
    
    <content type="html"><![CDATA[<p>在计算机程序的开发过程中，随着程序代码越写越多，在一个文件里代码就会越来越长，越来越不容易维护。为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在Python中，一个.py文件就称之为一个模块（Module）。</p><p>使用模块有什么好处？</p><p>最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括Python内置的模块和来自第三方的模块。<br><a id="more"></a></p><h1 id="导入模块"><a href="#导入模块" class="headerlink" title="导入模块"></a>导入模块</h1><h2 id="模块导入原理"><a href="#模块导入原理" class="headerlink" title="模块导入原理"></a>模块导入原理</h2><p>模块的导入需要一个叫做”路径搜索”的过程。 即在文件系统”预定义区域”中查找 mymodule.py<br>文件(如果你导入 mymodule 的话)。 这些预定义区域只不过是你的 Python 搜索路径的集合。</p><p>路径搜索和搜索路径是两个不同的概念, 前者是指查找某个文件的操作, 后者是去查找一组目录。</p><p>解释器启动之后可以通过Python的sys.path属性获得当前搜索路径集合：</p><pre><code>&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.path[&apos;C:\\Python36\\DLLs&apos;, &apos;C:\\Python36\\lib&apos;, &apos;C:\\Python36&apos;, &apos;C:\\Python36\\lib\\site-packages&apos;, &apos;C:\\Python36\\lib\\site-packages\\pip-9.0.1-py3.6.egg&apos;, &apos;C:\\Python36\\lib\\site-packages\\pymysql-0.7.11-py3.6.egg&apos;, &apos;C:\\Python36\\lib\\site-packages\\requests-2.18.4-py3.6.egg&apos;, &apos;C:\\Python36\\lib\\site-packages\\certifi-2017.7.27.1-py3.6.egg&apos;]</code></pre><p>如果你知道你需要导入的模块是什么,而它的路径不在搜索路径里, 那么只需要向sys.path 添加即可：</p><pre><code>sys.path.append(&apos;/home/wesc/py/lib&apos;)</code></pre><p>由于append()方法是把元素放在集合尾部，<strong>解释器是按照搜索路径顺序查找匹配的第一个模块名称</strong>，如果你有特殊需要, 那么应该使用列表的 insert() 方法操作。</p><p>补充：sys.path集合中值得顺序是：当前目录—&gt;环境变量PYTHONPATH中配置的目录—&gt;python的安装设置相关的默认路径</p><h2 id="模块导入方式"><a href="#模块导入方式" class="headerlink" title="模块导入方式"></a>模块导入方式</h2><h3 id="import-语句"><a href="#import-语句" class="headerlink" title="import 语句"></a>import 语句</h3><pre><code>import mymodule</code></pre><p>这种方式导入模块，就在当前的名称空间(namespace)建立了一个到该模块的引用。这种引用必须使用全称，也就是说，当使用在被导入模块中定义的函数时，必须包含模块的名字。所以不能只使用funcname，而应该使用 mymodule.funcname</p><p>当前的名称空间(namespace)，意思就是说如果在一个模块的顶层导入, 那么它的作用域就是全局的; 如果在函数中导入, 那么它的作用域是局部的。</p><p>如果mymodule模块是被第一次导入, 它将被加载并执行。</p><h3 id="from-import语句"><a href="#from-import语句" class="headerlink" title="from-import语句"></a>from-import语句</h3><pre><code>from module import name1[ name2[,....nameN]</code></pre><p>from-import语句导入模块的指定属性。name1、name2… 直接被导入到当前名称空间里去，这意味着你不需要使用属性/句点属性标识来访问模块的标识符，可直接使用name1、name2。</p><p>值得提一下的是：</p><pre><code>from module import *</code></pre><p>上面这句话是把module模块中的’所有‘名称导入到当前名称空间中，但是：</p><ol><li><p>如果module中定义了__all__变量，那只能导入__all__中的名称。</p><pre><code># module.py__all__ = [&apos;a&apos;, &apos;b&apos;]a = 10b = 20c=50</code></pre><p> 只会导入 a、b两个名称。</p> <font color="red">__all__只针对 from module import * 语句起作用。</font></li><li><p>没有定义__all__变量时，会导入所有非’<em>‘开头的名称，在python中以’</em>‘开头认为是私有的。</p><pre><code># module.pya = 10_b = 20c=50</code></pre><p>只会导入 a、c两个名称。</p></li></ol><p>另外，我们认为 “from module import *” 不是良好的编程风格, 因为它”污染”当前名称<br>空间, 而且很可能覆盖当前名称空间中现有的名字。</p><p>我们只在两种场合下建议使用这样的方法, 一个场合是：目标模块中的属性非常多, 反复键入<br>模块名很不方便, 例如 Tkinter (Python/Tk) 和 NumPy (Numeric Python) 模块, 可能还有<br>socket 模块。另一个场合是在交互解释器下, 因为这样可以减少输入次数。</p><h2 id="扩展的import语句-as"><a href="#扩展的import语句-as" class="headerlink" title="扩展的import语句(as)"></a>扩展的import语句(as)</h2><p>意思是给自己导入的模块或模块中的名称起别名。</p><pre><code>import Tkinter as tkfrom cqi import FieldStorage as fiesto</code></pre><h2 id="导入模块执行机制"><a href="#导入模块执行机制" class="headerlink" title="导入模块执行机制"></a>导入模块执行机制</h2><p>第一次载入时执行模块(执行是指模块的顶层代码将被直接执行)，一个模块只被执行一次，无论被导入多少次，这样可以阻止多重导入时代码被多次执行。这个机制是通过sys.modules控制的。</p><p>导入模块时，是创建一个名为模块名称的对象，该对象引用模块的名字空间，这样就可以通过这个对象访问模块中的函数及变量。当多次导入同一个模块时，后面的import语句只是简单的创建一个到模块名字空间的引用而已。</p><p>sys.modules是一个字典，保存着所有被导入模块的模块名到模块对象的映射。这个字典用来决定是否需要使用import语句来导入一个模块的最新拷贝。</p><h2 id="模块导入规范"><a href="#模块导入规范" class="headerlink" title="模块导入规范"></a>模块导入规范</h2><p>我们推荐所有的模块在 Python 模块的开头部分导入。 而且最好按照这样的顺序:</p><ol><li>Python 标准库模块</li><li>Python 第三方模块</li><li>应用程序自定义模块</li></ol><p>然后使用一个空行分割这三类模块的导入语句。 这将确保模块使用固定的习惯导入, 有助于减<br>少每个模块需要的 import 语句数目。</p><h1 id="模块内建函数"><a href="#模块内建函数" class="headerlink" title="模块内建函数"></a>模块内建函数</h1><h2 id="import-函数"><a href="#import-函数" class="headerlink" title="__import__函数"></a>__import__函数</h2><pre><code>__import__(module_name[, globals[, locals[, fromlist]]])</code></pre><p><strong>import</strong>() 函数作为实际上导入模块的函数, 这意味着 import 语句调用 <strong>import</strong>() 函数完成它的工作。提供这个函数是为了让有特殊需要的用户覆盖它, 实现自定义的导入算法。</p><pre><code>#这两句话相等mymodule = __import__ (’module_name’)import module_name</code></pre><h2 id="global-和locals"><a href="#global-和locals" class="headerlink" title="global()和locals()"></a>global()和locals()</h2><p>globals() 和 locals() 内建函数分别返回调用者全局和局部名称空间的字典。 在一个函数内<br>部, 局部名称空间代表在函数执行时候定义的所有名字, locals() 函数返回的就是包含这些名字<br>的字典。 globals() 会返回函数可访问的全局名字。</p><p>在全局名称空间下, globals() 和 locals() 返回相同的字典, 因为这时的局部名称空间就是<br>全局空间。</p><pre><code>def foo():    print &apos;\ncalling foo()...&apos;    aString = &apos;bar&apos;    anInt = 42    print &quot;foo()&apos;s globals:&quot;, globals().keys()    print &quot;foo()&apos;s locals:&quot;, locals().keys()print &quot;__main__&apos;s globals:&quot;, globals().keys()print &quot;__main__&apos;s locals:&quot;, locals().keys() foo()</code></pre><p>执行这个脚本, 我们得到如下的输出:</p><pre><code>&gt;&gt;&gt; $ namespaces.py__main__&apos;s globals: [&apos;__doc__&apos;, &apos;foo&apos;, &apos;__name__&apos;, &apos;__builtins__&apos;]__main__&apos;s locals: [&apos;__doc__&apos;, &apos;foo&apos;, &apos;__name__&apos;, &apos;__builtins__&apos;]</code></pre><h2 id="reload"><a href="#reload" class="headerlink" title="reload()"></a>reload()</h2><p>reload() 内建函数可以重新导入一个已经导入的模块。 它的语法如下:</p><pre><code>reload(module)</code></pre><p>上述是python2中的写法，在python3中写法如下：</p><pre><code>import importlibimportlib.reload(module)</code></pre><p>使用 reload() 的时候有一些标准。 首先模块必须是全部<br>导入(不是使用 from-import), 而且它必须被成功导入。另外 reload() 函数的参数必须是模块自<br>身而不是包含模块名的字符串。 也就是说必须类似 reload(sys) 而不是 reload(‘sys’)。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>说了那么多，主要记住,模块导入原理，根据sys.path搜索的；模块执行机制，根据sys.modules控制的；以及模块的导入方式就可以了，接下来会有博文介绍python中包的概念。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在计算机程序的开发过程中，随着程序代码越写越多，在一个文件里代码就会越来越长，越来越不容易维护。为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在Python中，一个.py文件就称之为一个模块（Module）。&lt;/p&gt;
&lt;p&gt;使用模块有什么好处？&lt;/p&gt;
&lt;p&gt;最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括Python内置的模块和来自第三方的模块。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://waisunny.com/categories/Python/"/>
    
    
      <category term="python基础" scheme="http://waisunny.com/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>python黑魔法—装饰器</title>
    <link href="http://waisunny.com/2017/12/26/python%E9%BB%91%E9%AD%94%E6%B3%95%E2%80%94%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <id>http://waisunny.com/2017/12/26/python黑魔法—装饰器/</id>
    <published>2017-12-26T09:37:26.000Z</published>
    <updated>2018-01-21T23:58:10.027Z</updated>
    
    <content type="html"><![CDATA[<p>先来一个形象的比喻：</p><p>内裤可以用来遮羞，但是到了冬天它没法为我们防风御寒，聪明的人们发明了长裤，有了长裤后宝宝再也不冷了，装饰器就像我们这里说的长裤，在不影响内裤作用的前提下，给我们的身子提供了保暖的功效。</p><p>再回到我们的主题</p><a id="more"></a><p><strong>什么是装饰器？</strong></p><p>装饰器本质上是一个Python函数，它可以让其它函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值是一个函数对象。</p><p><strong>装饰器有哪些使用场景？</strong></p><p>它经常用于有切面(AOP)需求的场景，比如：<strong>插入日志、性能测试、事务处理、缓存、权限校验</strong>等场景。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码并继续重用。概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。</p><h1 id="函数装饰器"><a href="#函数装饰器" class="headerlink" title="函数装饰器"></a>函数装饰器</h1><p>我们用一个小例子一步步引出装饰器：</p><pre><code>def fun():    print(&apos;my name is fun&apos;)</code></pre><p>上面我们定义了一个fun函数，函数运行时告诉用户一些信息。</p><p>现在我们有一个新的需求，需要给增加日志记录的功能，怎么办？</p><pre><code>import logginglogging.basicConfig(filename=&apos;log1.log&apos;,level=logging.DEBUG)def fun():    print(&apos;my name is fun&apos;)    logging.debug(&apos;fun is running&apos;)fun()</code></pre><p>我们借助了python内置的logging模块实现了日志记录的功能，运行上述代码能成功记录日志，新增的需求开发完了，真的开发完了吗？如果我们有fun1(),fun2()…等其它函数也需要记录日志呢，难道每一个函数都要加上一句logging.debug()语句吗？这样的话会有很多重复代码；我们可以定义一个专门记录日志的函数：</p><pre><code>import logginglogging.basicConfig(filename=&apos;log1.log&apos;,level=logging.DEBUG)def use_log(fun):    logging.debug(&apos;%s is running&apos;%fun.__name__)    fun()def fun():    print(&apos;my name is fun&apos;)use_log(fun)</code></pre><p>逻辑上不难理解，而且解决了重复代码的问题 ，但是它有一个极大的弊端；它改变了 用户的请求方式，以前我们只需要调用fun()函数即可，现在我们必须调用    use_log(fun)才行，这是 一个很糟糕的设计，想一想，我们的程序可能已经发布到了生产环境，也许正在有很多用户在使用，这么一改，用户按照以前的方式调用，全挂掉了，这种设计还不如第一种呢….,那没有什么好办法了吗？在不改变原有调用方式的前提下，增加日志记录功能。当然有,就是我们的装饰器：</p><p>简单的装饰器：</p><pre><code>import logginglogging.basicConfig(filename=&apos;log1.log&apos;,level=logging.DEBUG)def use_log(fun):    def wrapper():        logging.debug(&apos;%s is running&apos;%fun.__name__)        fun()    return wrapperdef fun():    print(&apos;my name is fun&apos;)fun=use_log(fun)fun()</code></pre><p>上述调用方式看起来有点麻烦，幸运的是python中给我们提供了语法糖，上述代码直接修改成：</p><pre><code>@use_log  等价于 fun=use_log(fun)def fun():    print(&apos;my name is fun&apos;)fun()</code></pre><p>use_log函数就是一个装饰器函数，内部函数 wrapper 是用来执行具体操作逻辑的函数。</p><p>不难看出usel_log其实也是一个闭包函数，没错，装饰器就是基于（闭包，高阶函数）实现的。</p><p>这样我们在不改变原有函数调用方式的前提下，增加了日志功能，并提高了代码的复用性。</p><p>上面的装饰器过于简单，如果我们要执行的函数带有参数怎么办？</p><h2 id="给功能函数加参数"><a href="#给功能函数加参数" class="headerlink" title="给功能函数加参数"></a><strong>给功能函数加参数</strong></h2><pre><code>import logginglogging.basicConfig(filename=&apos;log1.log&apos;,level=logging.DEBUG)def use_log(fun):    def wrapper(*args,**kwargs):        logging.debug(&apos;%s is running&apos;%fun.__name__)        fun(*args,**kwargs)    return wrapper@use_logdef fun(name):    print(&apos;my name is fun,params is %s&apos;%name)fun(&apos;_learner&apos;)</code></pre><p>我们将装饰器的内部函数定义成了 def wrapper(<em>args,*</em>kwargs): 的形式，这样就可以接受任何参数了。</p><p>现在我们又有了一个新的需求，函数可以自己控制是否记录日志；这时就需要用到装饰器参数了</p><h2 id="给装饰器函数加参数"><a href="#给装饰器函数加参数" class="headerlink" title="给装饰器函数加参数"></a><strong>给装饰器函数加参数</strong></h2><pre><code>import logginglogging.basicConfig(filename=&apos;log1.log&apos;,level=logging.DEBUG)def use_Log(is_log=1):    def decorator(fun):        def wrapper(*args,**kwargs):            if is_log:                logging.debug(&apos;%s is running&apos;%fun.__name__)            fun(*args,**kwargs)        return wrapper    return decorator@use_Log(0) 等价于 @decorator 等价于 fun=decorator(fun)def fun(name):    print(&apos;my name is fun,params is %s&apos;%name)fun(&apos;_learner&apos;)</code></pre><p>给装饰器函数加参数的方式：多定义一层外部函数，用于接受参数，该外部函数的返回值就是装饰器函数。</p><h1 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a><strong>类装饰器</strong></h1><p>再来看看类装饰器，相比函数装饰器，类装饰器具有灵活度大、高内聚、封装性等优点。使用类装饰器还可以依靠类内部的__call__方法，当使用 @ 形式将装饰器附加到函数上时，就会调用此方法。</p><h2 id="装饰器无参数，被装饰对象有参数"><a href="#装饰器无参数，被装饰对象有参数" class="headerlink" title="装饰器无参数，被装饰对象有参数"></a>装饰器无参数，被装饰对象有参数</h2><pre><code>class Decorator:    def __init__(self,func):# func是被装饰的对象        self.func=func    def __call__(self,*args, **kwargs):#*args, **kwargs用于承载被装饰对象的参数        print(&apos;class decoratoe is running&apos;)        self.func(*args,**kwargs)        print(&apos;class decorator is runned&apos;)@Decoratordef fun(name):    print(&apos;my name is %s&apos;%name)fun(&apos;_learner&apos;)</code></pre><p>运行结果：</p><pre><code>class decoratoe is runningmy name is _learnerclass decorator is runned</code></pre><h2 id="装饰器有参数，被装饰对象也有参数"><a href="#装饰器有参数，被装饰对象也有参数" class="headerlink" title="装饰器有参数，被装饰对象也有参数"></a>装饰器有参数，被装饰对象也有参数</h2><pre><code>class Decorator:    def __init__(self,is_print): # is_print 装饰器参数        self.is_print=is_print    def __call__(self,func): # func是被装饰的对象        def _cal(*args, **kwargs):# *args, **kwargs用于承载被装饰对象的参数            if self.is_print:                print(&apos;class decoratoe is running&apos;)                func(*args,**kwargs)                print(&apos;class decorator is runned&apos;)            else:                func(*args, **kwargs)        return _cal@Decorator(0)def fun(name):    print(&apos;my name is %s&apos;%name)fun(&apos;_learner&apos;)</code></pre><p>运行结果：</p><pre><code>my name is _learner</code></pre><h1 id="functools-wraps"><a href="#functools-wraps" class="headerlink" title="functools.wraps"></a><strong>functools.wraps</strong></h1><p>使用装饰器极大地复用了代码，但是他有一个缺点就是原函数的元信息不见了，比如函数的__doc__、__name__、参数列表，先看例子：</p><pre><code>def logged(fun):    def with_logging(*args,**kwargs):        &apos;&apos;&apos;with_logging&apos;&apos;&apos;        print(&apos;was called: %s&apos;%fun.__name__)        return fun(*args,**kwargs)    return with_logging@loggeddef f(x):    &apos;&apos;&apos; does some math&apos;&apos;&apos;    return x*xf(5)print(f.__name__)print(f.__doc__)</code></pre><p>运行结果：</p><pre><code>was called: fwith_loggingwith_logging</code></pre><p>能看出函数f的__doc__、__name__属性值全部变成了内部函数with_logging的了；这个问题是比较严重的，好在我们有functools.wraps，wraps本身也是一个装饰器，它能把原函数的元信息拷贝到装饰器函数中，这使得装饰器函数也有和原函数一样的元信息了。</p><pre><code>from  functools import wrapsdef logged(fun):    @wraps(fun)    def with_logging(*args,**kwargs):        &apos;&apos;&apos;with_logging&apos;&apos;&apos;        print(with_logging.__doc__)        print(with_logging.__name__)        return fun(*args,**kwargs)    return with_logging@loggeddef f(x):    &apos;&apos;&apos;does some math&apos;&apos;&apos;    return x*xf(5)print(f.__name__)print(f.__doc__)</code></pre><p>运行结果：</p><pre><code>does some mathffdoes some math</code></pre><h1 id="装饰器执行顺序"><a href="#装饰器执行顺序" class="headerlink" title="装饰器执行顺序"></a><strong>装饰器执行顺序</strong></h1><pre><code>@a@b@cdef fun():    pass</code></pre><p>等价于</p><pre><code>fun=a(b(c(fun)))</code></pre><h1 id="内置装饰器"><a href="#内置装饰器" class="headerlink" title="内置装饰器"></a><strong>内置装饰器</strong></h1><p>@staticmathod、@classmethod、@property</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>装饰器是python中一个相当重要的内容，它是在闭包合高阶函数的基础上实现的；可以定义函数装饰器、类装饰器等；它们分别都可以装饰函数、类等。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先来一个形象的比喻：&lt;/p&gt;
&lt;p&gt;内裤可以用来遮羞，但是到了冬天它没法为我们防风御寒，聪明的人们发明了长裤，有了长裤后宝宝再也不冷了，装饰器就像我们这里说的长裤，在不影响内裤作用的前提下，给我们的身子提供了保暖的功效。&lt;/p&gt;
&lt;p&gt;再回到我们的主题&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://waisunny.com/categories/Python/"/>
    
    
      <category term="python基础" scheme="http://waisunny.com/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>python中的下划线</title>
    <link href="http://waisunny.com/2017/12/24/python%E4%B8%AD%E7%9A%84%E4%B8%8B%E5%88%92%E7%BA%BF/"/>
    <id>http://waisunny.com/2017/12/24/python中的下划线/</id>
    <published>2017-12-24T15:56:58.000Z</published>
    <updated>2017-12-24T08:24:47.582Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章讨论Python中下划线<em>的使用。跟Python中很多用法类似，下划线</em>的不同用法绝大部分（不全是）都是一种惯例约定。<br><a id="more"></a></p><h1 id="单个下划线（-）"><a href="#单个下划线（-）" class="headerlink" title="单个下划线（_）"></a>单个下划线（_）</h1><p>主要有三种情况：</p><ol><li><p>解释器中<br>_符号是指交互解释器中最后一次执行语句的返回结果。这种用法最初出现在CPython解释器中，其他解释器后来也都跟进了。</p><pre><code>&gt;&gt;&gt; _Traceback (most recent call last):File &quot;&quot;, line 1, in NameError: name &apos;_&apos; is not defined&gt;&gt;&gt; 42&gt;&gt;&gt; _42&gt;&gt;&gt; &apos;alright!&apos; if _ else &apos;:(&apos;&apos;alright!&apos;&gt;&gt;&gt; _&apos;alright!&apos;</code></pre></li><li><p>作为名称使用<br>这个跟上面有点类似。_用作被丢弃的名称。按照惯例，这样做可以让阅读你代码的人知道，这是个不会被使用的特定名称。举个例子，你可能无所谓一个循环计数的值：</p><pre><code>n = 42for _ in range(n):    do_something()</code></pre></li><li><p>i18n<br>_还可以被用作函数名。这种情况，单下划线经常被用作国际化和本地化字符串翻译查询的函数名。这种惯例好像起源于C语言。举个例子，在 <a href="https://docs.djangoproject.com/en/dev/topics/i18n/translation/" target="_blank" rel="external">Django documentation for translation</a> 中你可能会看到：</p><pre><code>from django.utils.translation import ugettext as _from django.http import HttpResponsedef my_view(request):    output = _(&quot;Welcome to my site.&quot;)    return HttpResponse(output)</code></pre></li></ol><p>第二种和第三种用法会引起冲突，所以在任意代码块中，如果使用了_作i18n翻译查询函数，就应该避免再用作被丢弃的变量名。</p><h1 id="单下划线前缀的名称（例如-shahriar）"><a href="#单下划线前缀的名称（例如-shahriar）" class="headerlink" title="单下划线前缀的名称（例如_shahriar）"></a>单下划线前缀的名称（例如_shahriar）</h1><p>单下划线开头被常用于模块中，在一个模块中以单下划线开头的变量和函数被默认当作内部函数,“私有成员”，如果使用 from a<em>module import * 导入时，这部分变量和函数不会被导入,除非模块/包的\</em>_all__列表明确包含了这些名称。不过值得注意的是，如果使用 import a_module 这样导入模块，仍然可以用 a_module._some_var 这样的形式访问到这样的对象。</p><h1 id="双下划线前缀的名称（例如-shahriar）"><a href="#双下划线前缀的名称（例如-shahriar）" class="headerlink" title="双下划线前缀的名称（例如__shahriar）"></a>双下划线前缀的名称（例如__shahriar）</h1><p>以双下划线做前缀的名称（特别是方法名）并不是一种惯例；它对解释器有特定含义。Python会改写这些名称，以免与子类中定义的名称产生冲突。Python documentation中提到，任何__spam这种形式（至少以两个下划线做开头，绝大部分都还有一个下划线做结尾）的标识符，都会文本上被替换为_classname__spam，其中classname是当前类名，并带上一个下划线做前缀。</p><p>看下面这个例子：</p><pre><code>&gt;&gt;&gt; class A(object):...     def _internal_use(self):...         pass...     def __method_name(self):...         pass... &gt;&gt;&gt; dir(A())[&apos;_A__method_name&apos;, ..., &apos;_internal_use&apos;]</code></pre><p>正如所料，_internal<em>use没有变化，但\</em>_method_name被改写成了_ClassName__method_name。现在创建一个A的子类B（这可不是个好名字），就不会轻易的覆盖掉A中的__method_name了：</p><pre><code>&gt;&gt;&gt; class B(A):...     def __method_name(self):...         pass... &gt;&gt;&gt; dir(B())[&apos;_A__method_name&apos;, &apos;_B__method_name&apos;, ..., &apos;_internal_use&apos;]</code></pre><p>这种特定的行为差不多等价于Java中的final方法和C++中的正常方法（非虚方法）。</p><h1 id="前后都带有双下划线的名称（例如-init-）"><a href="#前后都带有双下划线的名称（例如-init-）" class="headerlink" title="前后都带有双下划线的名称（例如 __init__）"></a>前后都带有双下划线的名称（例如 __init__）</h1><p>这些是Python的特殊方法名，这仅仅是一种惯例，一种确保Python系统中的名称不会跟用户自定义的名称发生冲突的方式。通常你可以覆写这些方法，在Python调用它们时，产生你想得到的行为。例如，当写一个类的时候经常会覆写__init__方法。Python 官方推荐永远不要将这样的命名方式应用于自己的变量或函数，而是按照文档说明来使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章讨论Python中下划线&lt;em&gt;的使用。跟Python中很多用法类似，下划线&lt;/em&gt;的不同用法绝大部分（不全是）都是一种惯例约定。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://waisunny.com/categories/Python/"/>
    
    
      <category term="python基础" scheme="http://waisunny.com/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Python黑魔法—上下文管理器</title>
    <link href="http://waisunny.com/2017/12/21/Python%E9%BB%91%E9%AD%94%E6%B3%95%E2%80%94%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8/"/>
    <id>http://waisunny.com/2017/12/21/Python黑魔法—上下文管理器/</id>
    <published>2017-12-20T16:51:59.000Z</published>
    <updated>2017-12-24T09:46:16.171Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是上下文管理器"><a href="#什么是上下文管理器" class="headerlink" title="什么是上下文管理器"></a>什么是上下文管理器</h1><p>上下文管理器顾名思义是管理上下文的,也就是负责冲锋和垫后,而让主人专心完成自己的事情。我们在编写程序的时候，通常会将一系列操作放到一个语句块中，当某一条件为真时执行该语句快。有时候，我们需要再执行一个语句块时保持某种状态，并且在离开语句块后结束这种状态。例如对文件的操作，我们在打开一个文件进行读写操作时需要保持文件处于打开状态，而等操作完成之后要将文件关闭。所以，上下文管理器的任务是：代码块执行前准备，代码块执行后收拾。上下文管理器是在Python2.5加入的功能，它能够让你的代码可读性更强并且错误更少。</p><p>需求的产生<br>在正常的管理各种系统资源(文件、锁定和连接)，在涉及到异常时通常是个棘手的问题。异常很可能导致控制流跳过负责释放关键资源的语句。例如打开一个文件进行操作时，如果意外情况发生（磁盘已满、特殊的终端信号让其终止等），就会抛出异常，这样可能最后的文件关闭操作就不会执行。如果这样的问题频繁出现，则可能耗尽系统资源。</p><p>是的，这样的问题并不是不可避免。在没有接触到上下文管理器之前，我们可以用“try/finally”语句来解决这样的问题。或许在有些人看来，“try/finally”语句显得有些繁琐。上下文管理器就是被设计用来简化“try/finally”语句的，这样可以让程序更加简洁。<br><a id="more"></a></p><h1 id="With语句"><a href="#With语句" class="headerlink" title="With语句"></a>With语句</h1><p>With语句用于执行上下文操作，它也是复合语句的一种，其基本语法如下所示：</p><pre><code>with context_expr [as var]:    with_suite</code></pre><p>With 语句仅能工作于支持上下文管理协议(context management protocol)的对象。也就是说只有内建了”上下文管理”的对象才能和 with 一起工作。Python内置了一些支持该协议的对象，如下所列是一个简短列表：</p><ol><li>file</li><li>decimal.Context</li><li>thread.LockType</li><li>threading.Lock</li><li>threading.RLock</li><li>threading.Condition</li><li>threading.Semaphore</li><li>threading.BoundedSemaphore</li></ol><p>由以上列表可以看出，file 是已经内置了对上下文管理协议的支持。所以我们可以用下边的方法来操作文件：</p><pre><code>with open(&apos;/etc/passwd&apos;, &apos;r&apos;) as f:    for eachLine in f:        # ...do stuff with eachLine or f...</code></pre><p>上边的代码试图打开一个文件,如果一切正常,把文件对象赋值给 f。然后用迭代器遍历文件中的每一行,当完成时,关闭文件。无论是在这一段代码的开始,中间,还是结束时发生异常,会执行清理的代码,此外文件仍会被自动的关闭。</p><h1 id="自定义上下文管理器"><a href="#自定义上下文管理器" class="headerlink" title="自定义上下文管理器"></a>自定义上下文管理器</h1><p>要实现上下文管理器，必须实现两个方法：一个负责进入语句块的准备操作，另一个负责离开语句块的善后操作。Python类包含两个特殊的方法，分别名为：<strong>__enter__ 和 __exit__</strong>。</p><p>__enter__: 该方法进入运行时上下文环境，并返回自身或另一个与运行时上下文相关的对象。返回值会赋给 as 从句后面的变量，as 从句是可选的。</p><p>__exit__: 该方法退出当前运行时上下文并返回一个布尔值，该布尔值标明了“如果 with<em>suit 的退出是由异常引发的，该异常是否须要被忽略”。如果 \</em>_exit__() 的返回值等于 False，那么这个异常将被重新引发一次；如果 __exit__() 的返回值等于 True，那么这个异常就被无视掉，继续执行后面的代码。</p><p>With 语句的实际执行流程是这样的：</p><ol><li>执行 context_exp 以获取上下文管理器</li><li>加载上下文管理器的 __exit__() 方法以备稍后调用</li><li>调用上下文管理器的 __enter__() 方法</li><li>如果有 as var 从句，则将 __enter__() 方法的返回值赋给 var</li><li>执行子代码块 with_suit</li><li>调用上下文管理器的 __exit__() 方法，如果 with<em>suit 的退出是由异常引发的，那么该异常的 type、value 和 traceback 会作为参数传给 \</em>_exit__()，否则传三个 None。</li><li>如果 with<em>suit 的退出由异常引发，并且 \</em>_exit__() 的返回值等于 False，那么这个异常将被重新引发一次；如果 __exit__() 的返回值等于 True，那么这个异常就被无视掉，继续执行后面的代码</li></ol><p>下面我们自己来实现一个支持上下文管理协议的类：</p><pre><code>class Query(object):    def __init__(self, name):        self.name = name    def __enter__(self):        print(&apos;Begin&apos;)        return self    def __exit__(self, exc_type, exc_value, traceback):        if exc_type:            print(&apos;Error&apos;)        else:            print(&apos;End&apos;)    def query(self):        print(&apos;Query info about %s...&apos; % self.name)</code></pre><p>这样我们就可以把自己写的资源对象用于with语句：</p><pre><code>with Query(&apos;_learner&apos;) as q:    q.query()</code></pre><p>执行结果：</p><pre><code>BeginQuery info about _learner...End</code></pre><h1 id="上下文管理工具（contextlib模块）"><a href="#上下文管理工具（contextlib模块）" class="headerlink" title="上下文管理工具（contextlib模块）"></a>上下文管理工具（contextlib模块）</h1><p><strong>contextlib</strong>模块提供更易用的上下文管理器。</p><h2 id="contextmanager"><a href="#contextmanager" class="headerlink" title="@contextmanager"></a>@contextmanager</h2><p>编写<strong>enter</strong>和<strong>exit</strong>仍然很繁琐，因此Python的标准库contextlib提供了更简单的写法，上面的代码可以改写如下：</p><pre><code>from contextlib import contextmanagerclass Query(object):    def __init__(self, name):        self.name = name    def query(self):        print(&apos;Query info about %s...&apos; % self.name)@contextmanagerdef create_query(name):    print(&apos;Begin&apos;)    q = Query(name)    yield q    print(&apos;End&apos;)</code></pre><p><strong>@contextmanager</strong>这个decorator接受一个generator，用yield语句把with … as var把变量输出出去，然后，with语句就可以正常地工作了：</p><pre><code>with create_query(&apos;_learner&apos;) as q:    q.query()</code></pre><p>执行结果：</p><pre><code>BeginQuery info about _learner...End</code></pre><p>很多时候，我们希望在某段代码执行前后自动执行特定代码，也可以用@contextmanager实现。例如：</p><pre><code>@contextmanagerdef tag(name):    print(&quot;&lt;%s&gt;&quot; % name)    yield    print(&quot;&lt;/%s&gt;&quot; % name)with tag(&quot;h1&quot;):    print(&quot;hello&quot;)    print(&quot;world&quot;)</code></pre><p>上述代码执行结果为：</p><pre><code>&lt;h1&gt;helloworld&lt;/h1&gt;</code></pre><p>代码的执行顺序是：</p><ol><li>with语句首先执行yield之前的语句，因此打印出<h1\>；</h1\></li><li>yield调用会执行with语句内部的所有语句，因此打印出hello和world；</li><li>最后执行yield之后的语句，打印出。</li></ol><p>因此，@contextmanager让我们通过编写generator来简化上下文管理。</p><h2 id="closing"><a href="#closing" class="headerlink" title="@closing"></a>@closing</h2><p>如果一个对象没有实现上下文，我们就不能把它用于with语句。这个时候，可以用closing()来把该对象变为上下文对象。例如，用with语句使用urlopen()：</p><pre><code>from contextlib import closingfrom urllib.request import urlopenwith closing(urlopen(&apos;https://www.python.org&apos;)) as page:    for line in page:        print(line)</code></pre><p><strong>closing</strong>也是一个经过<strong>@contextmanager</strong>装饰的generator，这个generator编写起来其实非常简单：</p><pre><code>@contextmanagerdef closing(thing):    try:        yield thing    finally:        thing.close()</code></pre><p>重写上面的例子：</p><pre><code>from contextlib import  contextmanagerfrom urllib.request import urlopen@contextmanagerdef closing(thing):    try:        yield thing    finally:        thing.close()with closing(urlopen(&apos;https://www.python.org&apos;)) as page:    for line in page:        print(line)</code></pre><p>它的作用就是把任意对象变为上下文对象，并支持with语句。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是上下文管理器&quot;&gt;&lt;a href=&quot;#什么是上下文管理器&quot; class=&quot;headerlink&quot; title=&quot;什么是上下文管理器&quot;&gt;&lt;/a&gt;什么是上下文管理器&lt;/h1&gt;&lt;p&gt;上下文管理器顾名思义是管理上下文的,也就是负责冲锋和垫后,而让主人专心完成自己的事情。我们在编写程序的时候，通常会将一系列操作放到一个语句块中，当某一条件为真时执行该语句快。有时候，我们需要再执行一个语句块时保持某种状态，并且在离开语句块后结束这种状态。例如对文件的操作，我们在打开一个文件进行读写操作时需要保持文件处于打开状态，而等操作完成之后要将文件关闭。所以，上下文管理器的任务是：代码块执行前准备，代码块执行后收拾。上下文管理器是在Python2.5加入的功能，它能够让你的代码可读性更强并且错误更少。&lt;/p&gt;
&lt;p&gt;需求的产生&lt;br&gt;在正常的管理各种系统资源(文件、锁定和连接)，在涉及到异常时通常是个棘手的问题。异常很可能导致控制流跳过负责释放关键资源的语句。例如打开一个文件进行操作时，如果意外情况发生（磁盘已满、特殊的终端信号让其终止等），就会抛出异常，这样可能最后的文件关闭操作就不会执行。如果这样的问题频繁出现，则可能耗尽系统资源。&lt;/p&gt;
&lt;p&gt;是的，这样的问题并不是不可避免。在没有接触到上下文管理器之前，我们可以用“try/finally”语句来解决这样的问题。或许在有些人看来，“try/finally”语句显得有些繁琐。上下文管理器就是被设计用来简化“try/finally”语句的，这样可以让程序更加简洁。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://waisunny.com/categories/Python/"/>
    
    
      <category term="python基础" scheme="http://waisunny.com/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
