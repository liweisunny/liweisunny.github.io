---
title: 图文详解各排序算法(三 )
date: 2018-01-31 14:33:35
tags: 算法
toc: true
categories: 数据结构与算法
---

前面的文章依次介绍了选择排序、堆排序、冒泡排序、快速排序。

本篇博文将会介绍两个插入排序序算法：直接插入排序和希尔排序。

<!--more-->

# 直接插入排序
![](https://i.imgur.com/VQ9ocFa.gif)

## 简介

直接插入排序是一种最简单的插入排序。

插入排序：每一趟将一个待排序的记录，按照其大小插入到有序队列的合适位置里，直到全部插入完成。 

假设有一组无序序列 N0, N1, ... , N(n-1)。

(1) 我们先将这个序列中下标为 0 的元素视为元素个数为 1 的有序序列。

(2) 然后，我们要依次把 N1, N2, ... , N(n-1) 插入到这个有序序列中。所以，我们需要一个外部循环，从下标 1 扫描到 n-1 。

(3) 接下来描述插入过程。假设要将 Ni 插入到前面有序的序列中。由前面所述，我们可知，插入Ni时，前 i-1 个数肯定已经是有序了。

所以我们需要将Ni 和N0 ~ N(i-1) 进行比较，确定要插入的合适位置。我们可以定义一个待插变量来存放Ni,同时需要一个内部循环，一般是从后往前和待插元素比较，即从下标 i-1 开始向 0 进行扫描,如果集合里的元素大于待插元素，就将集合的当前元素它向后移动一个单元，当遇到小于等于待插元素的元素时终止内部循环并将待插元素插入到该位置。 
## 算法实现
	
	def insert_sort(lst):
	    
	    i = 1
	    while i < len(lst):
	        
	        j = i-1
	        insert_item = lst[i]
	        
	        while j >= 0 and lst[j] > insert_item:
	            lst[j+1] = lst[j]
	            j -= 1
	            
	        lst[j+1] = insert_item  # j+1 为当前带插入的位置，因为在找到带插入位置后会经过 j-=1。
	        
	        i += 1

	lst = [3, 2, 4, 5, 1, 4, 7]
	heap_sort(lst)
	print(lst)  # [1, 2, 3, 4, 4, 5, 7]

## 复杂度分析

### 时间复杂度

当数据正序时，执行效率最好，每次插入都不用移动前面的元素，时间复杂度为O(N)。 

当数据反序时，执行效率最差，每次插入都要前面的元素后移，时间复杂度为O(N2)。

所以，数据越接近正序，直接插入排序的算法性能越好。 

### 空间复杂度
由直接插入排序算法可知，我们在排序过程中，需要一个临时变量存储要插入的值，所以空间复杂度为 O(1) 。

## 稳定性
由直接插入排序算法可知，我们在排序过程中，需要一个临时变量存储要插入的值，所以空间复杂度为 1 。


# 希尔排序
![](https://i.imgur.com/yzdSLjL.gif)
## 简介

希尔(Shell)排序又称为**缩小增量排序**，它是一种插入排序。它是直接插入排序算法的一种威力加强版。

它的基本思想是：把列表按步长 gap 分组，对每组记录采用直接插入排序方法进行排序。

随着步长逐渐减小，所分成的组包含的记录越来越多，当步长的值减小到 1 时，整个数据合成为一组，并对其进行插入排序，构成一组有序记录，则完成排序。

我们来通过演示图，更深入的理解一下这个过程。

**第一步：**把较大的数据集合分割成若干个小组（**逻辑上分组**）。

![](https://i.imgur.com/p6gvj4l.png)

说明：上面有颜色的是逻辑上的分组，并没有实际地进行分组操作，在数组中的位置还是原来的样子，只是将他们看成这么几个分组（逻辑上分组）

可以看出，它是按下标相隔距离为 gap = n//2 =4 分的组，也就是说把下标相差4的分到一组，比如这个例子中a[0]与a[4]是一组、a[1]与a[5]是一组...，这里的差值（距离）被称为**增量**。

![](https://i.imgur.com/8qYSmb2.png)

**第二步：**对每个分组进行插入排序后，此时，插入排序所作用的数据量比较小（每一个小组），插入的效率比较高；这样各个分组就变成了有序的了（整体不一定有序）。
![](https://i.imgur.com/B3be7o4.png)

此时，整个数组变的部分有序了（有序程度可能不是很高）

![](https://i.imgur.com/s3ztTnF.png)

**第三步：**缩小增量gap为上个增量的一半:gap = 4//2 = 2，继续划分分组，此时，每个分组元素个数多了，但是，数组变的部分有序了，插入排序效率同样比较高。

![](https://i.imgur.com/tcPZGvQ.png)

**第四步：**同理对每个分组进行排序（插入排序），使其每个分组各自有序。

![](https://i.imgur.com/eMyO47C.png)

最后设置增量 gap 为上一个增量的一半：gap = 2//2 = 1，则整个数组被分为一组，此时，整个数组已经接近有序了，插入排序效率高。

![](https://i.imgur.com/95y135M.png)

同理，对这仅有的一组数据进行插入排序，排序完成。

## 算法实现

	def shell_sort(lst):
	    n = len(lst)
	    gap = n//2  # 初始步长
	    while gap > 0:
	
	        # 开始插入排序
	        i = gap  # 直接插入排序的起始元素是第二个元素，希尔排序的起始元素是索引为当前步长的那个元素
	        while i <= n-gap:
	            
	            j = i - gap
	            insert_item = lst[i]
	
	            while j >= 0 and lst[j] > insert_item:
	                lst[j+gap] = lst[j]
	                j -= gap
	
	            lst[j+gap] = insert_item
	            i += 1
	
	        gap //= 2

	lst = [3, 2, 4, 5, 1, 4, 7]
	heap_sort(lst)
	print(lst)  # [1, 2, 3, 4, 4, 5, 7]


## 复杂度分析

希尔排序的复杂度和增量序列是相关的

{1,2,4,8,...}这种序列并不是很好的增量序列，使用这个增量序列的时间复杂度（最坏情形）是O(n^2)

Hibbard提出了另一个增量序列{1,3,7，...,2^k-1}，这种序列的时间复杂度(最坏情形)为O(n^1.5)

Sedgewick提出了几种增量序列，其最坏情形运行时间为O（n^1.3）,其中最好的一个序列是{1,5,19,41,109,...}。

## 空间复杂度

希尔排序没有使用额外的辅助空间，空间复杂度O(1)。

## 稳定性
希尔排序不是稳定的，虽然插入排序是稳定的，但是希尔排序在插入的时候是跳跃性插入的，相同的数据有可能会交换位置。

# 二者比较

直接插入排序是**稳定**的；而希尔排序是**不稳定**的。

直接插入排序更适合于原始记录**基本有序**的集合。

希尔排序的比较次数和移动次数都要比直接插入排序少，当**N越大**时，效果越明显。   

在希尔排序中，增量序列gap的取法必须满足：**最后一个步长必须是 1 **。 

直接插入排序也适用于链式存储结构；希尔排序不适用于**链式结构**。

关于链式存储结构，请参见：