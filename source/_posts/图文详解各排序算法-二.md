---
title: 图文详解各排序算法(二)
date: 2018-01-30 14:33:35
tags: 算法
toc: true
categories: 数据结构与算法
---
上一篇博文介绍了两个选择排序算法，选择排序和堆排序，参见：。

本篇博文将会介绍两个交换排序序算法：冒泡排序和快速排序。

<!--more-->

# 冒泡排序

## 简介
![](https://i.imgur.com/Dxv6UuB.gif)

冒泡排序是一种交换排序。

什么是交换排序呢？

交换排序：两两比较待排序的关键字，并交换不满足次序要求的那对数，直到整个表都满足次序要求为止。

它的基本思想是：依次比较相邻的两个数，如果不符合排序规则，则调换两个数的位置。这样一遍比较下来，能够保证最大（或最小）的数排在最后一位。再对最后一位以外的数组，重复前面的过程，直至全部排序完成。

以对数组[3, 2, 4, 5, 1, 4]进行从小到大排序为例，步骤如下：

1. 第一位的“3”与第二位的“2”进行比较，3大于2，互换位置，数组变成[2, 3, 4, 5, 1, 4]。

2. 第二位的“3”与第三位的“4”进行比较，3小于4，数组不变。

3. 第三位的“4”与第四位的“5”进行比较，4小于5，数组不变。

3. 第四位的“5”与第五位的“1”进行比较，5大于1，互换位置，数组变成[2, 3, 4, 1, 5, 4]。

4. 第五位的“5”与第六位的“4”进行比较，5大于4，互换位置，数组变成[2, 3, 4, 1, 4, 5]。

第一轮排序完成，可以看到最后一位的5，已经是最大的数了。然后，再对剩下的数[2, 3, 4, 1, 4]重复这个过程，每一轮都会在本轮最后一位上出现正确的数。直至剩下最后一个位置，所有排序结束。
## 算法实现

	def bubble_sort(lst):
	
	    i = 0
	    while i < len(lst):
	
	        j = 0  # 每一轮的比较都是从列表的第一项开始
	
	        while j < len(lst)-1:
	
	            if lst[j] > lst[j+1]:   # 前一项大于后一项交换元素（降序排列）
	
	                lst[j], lst[j+1] = lst[j+1], lst[j]  # swap element
	
	            j += 1
	
	        i += 1
	
	lst = [3, 2, 4, 5, 1, 4]
	bubble_sort(lst)
	print(lst)  # [1, 2, 3, 4, 4, 5]


## 复杂度
### 时间复杂度
冒泡排序是一个嵌套的循环，对于大小为n的列表，外部循环执行 n 次，内部循环每次都是执行n-1次，所以内部总共循环 n^2-n 次，当n足够大的时候，忽略常数项，因此冒泡排序的时间复杂度为O(n^2)。需要说明的是，如果列表本身是排序好的，冒泡排序不会执行任何交换。然而在最后情况(反序排列的情况)下冒泡排序的交换工作超过了线性方式。

### 空间复杂度
冒泡排序的空间复杂度为O(1)，因为只是用了2个循环变量以及1到2个标志和交换等的中间变量。

## 稳定性

分析稳定性之前首先要了解什么是稳定性，简单讲吧，要排序的数中有两个相同的数，用A算法进行排序后，两个相等数的位置不会互换，则A算法是稳定的，否则A不稳定。因此冒泡排序时稳定的。

## 补充
其实，我们可以对冒泡排序做一个简单的优化，将其在最好情况(按照要排序的规则已经排序好的情况)下的时间复杂度提高到线性阶O(n)；再通过主循环时，如果没有发生交换，那么列表是已经排序的，这种情况可能发生在任何一个轮次，但是，在最好情况下，第一轮就发生。

### 修改后的版本

	def bubble_sort(lst):
	
	    i = 0
	    while i < len(lst):
	
	        swapped = False  # 定义一个bool标志
	        j = 0  # 每一轮的比较都是从列表的第一项开始
	
	        while j < len(lst)-1:
	
	            if lst[j] > lst[j+1]:   # 前一项大于后一项交换元素（降序排列）
	
	                lst[j], lst[j+1] = lst[j+1], lst[j]  # swap element
	                swapped = True  # 记录发生了交换
	
	            j += 1
	            
	        if not swapped: # 如果一整轮没有发生交换，说明列表已经排好序了，就没必要在进行下去，直接return.
	            return 
	
	        i += 1

# 快速排序

## 简介
![](https://i.imgur.com/oXSblv6.gif)
快速排序也是一种交换类排序算法，快速排序由于排序效率在同为O(N*logN)的几种排序方法中效率较高，因此经常被采用，再加上快速排序思想----> **分治法** 确实实用，因此很多软件公司的笔试面试，包括像腾讯，微软等知名IT公司都喜欢考这个，还有大大小的程序方面的考试如软考，考研中也常常出现快速排序的身影。

快速排序是C.R.A.Hoare于1962年提出的一种划分交换排序。它采用了一种分治的策略，通常称其为分治法(Divide-and-ConquerMethod)。

它的基本思想是：

1．先从数列中取出一个数作为基准数。

2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。

3．再对左右区间重复第二步，直到各区间只有一个数。

## 基准数选择方式

对于分治算法，当每次划分时，算法若都能分成两个等长的子序列时，那么分治算法效率会达到最大。也就是说，基准的选择是很重要的。选择基准的方式决定了两个分割后两个子序列的长度，进而对整个算法的效率产生决定性影响。

1.固定基准元

通常的、没有经过充分考虑的选择是将第一个元素做为"基准“。如果输入的数是随机的，那么这是可以接受的。
但是如果输入是预排序的或是反序的，那么这样的”基准“就是一个糟糕的分割，因为所有的元素不是被划入S1就是被划入S2。
实际上，如果第一个元素用作”基准“而且输入是预先排序的，那么快速排序花费的时间将是二次的，可是实际上却没干什么事，因此，使用第一个元素作为”基准“一定要用对场景

2.随机基准元

一种安全的方法是随机选取”基准“。这种策略是非常安全的，除非随机生成器有问题，但是随机数的生成一般是昂贵的，减少不了算法其余部分的平均运行时间。

3.三数取中值

一组N个数的中值是第[N/2]个最大的数。”基准“的最好选择是数组的中值。但是这很难算出，且减慢快速排序的速度。这样的中值的估计量可以通过随机选取三个元素并用它们的中值作为”基准”而得到。实际上，随机性并没有多大的帮助，因此一般的做法是使用左端、右端和中心位置上的三个元素的中值作为“基准”。

## 算法实现

	def quick_sort(lst):
	    quick_sort_helper(lst, 0, len(lst)-1)
	
	
	def quick_sort_helper(lst, low, high):
	    if low >= high:
	        return
	    three_standard_value(lst, low, high)  # 这一句决定使用哪种取基准值方式
	    middle_index = partition(lst, low, high)
	    quick_sort_helper(lst, low, middle_index-1)
	    quick_sort_helper(lst, middle_index+1, high)
	
	
	def three_standard_value(lst, low, high):
	
	    ''' 三数取中确定基准元，将确定好的基准元与第一个数交换'''
	    mid = (high + low)//2
	
	    if lst[mid] > lst[high]:
	        lst[mid], lst[high] = lst[high], lst[mid]
	
	    if lst[low] > lst[high]:
	        lst[low], lst[high] = lst[high], lst[low]
	
	    if lst[mid] > lst[low]:
	        lst[mid], lst[low] = lst[low], lst[mid]
	
	
	def partition(lst, low, high):
	    key = lst[low]  # 取第一个数为基准值
	    while low < high:
	        while low < high and lst[high] >= key:  # 从列表右边开始把小于基准值的元素放到
	            high -= 1
	        lst[low] = lst[high]
	        while low < high and lst[low] <= key:
	            low += 1
	        lst[high] = lst[low]
	    lst[low] = key
	    return low

	lst = [3, 2, 4, 5, 1, 4]
	quick_sort(lst)
	print(lst)  # [1, 2, 3, 4, 4, 5]

## 复杂度

### 时间复杂度

快速排序涉及到递归调用，所以该算法的时间复杂度还需要从递归算法的复杂度开始说起；

递归算法的时间复杂度公式：T[n] = aT[n/b] + f(n)  ；

**最优情况下时间复杂度**：快速排序最优的情况就是每一次取到的元素都刚好平分整个数组；

此时的时间复杂度公式则为：T[n] = 2T[n/2] + f(n)；

T[n/2]为平分后的子数组的时间复杂度，f[n] 为平分这个数组时所花的时间；

下面来推算下，在最优的情况下快速排序时间复杂度的计算(用迭代法)：

      	T[n] =  2T[n/2] + n                                  ----------------第一次递归

    令：n = n/2       =  2 { 2 T[n/4] + (n/2) }  + n        ----------------第二次递归

                      =  2^2 T[ n/ (2^2) ] + 2n

    令：n = n/(2^2)   =  2^2  {  2 T[n/ (2^3) ]  + n/(2^2)}  +  2n   ----------------第三次递归  

                      =  2^3 T[  n/ (2^3) ]  + 3n

    ..................................................                  

    令：n = n/(  2^(m-1) )    =  2^m T[1]  + mn                   ----------------第m次递归(m次后结束)

当最后平分的不能再平分时，也就是说把公式一直往下跌倒，到最后得到T[1]时，说明这个公式已经迭代完了（T[1]是常量了）。

    得到：T[n/ (2^m) ]  =  T[1]    ===>>   n = 2^m   ====>> m = logn；

    T[n] = 2^m T[1] + mn ；其中m = logn;

    T[n] = 2^(logn) T[1] + nlogn  =  n T[1] + nlogn  =  n + nlogn  ；其中n为元素个数

    又因为当n >= 2时：nlogn  >=  n  (也就是logn > 1)，所以取后面的 nlogn；

综上所述：快速排序最优的情况下时间复杂度为：O( nlogn )


**最差情况下时间复杂度**：最差的情况就是每一次取到的元素是数组中最小/最大的，这种情况其实就是冒泡排序了(每一次都排好一个元素的顺序)。

这种情况时间复杂度就好计算了，就是冒泡排序的时间复杂度：T[n] = n * (n-1) = n^2 - n;

综上所述：快速排序最差的情况下时间复杂度为：O( n^2 )

**平均时间复杂度**：快速排序的平均时间复杂度也是：O(nlogn)

### 空间复杂度

其实这个空间复杂度不太好计算，因为有的人使用的是非就地排序，那样就不好计算了（因为有的人用到了辅助数组，所以这就要计算到你的元素个数了）；我就分析下就地快速排序的空间复杂度吧；

首先就地快速排序使用的空间是O(1)的，也就是个常数级；而真正消耗空间的就是递归调用了，因为每次递归就要保持一些数据；

**最优的情况下空间复杂度为**：O(logn)；每一次都平分数组的情况。

**最差的情况下空间复杂度为**：O(n)；退化为冒泡排序的情况。

## 稳定性
在快速排序中，相等元素可能会因为分区而交换顺序，所以它是不稳定的算法。

# 总结
冒泡排序简单但不高效，快速排序理解起来有点复杂，却很高效，但要注意基准值的选择方式。