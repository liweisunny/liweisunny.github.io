---
title: python之文件操作
date: 2017-11-22 15:35:28
tags: python基础
toc: true
categories: Python
---
首先，学习python，掌握文件操作这一技能是必不可少的，本篇博文由浅入深，详细介绍python中操作文件的各种方法、各种方法之间的对比以及如何高效的读取文件等；另外，牢记文件操作的三个步骤：<font color=#FF0000 size=3>(1)打开文件;(2)操作文件(3)关闭文件</font>。

<!--more-->

# 打开文件
Python中的file()与open()都能够打开文件，对文件进行操作，也具有相似的用法和参数，并且返回的都是一个文件对象；但是，这两种文件打开方式有本质的区别，file是一个类，用file()来打开文件，相当于是在构造文件类；而用open()打开文件，是用python的内建函数来操作，这是不一样的，另外python3已经不再支持file()了；So，<font color=#FF0000 size=5>**强烈建议使用open()函数**</font>。
## open()
打开指定路径的文件，如果文件不存在会自动创建，返回一个文件对象。

	open(file[, mode[, buffering[, encoding[, errors[, newline[, closefd=True]]]]]])

open函数有很多的参数，常用的是file，mode和encoding

1. file：文件路径包含文件名，需要加引号
2. mode：文件打开模式，见下面3
3. encoding：表示的是返回的数据采用何种编码，一般采用utf8或者gbk；
4. buffering(可选):控制着文件的缓冲，如果参数是0(或者是False)，I/O(输人/输出)就是无缓冲的(所有的读写操作都直接针对硬盘); 如果是1(或者是true), I/O就是有缓冲的(意味着Python使用内存来代替硬盘，让程序更快，只有使用flush或者close时才会更新硬盘上的数据;如果是大于1的数字代表缓冲区的大小(单位是字节)；如果是-1(或者是任何负数)代表使用默认的缓冲区大小；使用默认时会采用下面策略来选择：对于二进制文件模式时，采用固定块内存缓冲区方式，内存块的大小根据系统设备的分配的磁盘块来决定，如果获取系统磁盘块的大小失败，就使用内部常量io.DEFAULT_BUFFER_SIZE定义的大小。一般的操作系统上，块的大小是4096或者8192字节大小。对于交互的文本文件（采用isatty()判断为True）时，采用一行缓冲区的方式。其它文本文件使用跟二进制一样的方式。

## 文件模式

1. 'r'：读模式
2. 'w'：写模式，会先清空文件内容
3. 'a'：追加模式
4. 'b'：二进制模式（可添加到其他模式中使用，如：'rb'：表示读取二进制文件）
5.  '+'：读/写模式（可添加到其他模式中使用）
6.  'a+'：可读写模式，写只能写在文件末尾
7.  'w+'：可读写，与'a+'的区别是要清空文件内容(<font color=#FF0000 size=3>**不推荐使用**</font>)
8.  'r+'：可读写，与'a+'的区别是可以写到文件任何位置


## 代码演示

	>>> f=open('file.txt','r',encoding='utf-8')#以只读的模式打开一个文件，对读取的文件内容是utf-8编码。
	>>> f=open('file.txt','r+',encoding='utf-8')#以读写的模式打开一个文件，对读取的文件内容是utf-8编码。
	>>> f=open('file.txt','a',encoding='utf-8')#以追加的模式打开一个文件，对读取的文件内容是utf-8编码。
# 操作文件的方法
**示例文件内容：**

![](https://i.imgur.com/RMzpzSy.png)
## 读 read(),reabline(),readlines()
	>>> f=open('file.txt','r',encoding='gbk')
	>>> f.read()#读取全部内容,返回一个字符串
	python 文件操作
	python 字符串语法
	python 列表元祖字典
	python 中的变量
	>>> f.read(5)#读取指定长度的字符
	
	>>> f.readline()#读取一行内容，返回一个 字符串

	>>> f.readlines()#读取全部行，返回一个列表
	
	>>> f.close()
	
说明：上述代码第一个读取操作读取出了所有内容，剩下的读取到的都是空，原因是因为每执行一次读操作，都会记录下当前文件读取指针的位置，接下来的读操作是在上一次的读操作读取到的内容之后继续开始读取的。可以通过下面介绍的tell()方法获取当前指针所在位置，通过seek()方法设置指针位置。

## 写 write(),writelines()
	>>> f=open('file.txt','w',encoding='gbk')
	>>> f.write('python人生')#接受字符串 作为参数
	>>> f.writelines(['python生活','python前世'])#接受序列(字符串，列表，元祖)作为参数
	>>> f.close()
	python人生
	python生活
    python前世

说明：当以只写的模式打开文件的时候会先清空文件内容,另外多个连续写的操作也会有读操作时说到的光标注意事项；另外需要值得一提的时，写操作并不是直接把内容写到磁盘上，而是写到了缓冲区中即内存里。当调用f.close()方法时会把缓冲区的内容写入到磁盘

## 关闭文件close()
close()方法时用来关闭文件的，这是一种很重要但是容易被忘记的操作，虽然说即使我们不直接调用close()方法，python解释器 也会在程序执行完是帮我们关闭文件，但是依赖于解释器来关闭文件的行为是不安全的，所以，一定要在操作完文件后调用close()方法来关闭文件；为了避免忘记关闭文件，推荐一种打开文件的方式：

	with open('log', 'r') as f:
	     f.readline()
	     f.read()
    print('hello')
	
	#同时操作多个文件
	with open('log1','r') as f_read, open('log2','w') as f_write:
		for line in f_read:
			f_write.write(line)

说明：使用with语句操作文件会在with语句块执行完后自动调用close()方法关闭文件，推荐这种写法。

## flush
flush() 方法是用来刷新缓冲区的，即将缓冲区中的数据立刻写入文件，同时清空缓冲区，不需要是被动的等待输出缓冲区写入。一般情况下，文件关闭后会自动刷新缓冲区，但有时你需要在关闭前刷新它，这时就可以使用 flush() 方法。
	
	file.flush()#没有返回值

## tell(),seek()
### tell()
1. 作用：获取当前文件读取指针的位置
2. 语法格式： file.tell() 注： 此方法没有参数

### seek()
1. 作用：用于移动文件读写指针到指定位置
2. 语法格式：file.seek(offset,whence=0)；(1) offset:偏移量，需要向前或者向后移动的字节数(中文是3个字节)，(2) 可选值，默认为0, 可选值为1或者2，表示从何处开始计算偏移，具体来说，0表示从当前位置开始计算偏移，1表示从文件头位置开始计算偏移，2表示从文件尾开始计算偏移。

### 代码展示
	>>> x = file('file.txt', 'r')   
	>>> x.tell()           #获得当前文件读取指针  
	0L                     #当前文件指针在文件头处  
	>>> x.seek(3)          #将文件指针向前移动3个字节  
	>>> x.tell()  
	3L                     #指针已经移动到了第3个字节处  
	>>> x.seek(5,1)        #表示从文件头处开始移动指针，向前移动5个字节  
	>>> x.tell()                 
	5L                     #当前文件读取指针已经移动到第5个字节处  
	>>> x.seek(0,0)        #表示将文件指针移动到文件头处  
	>>> x.tell()  
	0L  
	>>> x.seek(0,2)        #表示将文件读取指针移动到文件尾部  
	>>> x.tell()                 
	214L                   #可以得到文件大小为214B  
	>>> x.seek(-2,2)       #表示从文件尾部开始移动指针，向后移动2个字节  
	>>> x.tell() 
	212L 
	
# 高效迭代文件内容
方式一：

	with open('file.txt','r',encoding='gbk') as file:
    	for line in file.readlines():
        	do_things(line)

方式二：

	with open('file.txt','r',encoding='gbk')as file:
    	line=file.readline()
    	while line:
        	line=file.readline()
        	do_things(line)

方式三：

	with open('file.txt','r',encoding='gbk') as file:
    	for line in file:
        	do_things(line)

说明：

第一种方式会一次性将文件中的内容加载到内存中然后对内存进行读操作。

第二种方式从磁盘上读取一条输出一条，不会将文件内容一次性加载到内存。

第三种方式直接迭代文件对象,for循环会把它当做一个迭代器，读取一行输出一行。

三种方式执行效率对比（<font color=#FF0000 size=5>本人测试数据，会有偏差</font>）：

1. 测试文件：1G的大文本文件；多次运行三种方式：第一种内存明显增加，执行时间在1分钟10秒左右；第二种内存没有增加，运行时间在1分钟15秒左右；第三种内存没有增加，运行时间在1分钟左右；
2. 测试文件：15MB小文本文件;多次运行三种方式：第一种内存明显增加，执行时间在1.2秒左右；第二种内存没有增加，运行时间在1.6秒左右；第三种内存没有增加，运行时间在1.2秒左右；

由此可知：小文本操作时，第二种方式执行相对较慢，不推荐使用，大文本操作时第一种方式会占用很大内存；另外无论是大文本操作还是小文本操作，第三种方式都是最节省内存执行时间最快的；So，极力推荐使用第三种方式

# 总结
上述介绍了基本的文件操作方式和一些注意事项，最后详细介绍了迭代文件内容最高效的方式，希望各位读者可以自己亲自动手尝试一些，这样会让你有更深层次的理解.


