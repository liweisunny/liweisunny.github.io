---
title: 数组&链表结构
date: 2018-02-03 08:48:12
tags: 数据结构
toc: true
categories: 数据结构与算法
---

在编程语言中，最常用来实现集合的两种数据结构——数组&链表结构，这两种类型的结构采用不同的方法在计算机内存中存储和访问数据，这些方法反过来导致了操作该集合的算法中的不同的时间/空间取舍。本文将详细介绍数组和链表结构的数据组织和处理方式。

<!--more-->

# 数组

数组（arry）表示的是可以在给定的索引位置访问或替代的项的一个序列。

使用python代码构造数组：

	class Array:
	    def __init__(self, size, fillValue = None):
	        self._items = []
	        for num in range(size):
	            self._items.append(fillValue)
	
	    def __len__(self):
	        return len(self._items)
	
	    def __str__(self):
	        return str(self._items)
	
	    def __iter__(self):
	        return iter(self._items)
	
	    def __getitem__(self, index):
	        return self._items[index]
	
	    def __setitem__(self, index, value):
	        self._items[index] = value
	        
	if __name__ == '__main__':
	    # 构造数组并使用
	    a = Array(5)
	    print(len(a))  # 5
	    print(a)  # [None, None, None, None, None]
	    for i in range(len(a)):
	        a[i] = i+1
	    for item in a:
	        print(item)  # 1,2,3,4,5  

## 随机访问和连续内存

数组支持索引访问，**索引访问实际上是一个随机访问**操作。那么随机访问是基于什么实现的呢？

**计算机通过为数组分配一段连续的内存单元，从而支持随机访问。**

![](https://i.imgur.com/smmbiqi.png)

在随机访问中，计算机通过执行一定数目的步骤，获取第i项的位置 。因此，不管数组有多大，它访问第i项所需的时间和访问最后1项所需的时间都是相同的。哇，是不是觉着好牛逼，太高效了；那么随机访问具体执行什么样的步骤呢？

数组某一项的地址可以通过将两个值相加来得出，即将数组的基本地址和项的偏移地址相加。数组的基本地址是数组的第1项的机器地址。一个项的偏移地址等于它的索引乘以数组的一项所需的内存单元数目的一个常量表示（在 python中，这个值总是1）。概括起来，数组中的索引操作(随机访问)有两个步骤：

1. 获取数组内存块的基本地址；
2. 给这个地址加上索引，返回最终结果。

## 静态内存和动态内存

在大多数编程语言中，像Java、C++、C#中，数组是静态的数据结构，数组的大小和长度都在编译时确定了，不能改变。如果对于一个已知的、项数固定的内存需求使用这种数组是没有问题的。但是很多情况下数组的项目数是变化的，这样程序就需要事先申请到足够的内存来保证运行时不会超出数组边界，这明显是很浪费内存的。还好，这些语言都提供了动态数组，可以在运行是根据需求 变化内存大小。

**像静态数组一样，动态数组占据了连续的内存块并且支持随机访问。**

**Python中的列表也是基于动态数组实现的。**

**动态数组长度调整方式：**

1. 在程序开始的时候创建一个具有合理默认大小的数组。
2. 当这个数组不能保存更多数据的时候，创建一个新的、更大的数组，并且从旧的数组转移数据项，将对旧数组的引用全部转移到新数组，然后回收旧数组。
3. 当数组似乎存在浪费的内存的时候（有一些数据已经被应用程序删除了），创建一个新的、小数组，并且从旧数组转移数据项，将对旧数组的引用全部转移到新数组，然后回收旧数组。

## 物理大小和逻辑大小

数组的物理大小是它的数组单元总数，或者说是创建数组时用来指定其容量的数字。

数组的逻辑大小是它当前可供应用程序使用的项目数。也就是说数组中实际包含的元素个数。

图 1.1展示了 具有相同物理大小但逻辑大小各不相同的3个数组。当前被数据占用的单元格用阴影表示。

![](https://i.imgur.com/Je6nFgV.png)

通常，逻辑大小和物理大小会告诉你关于数组状态的几件重要的事情：

1. 如果逻辑大小为0，则数组为空。
2. 否则，在任何给定的时间数组中最后一项的索引都是其逻辑大小减去1。
3. 如果逻辑大小等于物理大小，数组已经呗数据填满了。

## 数组操作

从第i个位置访问，其最好情况和最后情况下的时间复杂度均为O(1)。

从第i个位置替换，其最好情况和最后情况下的时间复杂度均为O(1)。

因为数组是连续的，知道每一个数据的内存地址，可以直接通过前文描述的方式找到该地址的数据。

从数组的逻辑末尾插入数据或者删除数据，其时间复杂度为O(1),前提是不涉及到调整数组大小。

从数组的第i个位置插入和删除数据，其平均情况下的时间复杂度为O(n)；因为涉及到移动元素，后面会详细介绍具体的操作步骤。

当数组涉及到调整大小的时候，该操作的时间复杂度为O(n)。

### 在数组中插入一项

向数组插入一项和替代数组中的一项是不同的。因为替代的情况下，给定的索引位置已经存在一项了，直接通过索引找到这一项重新赋值就可以了，数组的逻辑大小并不会改变，整个操作的时间复杂度为O(1)。
在插入的情况中，程序员必须做如下4个操作：

1. 在尝试一次插入或增加数组的物理大小之前，如果必要的话，先检查可用空间。
2. 从数组的逻辑末尾开始，直到目标索引位置，将每一项都向后移动一个单元。这个过程会在目标索引位置为新项打开一个‘洞’。
3. 将新的想赋值给 目标索引位置。
4. 将逻辑大小加1。

图 1.3展示了在拥有4项的一个数组中的位置1插入D5项的步骤：

![](https://i.imgur.com/MWfcqKW.png)

正如你看到的那样，项的移动顺序很重要，必须从数组的逻辑末尾开始，并且朝着目标索引的位置操作。

使用python 代码展示这个操作过程：

	for i in range(logicalSize, taegetIndex, -1):
    	a[i] = a[i-1]
	a[targetIndex] = newItem
	logicalSize += 1

	# a 为被操作的数组，logicalSize为数组的逻辑大小，targetIndex 为插入的目标索引。

由此可知，插入操作是线性的，即O(n)；从数组中删除一项是插入一项的反过程，时间复杂度也是线性的O(n)。

# 链表结构

链表不同于数组，数组必须存储在连续的内存中。这意味着，数组中项的逻辑顺序是和内存中的物理单元序列紧密耦合的，相反，链表结构使用的是一段非连续性内存，它将结构中的项的逻辑顺序和内存中的物理单元顺序解耦了。也就是说，只要计算机遵照链表结构中一个给定项的地址和位置的链接，就能够在内存中找到它的单元在何处。

因此，链表结构不支持索引访问，必须从结构的开始沿着链表直到达到想要的位置，查询要比数组低效；对于插入和删除操作，一旦找到一个插入点或删除点，就可以进行插入和删除，不需要在内存中移动数据项，另外在每一次的插入和删除的过程中，链表结构会调整大小，并且不需要额外的内存代价，也不需要赋值数据项。

在Java等现代语言中，单链表结构中的一个节点，包含了一个数据项和指针值（一个特殊的空值，表示指针值是一个空链接）。程序员并不使用数组来建立不连续的内存，而是直接向计算机请求一个指针指向一个新的节点，这个节点来自于名为对象堆的一个内建的不连续内存区域，然后程序员在该节点中设置了指向另一个节点的指针，由此建立了到结构中的其它数据的一个链接。

python程序员使用对对象的引用建立起了节点和和链表结构。在python中，任何变量都可以引用任何内容，包括None值，它意味着一个空的链接。

链表可分为有单链表和双向链表，下面我们分别介绍着两种链表。


## 单链表
单向链表的链表对象维护了一个 first 引用，该引用指向节点链表中的第一个节点对象，每个节点对象维护一个 next 引用，next引用指向下一个节点对象；（这里注意：是引用指向的是节点对象：节点对象包含存储的数据和next引用），图 1.4 是一个单链表的存储结构示意图。

![](https://i.imgur.com/lFku64N.png)

代码实现：

	# 定义 单链表
	class Node:
	    def __init__(self, data, next=None):
	        self.data = data
	        self.next = next
	
	    def __str__(self):
	        return str(self.data)
	
	# 构造链表
	head = None
	for count in range(1, 6):
	    head = Node(count, head)
	
### 单链表操作

#### 遍历
使用一个临时的指针变量 probe，这个变量先初始化为链表结构的head指针，然后控制整个循环：
	probe = head
	while probe:
	    print(probe) # 5,4,3,2,1
	    probe = probe.next

遍历操作时间上是线性的O(n),不需要额外的内存。

#### 搜索

一个链表结构的顺序搜索和遍历是类似的，因为必须从第一个节点开始并且沿着链接直到遇到哨兵。然而，可能会出现两个可能的哨兵。

1. 空链接，表明不在有要检查的数据。
2. 等于目标项的一个数据项，表明一次成功的搜索。

	probe = head
	while probe:
		if probe.data == targetItem:
			return 1 
		probe = probe.next
	return -1

毫不奇怪，平均情况下，对应单链表结构的顺序搜索是线性的O(n)。

#### 替换
在单链表结构中，替换操作也利用了遍历模式,下面代码实现了替换第i项,假设 0<=i<=n：

	probe = head
	while i > 0:
		probe = probe.next
		i -=  1
	probe.data = nexItem

替换操作也是线性的。

#### 任意位置插入
链表结构插入节点项需要考虑，如果插入位置为起始位置即 i=0,直接插入，将新插入项的next指针指向head；否则，则需要找到i-1的位置，如果该位置的next指针为None说明 i>=n，否则i<n。

代码实现：

	if head is None or i<=0:
		head = Node(newItem, head) # 无论head是否为None，新插入项的next指针都指向head
	else:
		probe = head
		while i>1 and probe.next:
			probe = probe.next
			i -= 1
		probe.next = Node(newItem, probe.next) # 将i-1项的next指针指向新项，新插入的项的next指针，指向原来第i个位置的项即probe.next

复杂度分析：如果插入位置为开始位置，时间复杂度为O(1),其他情况下的时间复杂度仍未O(n)；空间复杂度为O(1)

#### 任意位置删除
从一个链表结构删除第i项，具有以下3种情况：

1. i<=0 ，假设结构中至少有一个节点，删除第一项
2. 0<i<n 搜索位于i-1的位置的节点，删除其后面的节点。
3. i>=n 删除最后一个节点

代码实现：

	if i<=0 or head.next is None:
		removeItem = head.data
		head = head.next
		return removeItem
	else:
		probe = head
		while i>1 and probe.next.next:
			probe = probe.next
			i -= 1
		removeItem = probe.next.data
		probe.next = probe.next.next # 将i-1项的next指针指向i+1项，删除i项
		return removeItem


## 双链表结构
链表对象中维护一个first 引用和 last引用，分别指向链表中的首末节点对象；每个节点对象维护 存储的数据对象引用,prev和next引用，用来指向前后节点对象。

![](https://i.imgur.com/EmgdTWR.png)
	

代码实现：
	
	# 定义双链表结构
	class TowWayNode(Node):
	    def __init__(self, data, previous=None, next=None):
	        super(TowWayNode, self).__init__(data, next)
	        self.previous = previous
	
	# 构造链表
	head = TowWayNode(1)
	tail = head
	for data in range(2, 6):
	    tail.next = TowWayNode(data, tail) 
	    tail = tail.next  # tail尾指针指向最后一个节点
	    
	# 遍历链表
	probe = tail
	while probe:
	    print(probe.data)
	    probe = probe.previous

双链表除了在结构的末尾插入和删除操作是常数级的，其他操作的运行时间复杂度和单链表上对应的操作是相同的。然而，双链表结构中的指向前驱的指针，需要一个线性的内存使用量。

# 总结
数组使用的是一块连续的内存，所以其支持索引访问，并且索引访问的时间复杂度为O(1)；

对数组执行插入和删除操作时，平均时间复杂度为O(n),因为会涉及到项的移动，如果需要调整大小，需要额外O(n)的空间复杂度；

链表与数组不同，其使用的是一块非连续的内存，导致其不支持索引访问，查找某一项的时间复杂度为O(n)；

链表插入或删除某一项的平均时间复杂度也是O(n),但它占用的额外内存空间是O(1);

因此链表结构相对于数组的主要优点在于节省内存，当调整数组大小的时候其时间和内存都是线性的，但当调整链表大小时，其时间是线性的，但内存是常数的，另外，链表结构中不会存在浪费内存的问题。