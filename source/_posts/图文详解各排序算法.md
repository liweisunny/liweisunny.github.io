---
title: 图文详解各排序算法(一)
date: 2018-01-29 14:33:35
tags: 算法
toc: true
categories: 数据结构与算法
---
补习数据结构和算法的时候，很多都是用c或者java写的，正好在学习python，于是就顺便用python重构了一遍~

常见的排序算法有：选择排序、堆排序、冒泡排序、快速排序、(直接)插入排序、希尔排序、归并排序、基数排序等

我将会分成三篇博文依次介绍上述八大排序算法。

<!--more-->

# 选择排序
![](https://i.imgur.com/KYti7vg.gif)

## 简介

它的基本思想是：搜索整个列表找到最小项（最大项）的位置，如果该位置不是列表的第一个位置，算法就会交换在这两个位置的项，然后算法回到第二个位置并且重复这个过程（找出列表剩余项中最大或最小值得位置），当算法达到整个过程的最后一个位置，列表就是排序号的了。

以对数组[3, 2, 4, 5, 1, 4] 进行从小到大排序为例，步骤如下：

1. 假定第一位的“3”是最小值。

2. 最小值“3”与第二位的“2”进行比较，2小于3，所以新的最小值是第二位的“2”。

3. 最小值“2”与第三位的“4”进行比较，2小于4，最小值不变。

4. 最小值“2”与第四位的“5”进行比较，2小于5，最小值不变。

5. 最小值“2”与第五位的“1”进行比较，1小于2，所以新的最小值是第五位的“1”。

6. 最小值“1”与第六位的“4”进行比较，1小于4，最小值不变。

6. 第五位的“1”与第一位的“3”互换位置，数组变为[1, 2, 4, 5, 3, 4]。

这一轮比较结束后，最小值“1”已经排到正确的位置了，然后对剩下的[2, 4, 5, 3, 4]重复上面的过程。每一轮排序都会将该轮的最小值排到正确的位置，直至剩下最后一个位置，所有排序结束。

## 算法实现

	def select_sort(lst):
	    i = 0
	    while i < len(lst)-1:
	
	        j = i+1
	        min_index = i
	
	        while j < len(lst):
	            if lst[min_index] > lst[j]:
	                min_index = j
	            j += 1
	
	        if min_index != i:
	            lst[min_index], lst[i] = lst[i], lst[min_index]
	
	        i += 1
	
	lst = [3, 2, 4, 5, 1, 4]
	select_sort(lst)
	print(lst)  # [1, 2, 3, 4, 4, 5]


##复杂度
### 时间复杂度
选择排序是一个嵌套的循环，对于大小为n的列表，外部循环执行 n-1 次，第一次通过外围循环时，内部的循环执行 n-1次，第2次通过外围循环时，内部循环执行 n-2 次，依次类推，所以内部总共循环(n-1)+(n-2)+...+1=1/2(n^2-n) 次，当n足够大的时候，忽略常数项，因此选择排序的时间复杂度为O(n^2)。对于较大的数据集合，交换各项的开销可能也很显著。但选择排序相对冒泡排序来说，数据交换只是在外围循环中进行，所以在最坏情况下（反序排列的情况）选择排序的这一额外开销是线性的

### 空间复杂度
选择排序的空间复杂度为O(1)，因为只是用了2个循环变量以及1到2个标志和交换等的中间变量。

## 稳定性
选择排序针对相同的项，并不会发生交换，所以是稳定的


# 堆排序




