---
title: 图文详解各排序算法(一)
date: 2018-01-29 14:33:35
tags: 算法
toc: true
categories: 数据结构与算法
---
补习数据结构和算法的时候，很多都是用c或者java写的，正好在学习python，于是就顺便用python重构了一遍~

常见的排序算法有：选择排序、堆排序、冒泡排序、快速排序、(直接)插入排序、希尔排序、归并排序等

我将会分成三篇博文依次介绍上述七大排序算法。

<!--more-->

# 选择排序
![](https://i.imgur.com/KYti7vg.gif)

## 简介

它的基本思想是：搜索整个列表找到最小项（最大项）的位置，如果该位置不是列表的第一个位置，算法就会交换在这两个位置的项，然后算法回到第二个位置并且重复这个过程（找出列表剩余项中最大或最小值得位置），当算法达到整个过程的最后一个位置，列表就是排序号的了。

以对数组[3, 2, 4, 5, 1, 4] 进行从小到大排序为例，步骤如下：

1. 假定第一位的“3”是最小值。

2. 最小值“3”与第二位的“2”进行比较，2小于3，所以新的最小值是第二位的“2”。

3. 最小值“2”与第三位的“4”进行比较，2小于4，最小值不变。

4. 最小值“2”与第四位的“5”进行比较，2小于5，最小值不变。

5. 最小值“2”与第五位的“1”进行比较，1小于2，所以新的最小值是第五位的“1”。

6. 最小值“1”与第六位的“4”进行比较，1小于4，最小值不变。

6. 第五位的“1”与第一位的“3”互换位置，数组变为[1, 2, 4, 5, 3, 4]。

这一轮比较结束后，最小值“1”已经排到正确的位置了，然后对剩下的[2, 4, 5, 3, 4]重复上面的过程。每一轮排序都会将该轮的最小值排到正确的位置，直至剩下最后一个位置，所有排序结束。

## 算法实现

	def select_sort(lst):
	    i = 0
	    while i < len(lst)-1:
	
	        j = i+1
	        min_index = i
	
	        while j < len(lst):
	            if lst[min_index] > lst[j]:
	                min_index = j
	            j += 1
	
	        if min_index != i:
	            lst[min_index], lst[i] = lst[i], lst[min_index]
	
	        i += 1
	
	lst = [3, 2, 4, 5, 1, 4]
	select_sort(lst)
	print(lst)  # [1, 2, 3, 4, 4, 5]


##复杂度分析
### 时间复杂度
选择排序是一个嵌套的循环，对于大小为n的列表，外部循环执行 n-1 次，第一次通过外围循环时，内部的循环执行 n-1次，第2次通过外围循环时，内部循环执行 n-2 次，依次类推，所以内部总共循环(n-1)+(n-2)+...+1=1/2(n^2-n) 次，当n足够大的时候，忽略常数项，因此选择排序的时间复杂度为O(n^2)。对于较大的数据集合，交换各项的开销可能也很显著。但选择排序相对冒泡排序来说，数据交换只是在外围循环中进行，所以在最坏情况下（反序排列的情况）选择排序的这一额外开销是线性的

### 空间复杂度
选择排序的空间复杂度为O(1)，因为只是用了2个循环变量以及1到2个标志和交换等的中间变量。

## 稳定性
选择排序针对相同的项，并不会发生交换，所以是稳定的


# 堆排序

## 简介
在介绍堆排序之前，首先需要说明一下，堆是个什么玩意儿。

堆是一棵顺序存储的完全二叉树。

其中每个结点的关键字都不大于其孩子结点的关键字，这样的堆称为小根堆。

其中每个结点的关键字都不小于其孩子结点的关键字，这样的堆称为大根堆。

举例来说，对于n个元素的序列{R0, R1, ... , Rn}当且仅当满足下列关系之一时，称之为堆：

(1) Ri <= R2i+1 且 Ri <= R2i+2 (小根堆)

(2) Ri >= R2i+1 且 Ri >= R2i+2 (大根堆)

其中i=1,2,…,n/2向下取整; 

![](https://i.imgur.com/9iplLLi.png)

如上图所示，序列R{3, 8, 15, 31, 25}是一个典型的小根堆。

堆中有两个父结点，元素3和元素8。

元素3在数组中以R[0]表示，它的左孩子结点是R[1]，右孩子结点是R[2]。

元素8在数组中以R[1]表示，它的左孩子结点是R[3]，右孩子结点是R[4]，它的父结点是R[0]。可以看出，它们满足以下规律：

设当前元素在数组中以R[i]表示，那么，

(1) 它的左孩子结点是：**R[2*i+1]**;

(2) 它的右孩子结点是：**R[2*i+2]**;

(3) 它的父结点是：**R[(i-1)/2]**;

(4) **R[i] <= R[2*i+1] 且 R[i] <= R[2i+2]**。

**堆排序的基本思想：**

第一步按堆的定义将数组R[0..n]调整为堆（这个过程称为创建初始堆）；

第二步：交换R[0]和R[n]；

第三步：将R[0..n-1]调整为堆，然后重复第二步，交换R[0]和R[n-1]；

如此反复，直到交换了R[0]和R[1]为止。


以上思想可归纳为两个操作：

（1）根据初始数组去构造初始堆（构建一个完全二叉树，保证所有的父结点都不小于他的孩子节点）。

（2）每次交换第一个和最后一个元素，输出最后一个元素（最大值），然后把剩下元素重新调整为大根堆。 

当输出完最后一个元素后，这个数组已经是按照从小到大的顺序排列了。

先通过详细的实例图来看一下，如何构建初始堆。

设有一个无序序列 { 1, 3, 4, 5, 2, 6, 9, 7, 8, 0 }。

![](https://i.imgur.com/YNxUhPj.png)

构造了初始堆后，我们来看一下完整的堆排序处理流程：

还是针对前面提到的无序序列 { 1, 3, 4, 5, 2, 6, 9, 7, 8, 0 } 来加以说明。

![](https://i.imgur.com/ZuWTU25.png)

## 算法实现

	def heap_sort(lst):
	    length = len(lst)
	    # 初始化堆
	    i = length//2
	    while i >= 0:
	        init_heap(lst, i, length)
	        i -= 1
	
	    # 执行堆排序过程
	    j = length - 1
	    while j > 0:
	        lst[j], lst[0] = lst[0], lst[j]
	        # 筛选 R[0] 结点，得到i-1个结点的堆
	        init_heap(lst, 0, j)
	        j -= 1
	
	
	def init_heap(lst, parent, length):
	    temp = lst[parent]  # 保存当前父节点
	    child = 2 * parent + 1  # 先获得左孩子
	    while child < length:
	
	        if child + 1 < length and lst[child] < lst[child + 1]:  # 如果有右孩子结点，并且右孩子结点的值大于左孩子结点，则选取右孩子结点
	            child += 1
	
	        if temp >= lst[child]:  # 如果父结点的值已经大于孩子结点的值，则直接结束
	            break
	
	        lst[parent] = lst[child]  # 把孩子结点的值赋给父结点
	
	        parent = child  # 选取孩子结点的左孩子结点, 继续向下筛选
	        child = 2 * child + 1
	    lst[parent] = temp

	lst = [3, 2, 4, 5, 1, 4, 7]
	heap_sort(lst)
	print(lst)  # [1, 2, 3, 4, 4, 5, 7]

## 复杂度分析

堆排序的时间复杂度为O(nlogn),空间复杂度为O(1);

## 稳定性

堆排序是一种**不稳定**的排序方法。

因为在堆的调整过程中，关键字进行比较和交换所走的是该结点到叶子结点的一条路径，

因此对于相同的关键字就可能出现排在后面的关键字被交换到前面来的情况。