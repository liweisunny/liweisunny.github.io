---
title: python深浅拷贝剖析
date: 2017-11-24 13:07:50
tags: python基础
---
先明白，在Python中一切都是对象，比如说:3, 3.14, 'Hello', [1,2,3,4],（'12',5,6）,{'a':1}......
# 浅拷贝

案列：假设你想创建一对小夫妻的通用档案，名为 person.然后你分别为他俩拷贝一份

	>>> person=['name',['savings',100.00],'JJ']
	>>> hubby=person[:]#切片
	>>> wifey=list(person)#工厂函数list()
	>>> [id(x) for x in (person,hubby,wifey)]
	[1689804830152, 1689804830856, 1689804999752]
	>>> person[0]='Jack'
	>>> [x for x in (person,hubby,wifey)]
	[['Jack', ['savings', 100.0], 'JJ'], ['name', ['savings', 100.0], 'JJ'], ['name', ['savings', 100.0], 'JJ']]
	>>> person[1][1]=60
	>>> [x for x in (person,hubby,wifey)]
	[['Jack', ['savings', 60], 'JJ'], ['name', ['savings', 60], 'JJ'], ['name', ['savings', 60], 'JJ']]
	>>>
	>
<!--more-->

剖析：上面的例子中我们定义了一个列表person,然后使用切片方法和工厂函数list()生成了两个**“新”**列表，hubby和wifey；然后使用内建函数id()查看三个列表的id值,三个列表的id值均不同，这是为什么呢？然后，我们修改了person的第一个元素，发现只有person列表的值变化了，另外两个列表没有变化，但是当我们修改person(也可以是其他两个列表中的一个)的第二个元素的值时，三个列表都发生了变化，这是为啥子呢？

原因：我们仅仅做了一个**浅拷贝**。<font size=5 color=red>对一个对象进行浅拷贝其实是新创建了一个类型跟原对象一样,其内容是原来对象元素的引用的对象</font>,换句话说,这个拷贝的对象本身是新的（**所以三个列表id值不同**）,但是它的内容不是。序列类型对象的浅拷贝是默认类型拷贝,并可以以下几种方式实施:(1)切片操作[:],(2)利用工厂函数,比如 list(),dict()等,(3)使用 copy 模块的 copy 函数。

上面的解释貌似只解释了一个问题，第二个问题是为啥呢？

原因：在这几个列表的两个对象中,第一个对象是不可变的(是个字符串类型),而第二个是可变的(一个列表).正因为如此,当进行浅拷贝时,字符串被显式的拷贝,并新创建了一个字符串对象,而列表元素只是把它的引用复制了一下,并不是它的成员（<font size=4 color=red>简单的理解，浅拷贝只能拷贝一层</font>）。所以改变名字没有任何问题,但是更改他们银行账号的任何信息都会引发问题。

接下来我们看一下三个列表中，每个元素的id值的变化：

修改前：

	>>> [id(x) for x in person]
	[1689774975888, 1689804999944, 1689804828320]
	>>> [id(x) for x in hubby]
	[1689774975888, 1689804999944, 1689804828320]
	>>> [id(x) for x in wifey]
	[1689774975888, 1689804999944, 1689804828320]
	>>>

修改后：

	>>> [id(x) for x in person]
	[1689804828600, 1689804830984, 1689804828320]
	>>> [id(x) for x in hubby]
	[1689774975888, 1689804830984, 1689804828320]
	>>> [id(x) for x in wifey]
	[1689774975888, 1689804830984, 1689804828320]
	>>>

# 深拷贝

我们用深拷贝的方式实现上面的案列：

	>>> import copy
	>>> person=['name',['savings',100.00],'JJ']
	>>> hubby=copy.deepcopy(person)
	>>> wifey=copy.copy(person)
	>>> [id(x) for x in (person,hubby,wifey)]
	[1689806469640, 1689804999688, 1689804830152]
	>>> person[0]='Jack'
	>>> [x for x in (person,hubby,wifey)]
	[['Jack', ['savings', 100.0], 'JJ'], ['name', ['savings', 100.0], 'JJ'], ['name', ['savings', 100.0], 'JJ']]
	>>> person[1][1]=60
	>>> [x for x in (person,hubby,wifey)]  #结果不一样了
	[['Jack', ['savings', 60], 'JJ'], ['name', ['savings', 100.0], 'JJ'], ['name', ['savings', 60], 'JJ']]
	>>>

注意点

第一,非容器类型(比如数字,字符串和其他“原子”类型的对象,像代码,类型和 xrange 对象等)没有被拷贝一说。

第二,如果元组变量只包含原子类型对象,对它的深拷贝将不会进行.如果我们把账户信息改成元组类型,那么即便按我们的要求使用深拷贝操作也只能得到一个浅拷贝。
	
	>>> import copy
	>>> person = ['name', ('savings', 100.00)]
	>>> newPerson = copy.deepcopy(person)
	>> [id(x) for x in (person, newPerson)]
	[1689804999752, 1689804999944]
	>>> [id(x) for x in person]
	[1689774975888, 1689805087240]
	>>> [id(x) for x in newPerson]
	[1689774975888, 1689805087240]
	>>>

说明：原子类型对象：数值（所有的数值类型），字符串

# 结论

<font size=4 color=red>
**深浅拷贝都是对源对象的复制，占用不同的内存空间**

**如果源对象只有一级目录的话，源做任何改动，不影响深浅拷贝对象**

**如果源对象不止一级目录的话，源做任何改动，都要影响浅拷贝，但不影响深拷贝**

**序列对象的切片以及使用工厂函数list(),dict()等是浅拷贝，即只拷贝顶级的对象。**
</font>